This file is part of MXE.
See index.html for further information.

- 32-bit fixes for GCC ASM
- 64-bit support for most MMX functions

See https://gitorious.org/sdlgfx/asm
and http://sourceforge.net/p/sdl2gfx/code/HEAD/tree/trunk/SDL2_imageFilter.c

--- a/SDL_imageFilter.c
+++ b/SDL_imageFilter.c
@@ -3,6 +3,7 @@
 SDL_imageFilter.c: byte-image "filter" routines
 
 Copyright (C) 2001-2012  Andreas Schiffler
+Copyright (C) 2013  Sylvain Beucler
 
 This software is provided 'as-is', without any express or implied
 warranty. In no event will the authors be held liable for any damages
@@ -41,6 +42,15 @@ him for his work.
 #include <stdlib.h>
 #include <string.h>
 
+/* Use GCC intrinsics if available: they support both i386 and x86_64,
+   provide ASM-grade performances, and lift the PUSHA/POPA issues. */
+#ifdef __GNUC__
+#  ifdef USE_MMX
+#    include <mmintrin.h>
+#  endif
+#  include <SDL_cpuinfo.h>
+#endif
+
 #include "SDL_imageFilter.h"
 
 /*!
@@ -61,38 +71,6 @@ static int SDL_imageFilterUseMMX = 1;
 #endif
 
 /*!
-\brief Internal function returning the CPU flags. 
-
-\returns Flags of system CPU.
-*/
-unsigned int _cpuFlags()
-{
-	unsigned int flags = 0;
-
-#ifdef USE_MMX
-#if !defined(GCC__)
-	__asm
-	{
-		pusha
-			mov eax, 1
-			cpuid	/* get CPU ID flag */
-			mov flags,edx	/* move result to mmx_bit */
-			popa
-	}
-#else
-	asm volatile ("pusha		     \n\t" "mov    %1, %%eax     \n\t"	/* request feature flag */
-		"cpuid                \n\t"	/* get CPU ID flag */
-		"mov    %%edx, %0     \n\t"	/* move result to mmx_bit */
-		"popa		     \n\t":"=m" (flags)	/* %0 */
-		:"i"(0x00000001)	/* %1 */
-		);
-#endif
-#endif
-
-	return (flags);
-}
-
-/*!
 \brief MMX detection routine (with override flag). 
 
 \returns 1 of MMX was detected, 0 otherwise.
@@ -106,11 +84,7 @@ int SDL_imageFilterMMXdetect(void)
 		return (0);
 	}
 
-	mmx_bit = _cpuFlags();
-	mmx_bit &= 0x00800000;
-	mmx_bit = (mmx_bit && 0x00800000);
-
-	return (int)(mmx_bit);
+        return SDL_HasMMX();
 }
 
 /*!
@@ -141,7 +115,7 @@ void SDL_imageFilterMMXon()
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterAddMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
+static int SDL_imageFilterAddMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -167,26 +141,18 @@ L1010:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "mov          %2, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %1, %%ebx \n\t"	/* load Src2 address into ebx */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %3, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm1 \n\t"    	/* load 8 bytes from Src1 into mm1 */
-		"paddusb (%%ebx), %%mm1 \n\t"	/* mm1=Src1+Src2 (add 8 bytes with saturation) */
-		"movq    %%mm1, (%%edi) \n\t"	/* store result in Dest */
-		"add          $8, %%eax \n\t"	/* increase Src1, Src2 and Dest  */
-		"add          $8, %%ebx \n\t"	/* register pointers by 8 */
-		"add          $8, %%edi \n\t" "dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz             1b     \n\t"     /* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src2),		/* %1 */
-		"m"(Src1),		/* %2 */
-		"m"(SrcLength)		/* %3 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mSrc2 = (__m64*)Src2;
+	__m64 *mDest = (__m64*)Dest;
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		*mDest = _m_paddusb(*mSrc1, *mSrc2);	/* Src1+Src2 (add 8 bytes with saturation) */
+		mSrc1++;
+		mSrc2++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -266,7 +232,7 @@ int SDL_imageFilterAdd(unsigned char *Src1, unsigned char *Src2, unsigned char *
 ]
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterMeanMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength,
+static int SDL_imageFilterMeanMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength,
 						   unsigned char *Mask)
 {
 #ifdef USE_MMX
@@ -303,39 +269,25 @@ L21011:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "movl         %4, %%edx \n\t"	/* load Mask address into edx */
-		"movq    (%%edx), %%mm0 \n\t"	/* load Mask into mm0 */
-		"mov          %2, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %1, %%ebx \n\t"	/* load Src2 address into ebx */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %3, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1:                      \n\t"
-		"movq    (%%eax), %%mm1 \n\t"	/* load 8 bytes from Src1 into mm1 */
-		"movq    (%%ebx), %%mm2 \n\t"	/* load 8 bytes from Src2 into mm2 */
-		/* --- Byte shift via Word shift --- */
-		"psrlw        $1, %%mm1 \n\t"	/* shift 4 WORDS of mm1 1 bit to the right */
-		"psrlw        $1, %%mm2 \n\t"	/* shift 4 WORDS of mm2 1 bit to the right */
-		/*      "pand      %%mm0, %%mm1 \n\t"    // apply Mask to 8 BYTES of mm1 */
-		".byte     0x0f, 0xdb, 0xc8 \n\t"
-		/*      "pand      %%mm0, %%mm2 \n\t"    // apply Mask to 8 BYTES of mm2 */
-		".byte     0x0f, 0xdb, 0xd0 \n\t" 
-		"paddusb   %%mm2, %%mm1 \n\t"	/* mm1=mm1+mm2 (add 8 bytes with saturation) */
-		"movq    %%mm1, (%%edi) \n\t"	/* store result in Dest */
-		"add          $8, %%eax \n\t"	/* increase Src1, Src2 and Dest  */
-		"add          $8, %%ebx \n\t"	/* register pointers by 8 */
-		"add          $8, %%edi \n\t" 
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"     /* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src2),		/* %1 */
-		"m"(Src1),		/* %2 */
-		"m"(SrcLength),		/* %3 */
-		"m"(Mask)			/* %4 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mSrc2 = (__m64*)Src2;
+	__m64 *mDest = (__m64*)Dest;
+	__m64 *mMask = (__m64*)Mask;
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		__m64 mm1 = *mSrc1,
+		      mm2 = *mSrc2;
+		mm1 = _m_psrlwi(mm1, 1);	/* shift 4 WORDS of mm1 1 bit to the right */
+		mm2 = _m_psrlwi(mm2, 1);	/* shift 4 WORDS of mm2 1 bit to the right */
+		mm1 = _m_pand(mm1, *mMask);	/* apply Mask to 8 BYTES of mm1 */
+		mm2 = _m_pand(mm2, *mMask);	/* apply Mask to 8 BYTES of mm2 */
+		*mDest = _m_paddusb(mm1, mm2);	/* mm1+mm2 (add 8 bytes with saturation) */
+		mSrc1++;
+		mSrc2++;
+		mDest++;
+	}
+	_m_empty();				/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -412,7 +364,7 @@ int SDL_imageFilterMean(unsigned char *Src1, unsigned char *Src2, unsigned char
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterSubMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
+static int SDL_imageFilterSubMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -438,26 +390,18 @@ L1012:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "mov %2, %%eax \n\t"	/* load Src1 address into eax */
-		"mov %1, %%ebx \n\t"	/* load Src2 address into ebx */
-		"mov %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov %3, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16       \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm1 \n\t"     /* load 8 bytes from Src1 into mm1 */
-		"psubusb (%%ebx), %%mm1 \n\t"	/* mm1=Src1-Src2 (sub 8 bytes with saturation) */
-		"movq    %%mm1, (%%edi) \n\t"	/* store result in Dest */
-		"add $8, %%eax \n\t"	/* increase Src1, Src2 and Dest  */
-		"add $8, %%ebx \n\t"	/* register pointers by 8 */
-		"add $8, %%edi \n\t" "dec %%ecx     \n\t"	/* decrease loop counter */
-		"jnz 1b         \n\t"     /* check loop termination, proceed if required */
-		"emms          \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src2),		/* %1 */
-		"m"(Src1),		/* %2 */
-		"m"(SrcLength)		/* %3 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mSrc2 = (__m64*)Src2;
+	__m64 *mDest = (__m64*)Dest;
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		*mDest = _m_psubusb(*mSrc1, *mSrc2);	/* Src1-Src2 (sub 8 bytes with saturation) */
+		mSrc1++;
+		mSrc2++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -535,7 +479,7 @@ int SDL_imageFilterSub(unsigned char *Src1, unsigned char *Src2, unsigned char *
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterAbsDiffMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
+static int SDL_imageFilterAbsDiffMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -564,29 +508,20 @@ L1013:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "mov %2, %%eax \n\t"	/* load Src1 address into eax */
-		"mov %1, %%ebx \n\t"	/* load Src2 address into ebx */
-		"mov %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov %3, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16       \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm1 \n\t"     /* load 8 bytes from Src1 into mm1 */
-		"movq    (%%ebx), %%mm2 \n\t"	/* load 8 bytes from Src2 into mm2 */
-		"psubusb (%%ebx), %%mm1 \n\t"	/* mm1=Src1-Src2 (sub 8 bytes with saturation) */
-		"psubusb (%%eax), %%mm2 \n\t"	/* mm2=Src2-Src1 (sub 8 bytes with saturation) */
-		"por       %%mm2, %%mm1 \n\t"	/* combine both mm2 and mm1 results */
-		"movq    %%mm1, (%%edi) \n\t"	/* store result in Dest */
-		"add $8, %%eax \n\t"	/* increase Src1, Src2 and Dest  */
-		"add $8, %%ebx \n\t"	/* register pointers by 8 */
-		"add $8, %%edi \n\t" "dec %%ecx     \n\t"	/* decrease loop counter */
-		"jnz 1b        \n\t"      /* check loop termination, proceed if required */
-		"emms          \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src2),		/* %1 */
-		"m"(Src1),		/* %2 */
-		"m"(SrcLength)		/* %3 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mSrc2 = (__m64*)Src2;
+	__m64 *mDest = (__m64*)Dest;
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		__m64 mm1 = _m_psubusb(*mSrc2, *mSrc1);	/* Src1-Src2 (sub 8 bytes with saturation) */
+		__m64 mm2 = _m_psubusb(*mSrc1, *mSrc2);	/* Src2-Src1 (sub 8 bytes with saturation) */
+		*mDest = _m_por(mm1, mm2);		/* combine both mm2 and mm1 results */
+		mSrc1++;
+		mSrc2++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -662,7 +597,7 @@ int SDL_imageFilterAbsDiff(unsigned char *Src1, unsigned char *Src2, unsigned ch
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterMultMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
+static int SDL_imageFilterMultMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -707,45 +642,73 @@ L1014:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "mov %2, %%eax \n\t"	/* load Src1 address into eax */
-		"mov %1, %%ebx \n\t"	/* load Src2 address into ebx */
-		"mov %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov %3, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		"pxor      %%mm0, %%mm0 \n\t"	/* zero mm0 register */
-		".align 16       \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm1 \n\t"     /* load 8 bytes from Src1 into mm1 */
-		"movq    (%%ebx), %%mm3 \n\t"	/* load 8 bytes from Src2 into mm3 */
-		"movq      %%mm1, %%mm2 \n\t"	/* copy mm1 into mm2 */
-		"movq      %%mm3, %%mm4 \n\t"	/* copy mm3 into mm4  */
-		"punpcklbw %%mm0, %%mm1 \n\t"	/* unpack low  bytes of Src1 into words */
-		"punpckhbw %%mm0, %%mm2 \n\t"	/* unpack high bytes of Src1 into words */
-		"punpcklbw %%mm0, %%mm3 \n\t"	/* unpack low  bytes of Src2 into words */
-		"punpckhbw %%mm0, %%mm4 \n\t"	/* unpack high bytes of Src2 into words */
-		"pmullw    %%mm3, %%mm1 \n\t"	/* mul low  bytes of Src1 and Src2  */
-		"pmullw    %%mm4, %%mm2 \n\t"	/* mul high bytes of Src1 and Src2 */
-		/* Take abs value of the results (signed words) */
-		"movq      %%mm1, %%mm5 \n\t"	/* copy mm1 into mm5 */
-		"movq      %%mm2, %%mm6 \n\t"	/* copy mm2 into mm6 */
-		"psraw       $15, %%mm5 \n\t"	/* fill mm5 words with word sign bit */
-		"psraw       $15, %%mm6 \n\t"	/* fill mm6 words with word sign bit */
-		"pxor      %%mm5, %%mm1 \n\t"	/* take 1's compliment of only neg. words */
-		"pxor      %%mm6, %%mm2 \n\t"	/* take 1's compliment of only neg. words */
-		"psubsw    %%mm5, %%mm1 \n\t"	/* add 1 to only neg. words, W-(-1) or W-0 */
-		"psubsw    %%mm6, %%mm2 \n\t"	/* add 1 to only neg. words, W-(-1) or W-0 */
-		"packuswb  %%mm2, %%mm1 \n\t"	/* pack words back into bytes with saturation */
-		"movq    %%mm1, (%%edi) \n\t"	/* store result in Dest */
-		"add $8, %%eax \n\t"	/* increase Src1, Src2 and Dest  */
-		"add $8, %%ebx \n\t"	/* register pointers by 8 */
-		"add $8, %%edi \n\t" "dec %%ecx     \n\t"	/* decrease loop counter */
-		"jnz 1b        \n\t"      /* check loop termination, proceed if required */
-		"emms          \n\t"	/* exit MMX state */
-		"popa \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src2),		/* %1 */
-		"m"(Src1),		/* %2 */
-		"m"(SrcLength)		/* %3 */
-		);
+	/* i386 ASM with constraints: */
+	/* asm volatile ( */
+	/* 	"shr $3, %%ecx \n\t"	/\* counter/8 (MMX loads 8 bytes at a time) *\/ */
+	/* 	"pxor      %%mm0, %%mm0 \n\t"	/\* zero mm0 register *\/ */
+	/* 	".align 16       \n\t"	/\* 16 byte alignment of the loop entry *\/ */
+	/* 	"1: movq (%%eax), %%mm1 \n\t"     /\* load 8 bytes from Src1 into mm1 *\/ */
+	/* 	"movq    (%%ebx), %%mm3 \n\t"	/\* load 8 bytes from Src2 into mm3 *\/ */
+	/* 	"movq      %%mm1, %%mm2 \n\t"	/\* copy mm1 into mm2 *\/ */
+	/* 	"movq      %%mm3, %%mm4 \n\t"	/\* copy mm3 into mm4  *\/ */
+	/* 	"punpcklbw %%mm0, %%mm1 \n\t"	/\* unpack low  bytes of Src1 into words *\/ */
+	/* 	"punpckhbw %%mm0, %%mm2 \n\t"	/\* unpack high bytes of Src1 into words *\/ */
+	/* 	"punpcklbw %%mm0, %%mm3 \n\t"	/\* unpack low  bytes of Src2 into words *\/ */
+	/* 	"punpckhbw %%mm0, %%mm4 \n\t"	/\* unpack high bytes of Src2 into words *\/ */
+	/* 	"pmullw    %%mm3, %%mm1 \n\t"	/\* mul low  bytes of Src1 and Src2  *\/ */
+	/* 	"pmullw    %%mm4, %%mm2 \n\t"	/\* mul high bytes of Src1 and Src2 *\/ */
+	/* 	/\* Take abs value of the results (signed words) *\/ */
+	/* 	"movq      %%mm1, %%mm5 \n\t"	/\* copy mm1 into mm5 *\/ */
+	/* 	"movq      %%mm2, %%mm6 \n\t"	/\* copy mm2 into mm6 *\/ */
+	/* 	"psraw       $15, %%mm5 \n\t"	/\* fill mm5 words with word sign bit *\/ */
+	/* 	"psraw       $15, %%mm6 \n\t"	/\* fill mm6 words with word sign bit *\/ */
+	/* 	"pxor      %%mm5, %%mm1 \n\t"	/\* take 1's compliment of only neg. words *\/ */
+	/* 	"pxor      %%mm6, %%mm2 \n\t"	/\* take 1's compliment of only neg. words *\/ */
+	/* 	"psubsw    %%mm5, %%mm1 \n\t"	/\* add 1 to only neg. words, W-(-1) or W-0 *\/ */
+	/* 	"psubsw    %%mm6, %%mm2 \n\t"	/\* add 1 to only neg. words, W-(-1) or W-0 *\/ */
+	/* 	"packuswb  %%mm2, %%mm1 \n\t"	/\* pack words back into bytes with saturation *\/ */
+	/* 	"movq    %%mm1, (%%edi) \n\t"	/\* store result in Dest *\/ */
+	/* 	"add $8, %%eax \n\t"	/\* increase Src1, Src2 and Dest  *\/ */
+	/* 	"add $8, %%ebx \n\t"	/\* register pointers by 8 *\/ */
+	/* 	"add $8, %%edi \n\t" */
+	/* 	"dec %%ecx     \n\t"	/\* decrease loop counter *\/ */
+	/* 	"jnz 1b        \n\t"	/\* check loop termination, proceed if required *\/ */
+	/* 	"emms          \n\t"	/\* exit MMX state *\/ */
+	/* 	: "+a" (Src1),		/\* load Src1 address into rax, modified by the loop *\/ */
+	/* 	  "+b" (Src2),		/\* load Src2 address into rbx, modified by the loop *\/ */
+	/* 	  "+c" (SrcLength),	/\* load loop counter (SIZE) into rcx, modified by the loop *\/ */
+	/* 	  "+D" (Dest)		/\* load Dest address into rdi, modified by the loop *\/ */
+	/* 	: */
+	/* 	: "memory",		/\* *Dest is modified *\/ */
+        /*           "mm0","mm1","mm2","mm3","mm4","mm5","mm6"	/\* registers modified *\/ */
+	/* ); */
+
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mSrc2 = (__m64*)Src2;
+	__m64 *mDest = (__m64*)Dest;
+	__m64 mm0 = _m_from_int(0); /* zero mm0 register */
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		__m64 mm1, mm2, mm3, mm4, mm5, mm6;
+		mm1 = _m_punpcklbw(*mSrc1, mm0);	/* unpack low  bytes of Src1 into words */
+		mm2 = _m_punpckhbw(*mSrc1, mm0);	/* unpack high bytes of Src1 into words */
+		mm3 = _m_punpcklbw(*mSrc2, mm0);	/* unpack low  bytes of Src2 into words */
+		mm4 = _m_punpckhbw(*mSrc2, mm0);	/* unpack high bytes of Src2 into words */
+		mm1 = _m_pmullw(mm1, mm3);		/* mul low  bytes of Src1 and Src2  */
+		mm2 = _m_pmullw(mm2, mm4);		/* mul high bytes of Src1 and Src2 */
+		mm5 = _m_psrawi(mm1, 15);		/* fill mm5 words with word sign bit */
+		mm6 = _m_psrawi(mm2, 15);		/* fill mm6 words with word sign bit */
+		mm1 = _m_pxor(mm1, mm5);		/* take 1's compliment of only neg. words */
+		mm2 = _m_pxor(mm2, mm6);		/* take 1's compliment of only neg. words */
+		mm1 = _m_psubsw(mm1, mm5);		/* add 1 to only neg. words, W-(-1) or W-0 */
+		mm2 = _m_psubsw(mm2, mm6);		/* add 1 to only neg. words, W-(-1) or W-0 */
+		*mDest = _m_packuswb(mm1, mm2);		/* pack words back into bytes with saturation */
+		mSrc1++;
+		mSrc2++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -850,23 +813,34 @@ L10141:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "mov %2, %%edx \n\t"	/* load Src1 address into edx */
-		"mov %1, %%esi \n\t"	/* load Src2 address into esi */
-		"mov %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov %3, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
+	/* Note: ~5% gain on i386, less efficient than C on x86_64 */
+	/* Also depends on whether this function is static (?!) */
+	asm volatile (
 		".align 16       \n\t"	/* 16 byte alignment of the loop entry */
+#  if defined(i386)
 		"1:mov  (%%edx), %%al \n\t"      /* load a byte from Src1 */
 		"mulb (%%esi)       \n\t"	/* mul with a byte from Src2 */
 		"mov %%al, (%%edi)  \n\t"       /* move a byte result to Dest */
 		"inc %%edx \n\t"		/* increment Src1, Src2, Dest */
 		"inc %%esi \n\t"		/* pointer registers by one */
-		"inc %%edi \n\t" "dec %%ecx      \n\t"	/* decrease loop counter */
-		"jnz 1b         \n\t"     /* check loop termination, proceed if required */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src2),		/* %1 */
-		"m"(Src1),		/* %2 */
-		"m"(SrcLength)		/* %3 */
+		"inc %%edi \n\t"
+		"dec %%ecx      \n\t"	/* decrease loop counter */
+#  elif defined(__x86_64__)
+		"1:mov  (%%rdx), %%al \n\t"      /* load a byte from Src1 */
+		"mulb (%%rsi)       \n\t"	/* mul with a byte from Src2 */
+		"mov %%al, (%%rdi)  \n\t"       /* move a byte result to Dest */
+		"inc %%rdx \n\t"		/* increment Src1, Src2, Dest */
+		"inc %%rsi \n\t"		/* pointer registers by one */
+		"inc %%rdi \n\t"
+		"dec %%rcx      \n\t"	/* decrease loop counter */
+#  endif
+		"jnz 1b         \n\t"	/* check loop termination, proceed if required */
+		: "+d" (Src1),		/* load Src1 address into edx */
+		  "+S" (Src2),		/* load Src2 address into esi */
+		  "+c" (SrcLength),	/* load loop counter (SIZE) into ecx */
+		  "+D" (Dest)		/* load Dest address into edi */
+		:
+		: "memory", "rax"
 		);
 #endif
 	return (0);
@@ -927,8 +901,7 @@ int SDL_imageFilterMultNor(unsigned char *Src1, unsigned char *Src2, unsigned ch
 
 	/* C routine to process image */
 	for (i = istart; i < length; i++) {
-		result = (int) *cursrc1 * (int) *cursrc2;
-		*curdst = (unsigned char) result;
+		*curdst = (int)*cursrc1 * (int)*cursrc2;  // (int) for efficiency
 		/* Advance pointers */
 		cursrc1++;
 		cursrc2++;
@@ -948,7 +921,7 @@ int SDL_imageFilterMultNor(unsigned char *Src1, unsigned char *Src2, unsigned ch
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterMultDivby2MMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
+static int SDL_imageFilterMultDivby2MMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -986,38 +959,28 @@ L1015:
 			popa
 	}
 #else
-	asm volatile
-		("pusha \n\t" "mov %2, %%eax \n\t"	/* load Src1 address into eax */
-		"mov %1, %%ebx \n\t"	/* load Src2 address into ebx */
-		"mov %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov %3, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		"pxor      %%mm0, %%mm0 \n\t"	/* zero mm0 register */
-		".align 16       \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm1 \n\t"	/* load 8 bytes from Src1 into mm1 */
-		"movq    (%%ebx), %%mm3 \n\t"	/* load 8 bytes from Src2 into mm3 */
-		"movq      %%mm1, %%mm2 \n\t"	/* copy mm1 into mm2 */
-		"movq      %%mm3, %%mm4 \n\t"	/* copy mm3 into mm4  */
-		"punpcklbw %%mm0, %%mm1 \n\t"	/* unpack low  bytes of Src1 into words */
-		"punpckhbw %%mm0, %%mm2 \n\t"	/* unpack high bytes of Src1 into words */
-		"punpcklbw %%mm0, %%mm3 \n\t"	/* unpack low  bytes of Src2 into words */
-		"punpckhbw %%mm0, %%mm4 \n\t"	/* unpack high bytes of Src2 into words */
-		"psrlw        $1, %%mm1 \n\t"	/* divide mm1 words by 2, Src1 low bytes */
-		"psrlw        $1, %%mm2 \n\t"	/* divide mm2 words by 2, Src1 high bytes */
-		"pmullw    %%mm3, %%mm1 \n\t"	/* mul low  bytes of Src1 and Src2  */
-		"pmullw    %%mm4, %%mm2 \n\t"	/* mul high bytes of Src1 and Src2 */
-		"packuswb  %%mm2, %%mm1 \n\t"	/* pack words back into bytes with saturation */
-		"movq    %%mm1, (%%edi) \n\t"	/* store result in Dest */
-		"add $8, %%eax \n\t"	/* increase Src1, Src2 and Dest  */
-		"add $8, %%ebx \n\t"	/* register pointers by 8 */
-		"add $8, %%edi \n\t" "dec %%ecx     \n\t"	/* decrease loop counter */
-		"jnz 1b        \n\t"	/* check loop termination, proceed if required */
-		"emms          \n\t"	/* exit MMX state */
-		"popa \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src2),		/* %1 */
-		"m"(Src1),		/* %2 */
-		"m"(SrcLength)		/* %3 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mSrc2 = (__m64*)Src2;
+	__m64 *mDest = (__m64*)Dest;
+	__m64 mm0 = _m_from_int(0); /* zero mm0 register */
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		__m64 mm1, mm2, mm3, mm4, mm5, mm6;
+		mm1 = _m_punpcklbw(*mSrc1, mm0);	/* unpack low  bytes of Src1 into words */
+		mm2 = _m_punpckhbw(*mSrc1, mm0);	/* unpack high bytes of Src1 into words */
+		mm3 = _m_punpcklbw(*mSrc2, mm0);	/* unpack low  bytes of Src2 into words */
+		mm4 = _m_punpckhbw(*mSrc2, mm0);	/* unpack high bytes of Src2 into words */
+		mm1 = _m_psrlwi(mm1, 1);		/* divide mm1 words by 2, Src1 low bytes */
+		mm2 = _m_psrlwi(mm2, 1);		/* divide mm2 words by 2, Src1 high bytes */
+		mm1 = _m_pmullw(mm1, mm3);		/* mul low  bytes of Src1 and Src2  */
+		mm2 = _m_pmullw(mm2, mm4);		/* mul high bytes of Src1 and Src2 */
+		*mDest = _m_packuswb(mm1, mm2);		/* pack words back into bytes with saturation */
+		mSrc1++;
+		mSrc2++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -1095,7 +1058,7 @@ int SDL_imageFilterMultDivby2(unsigned char *Src1, unsigned char *Src2, unsigned
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterMultDivby4MMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
+static int SDL_imageFilterMultDivby4MMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -1135,40 +1098,30 @@ L1016:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "mov %2, %%eax \n\t"	/* load Src1 address into eax */
-		"mov %1, %%ebx \n\t"	/* load Src2 address into ebx */
-		"mov %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov %3, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		"pxor      %%mm0, %%mm0 \n\t"	/* zero mm0 register */
-		".align 16       \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm1 \n\t"	/* load 8 bytes from Src1 into mm1 */
-		"movq    (%%ebx), %%mm3 \n\t"	/* load 8 bytes from Src2 into mm3 */
-		"movq      %%mm1, %%mm2 \n\t"	/* copy mm1 into mm2 */
-		"movq      %%mm3, %%mm4 \n\t"	/* copy mm3 into mm4  */
-		"punpcklbw %%mm0, %%mm1 \n\t"	/* unpack low  bytes of Src1 into words */
-		"punpckhbw %%mm0, %%mm2 \n\t"	/* unpack high bytes of Src1 into words */
-		"punpcklbw %%mm0, %%mm3 \n\t"	/* unpack low  bytes of Src2 into words */
-		"punpckhbw %%mm0, %%mm4 \n\t"	/* unpack high bytes of Src2 into words */
-		"psrlw        $1, %%mm1 \n\t"	/* divide mm1 words by 2, Src1 low bytes */
-		"psrlw        $1, %%mm2 \n\t"	/* divide mm2 words by 2, Src1 high bytes */
-		"psrlw        $1, %%mm3 \n\t"	/* divide mm3 words by 2, Src2 low bytes */
-		"psrlw        $1, %%mm4 \n\t"	/* divide mm4 words by 2, Src2 high bytes */
-		"pmullw    %%mm3, %%mm1 \n\t"	/* mul low  bytes of Src1 and Src2  */
-		"pmullw    %%mm4, %%mm2 \n\t"	/* mul high bytes of Src1 and Src2 */
-		"packuswb  %%mm2, %%mm1 \n\t"	/* pack words back into bytes with saturation */
-		"movq    %%mm1, (%%edi) \n\t"	/* store result in Dest */
-		"add $8, %%eax \n\t"	/* increase Src1, Src2 and Dest  */
-		"add $8, %%ebx \n\t"	/* register pointers by 8 */
-		"add $8, %%edi \n\t" "dec %%ecx     \n\t"	/* decrease loop counter */
-		"jnz 1b        \n\t"	/* check loop termination, proceed if required */
-		"emms          \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src2),		/* %1 */
-		"m"(Src1),		/* %2 */
-		"m"(SrcLength)		/* %3 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mSrc2 = (__m64*)Src2;
+	__m64 *mDest = (__m64*)Dest;
+	__m64 mm0 = _m_from_int(0); /* zero mm0 register */
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		__m64 mm1, mm2, mm3, mm4, mm5, mm6;
+		mm1 = _m_punpcklbw(*mSrc1, mm0);	/* unpack low  bytes of Src1 into words */
+		mm2 = _m_punpckhbw(*mSrc1, mm0);	/* unpack high bytes of Src1 into words */
+		mm3 = _m_punpcklbw(*mSrc2, mm0);	/* unpack low  bytes of Src2 into words */
+		mm4 = _m_punpckhbw(*mSrc2, mm0);	/* unpack high bytes of Src2 into words */
+		mm1 = _m_psrlwi(mm1, 1);		/* divide mm1 words by 2, Src1 low bytes */
+		mm2 = _m_psrlwi(mm2, 1);		/* divide mm2 words by 2, Src1 high bytes */
+		mm3 = _m_psrlwi(mm3, 1);		/* divide mm3 words by 2, Src2 low bytes */
+		mm4 = _m_psrlwi(mm4, 1);		/* divide mm4 words by 2, Src2 high bytes */
+		mm1 = _m_pmullw(mm1, mm3);		/* mul low  bytes of Src1 and Src2  */
+		mm2 = _m_pmullw(mm2, mm4);		/* mul high bytes of Src1 and Src2 */
+		*mDest = _m_packuswb(mm1, mm2);		/* pack words back into bytes with saturation */
+		mSrc1++;
+		mSrc2++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -1246,7 +1199,7 @@ int SDL_imageFilterMultDivby4(unsigned char *Src1, unsigned char *Src2, unsigned
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterBitAndMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
+static int SDL_imageFilterBitAndMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -1272,26 +1225,40 @@ L1017:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "mov %2, %%eax \n\t"	/* load Src1 address into eax */
-		"mov %1, %%ebx \n\t"	/* load Src2 address into ebx */
-		"mov %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov %3, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16       \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm1 \n\t"	/* load 8 bytes from Src1 into mm1 */
-		"pand    (%%ebx), %%mm1 \n\t"	/* mm1=Src1&Src2 */
-		"movq    %%mm1, (%%edi) \n\t"	/* store result in Dest */
-		"add $8, %%eax \n\t"	/* increase Src1, Src2 and Dest  */
-		"add $8, %%ebx \n\t"	/* register pointers by 8 */
-		"add $8, %%edi \n\t" "dec %%ecx     \n\t"	/* decrease loop counter */
-		"jnz 1b        \n\t"	/* check loop termination, proceed if required */
-		"emms          \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src2),		/* %1 */
-		"m"(Src1),		/* %2 */
-		"m"(SrcLength)		/* %3 */
-		);
+	/* x86_64 ASM with constraints: */
+	/* asm volatile ( */
+	/* 	"shr $3, %%rcx \n\t"	/\* counter/8 (MMX loads 8 bytes at a time) *\/ */
+	/* 	".align 16       \n\t"	/\* 16 byte alignment of the loop entry *\/ */
+	/* 	"1: movq (%%rax), %%mm1 \n\t"	/\* load 8 bytes from Src1 into mm1 *\/ */
+	/* 	"pand    (%%rbx), %%mm1 \n\t"	/\* mm1=Src1&Src2 *\/ */
+	/* 	"movq    %%mm1, (%%rdi) \n\t"	/\* store result in Dest *\/ */
+	/* 	"add $8, %%rax \n\t"	/\* increase Src1, Src2 and Dest  *\/ */
+	/* 	"add $8, %%rbx \n\t"	/\* register pointers by 8 *\/ */
+	/* 	"add $8, %%rdi \n\t" */
+	/* 	"dec %%rcx     \n\t"	/\* decrease loop counter *\/ */
+	/* 	"jnz 1b        \n\t"	/\* check loop termination, proceed if required *\/ */
+	/* 	"emms          \n\t"	/\* exit MMX state *\/ */
+	/* 	: "+a" (Src1),		/\* load Src1 address into rax, modified by the loop *\/ */
+	/* 	  "+b" (Src2),		/\* load Src2 address into rbx, modified by the loop *\/ */
+	/* 	  "+c" (SrcLength),	/\* load loop counter (SIZE) into rcx, modified by the loop *\/ */
+	/* 	  "+D" (Dest)		/\* load Dest address into rdi, modified by the loop *\/ */
+	/* 	: */
+	/* 	: "memory",		/\* *Dest is modified *\/ */
+        /*           "mm1"			/\* register mm1 modified *\/ */
+	/* ); */
+
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mSrc2 = (__m64*)Src2;
+	__m64 *mDest = (__m64*)Dest;
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		*mDest = _m_pand(*mSrc1, *mSrc2);	/* Src1&Src2 */
+		mSrc1++;
+		mSrc2++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -1368,7 +1335,7 @@ int SDL_imageFilterBitAnd(unsigned char *Src1, unsigned char *Src2, unsigned cha
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterBitOrMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
+static int SDL_imageFilterBitOrMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -1394,26 +1361,18 @@ L91017:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "mov %2, %%eax \n\t"	/* load Src1 address into eax */
-		"mov %1, %%ebx \n\t"	/* load Src2 address into ebx */
-		"mov %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov %3, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16       \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm1 \n\t"	/* load 8 bytes from Src1 into mm1 */
-		"por     (%%ebx), %%mm1 \n\t"	/* mm1=Src1|Src2 */
-		"movq    %%mm1, (%%edi) \n\t"	/* store result in Dest */
-		"add $8, %%eax \n\t"	/* increase Src1, Src2 and Dest  */
-		"add $8, %%ebx \n\t"	/* register pointers by 8 */
-		"add $8, %%edi \n\t" "dec %%ecx     \n\t"	/* decrease loop counter */
-		"jnz 1b        \n\t"	/* check loop termination, proceed if required */
-		"emms          \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src2),		/* %1 */
-		"m"(Src1),		/* %2 */
-		"m"(SrcLength)		/* %3 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mSrc2 = (__m64*)Src2;
+	__m64 *mDest = (__m64*)Dest;
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		*mDest = _m_por(*mSrc1, *mSrc2);	/* Src1|Src2 */
+		mSrc1++;
+		mSrc2++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -1487,7 +1446,7 @@ int SDL_imageFilterBitOr(unsigned char *Src1, unsigned char *Src2, unsigned char
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterDivASM(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
+static int SDL_imageFilterDivASM(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -1519,27 +1478,57 @@ L10193:
 			popa
 	}
 #else
-	asm volatile
-		("pusha \n\t" "mov %2, %%edx \n\t"	/* load Src1 address into edx */
-		"mov %1, %%esi \n\t"	/* load Src2 address into esi */
-		"mov %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov %3, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		".align 16     \n\t"	/* 16 byte alignment of the loop entry */
+	/* Note: ~15% gain on i386, less efficient than C on x86_64 */
+	/* Also depends on whether the function is static (?!) */
+	/* Also depends on whether we work on malloc() or static char[] */
+	asm volatile (
+#  if defined(i386)
+		"pushl %%ebx \n\t"		/* %ebx may be the PIC register.  */
+		".align 16     \n\t"		/* 16 byte alignment of the loop entry */
 		"1: mov (%%esi), %%bl  \n\t"	/* load a byte from Src2 */
-		"cmp       $0, %%bl  \n\t"	/* check if it zero */
-		"jnz 2f              \n\t" "movb  $255, (%%edi) \n\t"	/* division by zero = 255 !!! */
-		"jmp 3f              \n\t" "2:                  \n\t" "xor   %%ah, %%ah    \n\t"	/* prepare AX, zero AH register */
-		"mov   (%%edx), %%al \n\t"	/* load a byte from Src1 into AL */
-		"div   %%bl          \n\t"	/* divide AL by BL */
-		"mov   %%al, (%%edi) \n\t"	/* move a byte result to Dest */
-		"3: inc %%edx        \n\t"	/* increment Src1, Src2, Dest */
+		"cmp       $0, %%bl    \n\t"	/* check if it zero */
+		"jnz 2f                \n\t"
+		"movb  $255, (%%edi)   \n\t"	/* division by zero = 255 !!! */
+		"jmp 3f                \n\t"
+		"2: xor %%ah, %%ah     \n\t"	/* prepare AX, zero AH register */
+		"mov   (%%edx), %%al   \n\t"	/* load a byte from Src1 into AL */
+		"div   %%bl            \n\t"	/* divide AL by BL */
+		"mov   %%al, (%%edi)   \n\t"	/* move a byte result to Dest */
+		"3: inc %%edx          \n\t"	/* increment Src1, Src2, Dest */
 		"inc %%esi \n\t"		/* pointer registers by one */
-		"inc %%edi \n\t" "dec %%ecx    \n\t"	/* decrease loop counter */
-		"jnz 1b       \n\t"	/* check loop termination, proceed if required */
-		"popa \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src2),		/* %1 */
-		"m"(Src1),		/* %2 */
-		"m"(SrcLength)		/* %3 */
+		"inc %%edi \n\t"
+		"dec %%ecx \n\t"		/* decrease loop counter */
+		"jnz 1b    \n\t"		/* check loop termination, proceed if required */
+		"popl %%ebx \n\t"		/* restore %ebx */
+		: "+d" (Src1),		/* load Src1 address into edx */
+		  "+S" (Src2),		/* load Src2 address into esi */
+		  "+c" (SrcLength),	/* load loop counter (SIZE) into ecx */
+		  "+D" (Dest)		/* load Dest address into edi */
+		:
+		: "memory", "rax"
+#  elif defined(__x86_64__)
+		".align 16     \n\t"		/* 16 byte alignment of the loop entry */
+		"1: mov (%%rsi), %%bl  \n\t"	/* load a byte from Src2 */
+		"cmp       $0, %%bl    \n\t"	/* check if it zero */
+		"jnz 2f                \n\t"
+		"movb  $255, (%%rdi)   \n\t"	/* division by zero = 255 !!! */
+		"jmp 3f                \n\t"
+		"2: xor %%ah, %%ah     \n\t"	/* prepare AX, zero AH register */
+		"mov   (%%rdx), %%al   \n\t"	/* load a byte from Src1 into AL */
+		"div   %%bl            \n\t"	/* divide AL by BL */
+		"mov   %%al, (%%rdi)   \n\t"	/* move a byte result to Dest */
+		"3: inc %%rdx          \n\t"	/* increment Src1, Src2, Dest */
+		"inc %%rsi \n\t"		/* pointer registers by one */
+		"inc %%rdi \n\t"
+		"dec %%rcx \n\t"		/* decrease loop counter */
+		"jnz 1b    \n\t"		/* check loop termination, proceed if required */
+		: "+d" (Src1),		/* load Src1 address into edx */
+		  "+S" (Src2),		/* load Src2 address into esi */
+		  "+c" (SrcLength),	/* load loop counter (SIZE) into ecx */
+		  "+D" (Dest)		/* load Dest address into edi */
+		:
+		: "memory", "rax", "rbx"
+#  endif
 		);
 #endif
 	return (0);
@@ -1589,9 +1578,24 @@ int SDL_imageFilterDiv(unsigned char *Src1, unsigned char *Src2, unsigned char *
 	curdst = Dest;
 
 	/* C routine to process image */
+	/* for (i = istart; i < length; i++) { */
+	/* 	if (*cursrc2 == 0) { */
+	/* 		*curdst = 255; */
+	/* 	} else { */
+	/* 		result = (int) *cursrc1 / (int) *cursrc2; */
+	/* 		*curdst = (unsigned char) result; */
+	/* 	} */
+	/* 	/\* Advance pointers *\/ */
+	/* 	cursrc1++; */
+	/* 	cursrc2++; */
+	/* 	curdst++; */
+	/* } */
 	for (i = istart; i < length; i++) {
-		result = (int) *cursrc1 / (int) *cursrc2;
-		*curdst = (unsigned char) result;
+		if (*cursrc2 == 0) {
+			*curdst = 255;
+		} else {
+			*curdst = (int)*cursrc1 / (int)*cursrc2;  // (int) for efficiency
+		}
 		/* Advance pointers */
 		cursrc1++;
 		cursrc2++;
@@ -1612,7 +1616,7 @@ int SDL_imageFilterDiv(unsigned char *Src1, unsigned char *Src2, unsigned char *
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterBitNegationMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength)
+static int SDL_imageFilterBitNegationMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -1637,24 +1641,19 @@ L91117:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "pcmpeqb   %%mm1, %%mm1 \n\t"	/* generate all 1's in mm1 */
-		"mov %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16       \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm0 \n\t"	/* load 8 bytes from Src1 into mm1 */
-		"pxor      %%mm1, %%mm0 \n\t"	/* negate mm0 by xoring with mm1 */
-		"movq    %%mm0, (%%edi) \n\t"	/* store result in Dest */
-		"add $8, %%eax \n\t"	/* increase Src1, Src2 and Dest  */
-		"add $8, %%edi \n\t" "dec %%ecx     \n\t"	/* decrease loop counter */
-		"jnz 1b        \n\t"	/* check loop termination, proceed if required */
-		"emms          \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength)		/* %2 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+        __m64 mm1;
+	mm1 = _m_pcmpeqb(mm1, mm1);		/* generate all 1's in mm1 */
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		*mDest = _m_pxor(*mSrc1, mm1);	/* negate mm0 by xoring with mm1 */
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();				/* clean MMX state */
+
 #endif
 	return (0);
 #else
@@ -1724,7 +1723,7 @@ int SDL_imageFilterBitNegation(unsigned char *Src1, unsigned char *Dest, unsigne
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterAddByteMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char C)
+static int SDL_imageFilterAddByteMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char C)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -1757,36 +1756,22 @@ L1021:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t"
-		/* ** Duplicate C in 8 bytes of MM1 ** */
-		"mov           %3, %%al \n\t"	/* load C into AL */
-		"mov         %%al, %%ah \n\t"	/* copy AL into AH */
-		"mov         %%ax, %%bx \n\t"	/* copy AX into BX */
-		"shl         $16, %%eax \n\t"	/* shift 2 bytes of EAX left */
-		"mov         %%bx, %%ax \n\t"	/* copy BX into AX */
-		"movd      %%eax, %%mm1 \n\t"	/* copy EAX into MM1 */
-		"movd      %%eax, %%mm2 \n\t"	/* copy EAX into MM2 */
-		"punpckldq %%mm2, %%mm1 \n\t"	/* fill higher bytes of MM1 with C */
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1:                     \n\t" 
-		"movq    (%%eax), %%mm0 \n\t"	/* load 8 bytes from Src1 into MM0 */
-		"paddusb   %%mm1, %%mm0 \n\t"	/* MM0=SrcDest+C (add 8 bytes with saturation) */
-		"movq    %%mm0, (%%edi) \n\t"	/* store result in Dest */
-		"add          $8, %%eax \n\t"	/* increase Dest register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"	/* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(C)			/* %3 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	/* Duplicate C in 8 bytes of MM1 */
+	int i;
+	memset(&i, C, 4);
+	__m64 mm1 = _m_from_int(i);
+	__m64 mm2 = _m_from_int(i);
+	mm1 = _m_punpckldq(mm1, mm2);			/* fill higher bytes of MM1 with C */
+        //__m64 mm1 = _m_from_int64(lli); // x86_64 only
+	for (i = 0; i < SrcLength/8; i++) {
+		*mDest = _m_paddusb(*mSrc1, mm1);	/* Src1+C (add 8 bytes with saturation) */
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -1871,7 +1856,7 @@ int SDL_imageFilterAddByte(unsigned char *Src1, unsigned char *Dest, unsigned in
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterAddUintMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned int C, unsigned int D)
+static int SDL_imageFilterAddUintMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned int C, unsigned int D)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -1901,34 +1886,21 @@ L11023:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t"
-		/* ** Duplicate (int)C in 8 bytes of MM1 ** */
-		"mov          %3, %%eax \n\t"	/* load C into EAX */
-		"movd      %%eax, %%mm1 \n\t"	/* copy EAX into MM1 */
-		"mov          %4, %%eax \n\t"	/* load D into EAX */
-		"movd      %%eax, %%mm2 \n\t"	/* copy EAX into MM2 */
-		"punpckldq %%mm2, %%mm1 \n\t"	/* fill higher bytes of MM1 with C */
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1:                     \n\t" 
-		"movq    (%%eax), %%mm0 \n\t"	/* load 8 bytes from SrcDest into MM0 */
-		"paddusb   %%mm1, %%mm0 \n\t"	/* MM0=SrcDest+C (add 8 bytes with saturation) */
-		"movq    %%mm0, (%%edi) \n\t"	/* store result in SrcDest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"	/* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(C),			/* %3 */
-		"m"(D)			/* %4 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	/* Duplicate (int)C in 8 bytes of MM1 */
+	__m64 mm1 = _m_from_int(C);
+	__m64 mm2 = _m_from_int(C);
+	mm1 = _m_punpckldq(mm1, mm2);			/* fill higher bytes of MM1 with C */
+        //__m64 mm1 = _m_from_int64(lli); // x86_64 only
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		*mDest = _m_paddusb(*mSrc1, mm1);	/* Src1+C (add 8 bytes with saturation) */
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -2020,7 +1992,7 @@ int SDL_imageFilterAddUint(unsigned char *Src1, unsigned char *Dest, unsigned in
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterAddByteToHalfMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char C,
+static int SDL_imageFilterAddByteToHalfMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char C,
 									unsigned char *Mask)
 {
 #ifdef USE_MMX
@@ -2048,7 +2020,6 @@ L1022:
 		movq mm2, [eax]   	/* load 8 bytes from Src1 into MM2 */
 		psrlw mm2, 1   	/* shift 4 WORDS of MM2 1 bit to the right */
 			pand mm2, mm0        // apply Mask to 8 BYTES of MM2 */
-			/* byte     0x0f, 0xdb, 0xd0 */
 			paddusb mm2,  mm1 	/* MM2=SrcDest+C (add 8 bytes with saturation) */
 			movq [edi], mm2   	/* store result in Dest */
 			add eax, 8   	/* increase Src1 register pointer by 8 */
@@ -2059,42 +2030,26 @@ L1022:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t"
-		/* ** Duplicate C in 8 bytes of MM1 ** */
-		"mov           %3, %%al \n\t"	/* load C into AL */
-		"mov         %%al, %%ah \n\t"	/* copy AL into AH */
-		"mov         %%ax, %%bx \n\t"	/* copy AX into BX */
-		"shl         $16, %%eax \n\t"	/* shift 2 bytes of EAX left */
-		"mov         %%bx, %%ax \n\t"	/* copy BX into AX */
-		"movd      %%eax, %%mm1 \n\t"	/* copy EAX into MM1 */
-		"movd      %%eax, %%mm2 \n\t"	/* copy EAX into MM2 */
-		"punpckldq %%mm2, %%mm1 \n\t"	/* fill higher bytes of MM1 with C */
-		"movl         %4, %%edx \n\t"	/* load Mask address into edx */
-		"movq    (%%edx), %%mm0 \n\t"	/* load Mask into mm0 */
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1:                     \n\t" 
-		"movq    (%%eax), %%mm2 \n\t"	/* load 8 bytes from Src1 into MM2 */
-		"psrlw        $1, %%mm2 \n\t"	/* shift 4 WORDS of MM2 1 bit to the right */
-		/*    "pand      %%mm0, %%mm2 \n\t"    // apply Mask to 8 BYTES of MM2 */
-		".byte     0x0f, 0xdb, 0xd0 \n\t" 
-		"paddusb   %%mm1, %%mm2 \n\t"	/* MM2=SrcDest+C (add 8 bytes with saturation) */
-		"movq    %%mm2, (%%edi) \n\t"	/* store result in Dest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                  1b \n\t"	/* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(C),			/* %3 */
-		"m"(Mask)			/* %4 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	__m64 *mMask = (__m64*)Mask;
+	/* Duplicate C in 8 bytes of MM1 */
+	int i;
+	memset(&i, C, 4);
+	__m64 mm1 = _m_from_int(i);
+	__m64 mm2 = _m_from_int(i);
+	mm1 = _m_punpckldq(mm1, mm2);			/* fill higher bytes of MM1 with C */
+        //__m64 mm1 = _m_from_int64(lli); // x86_64 only
+	for (i = 0; i < SrcLength/8; i++) {
+		__m64 mm2 = _m_psrlwi(*mSrc1, 1);	/* shift 4 WORDS of MM2 1 bit to the right */
+		mm2 = _m_pand(mm2, *mMask);		/* apply Mask to 8 BYTES of MM2 */
+							/* byte     0x0f, 0xdb, 0xd0 */
+		*mDest = _m_paddusb(mm1, mm2);		/* Src1+C (add 8 bytes with saturation) */
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -2207,35 +2162,22 @@ L1023:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t"
-		/* ** Duplicate C in 8 bytes of MM1 ** */
-		"mov           %3, %%al \n\t"	/* load C into AL */
-		"mov         %%al, %%ah \n\t"	/* copy AL into AH */
-		"mov         %%ax, %%bx \n\t"	/* copy AX into BX */
-		"shl         $16, %%eax \n\t"	/* shift 2 bytes of EAX left */
-		"mov         %%bx, %%ax \n\t"	/* copy BX into AX */
-		"movd      %%eax, %%mm1 \n\t"	/* copy EAX into MM1 */
-		"movd      %%eax, %%mm2 \n\t"	/* copy EAX into MM2 */
-		"punpckldq %%mm2, %%mm1 \n\t"	/* fill higher bytes of MM1 with C */
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm0 \n\t"	/* load 8 bytes from SrcDest into MM0 */
-		"psubusb   %%mm1, %%mm0 \n\t"	/* MM0=SrcDest-C (sub 8 bytes with saturation) */
-		"movq    %%mm0, (%%edi) \n\t"	/* store result in SrcDest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"	/* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(C)			/* %3 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	/* Duplicate C in 8 bytes of MM1 */
+	int i;
+	memset(&i, C, 4);
+	__m64 mm1 = _m_from_int(i);
+	__m64 mm2 = _m_from_int(i);
+	mm1 = _m_punpckldq(mm1, mm2);			/* fill higher bytes of MM1 with C */
+        //__m64 mm1 = _m_from_int64(lli); // x86_64 only
+	for (i = 0; i < SrcLength/8; i++) {
+		*mDest = _m_psubusb(*mSrc1, mm1);	/* Src1-C (sub 8 bytes with saturation) */
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -2320,7 +2262,7 @@ int SDL_imageFilterSubByte(unsigned char *Src1, unsigned char *Dest, unsigned in
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterSubUintMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned int C, unsigned int D)
+static int SDL_imageFilterSubUintMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned int C, unsigned int D)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -2350,33 +2292,21 @@ L11024:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t"
-		/* ** Duplicate (int)C in 8 bytes of MM1 ** */
-		"mov          %3, %%eax \n\t"	/* load C into EAX */
-		"movd      %%eax, %%mm1 \n\t"	/* copy EAX into MM1 */
-		"mov          %4, %%eax \n\t"	/* load D into EAX */
-		"movd      %%eax, %%mm2 \n\t"	/* copy EAX into MM2 */
-		"punpckldq %%mm2, %%mm1 \n\t"	/* fill higher bytes of MM1 with C */
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm0 \n\t"	/* load 8 bytes from SrcDest into MM0 */
-		"psubusb   %%mm1, %%mm0 \n\t"	/* MM0=SrcDest-C (sub 8 bytes with saturation) */
-		"movq    %%mm0, (%%edi) \n\t"	/* store result in SrcDest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                  1b \n\t"	/* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(C),			/* %3 */
-		"m"(D)			/* %4 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	/* Duplicate (int)C in 8 bytes of MM1 */
+	__m64 mm1 = _m_from_int(C);
+	__m64 mm2 = _m_from_int(C);
+	mm1 = _m_punpckldq(mm1, mm2);			/* fill higher bytes of MM1 with C */
+        //__m64 mm1 = _m_from_int64(lli); // x86_64 only
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		*mDest = _m_psubusb(*mSrc1, mm1);	/* Src1-C (sub 8 bytes with saturation) */
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -2468,7 +2398,7 @@ int SDL_imageFilterSubUint(unsigned char *Src1, unsigned char *Dest, unsigned in
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterShiftRightMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char N,
+static int SDL_imageFilterShiftRightMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char N,
 								 unsigned char *Mask)
 {
 #ifdef USE_MMX
@@ -2508,42 +2438,26 @@ L10241:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "movl         %4, %%edx \n\t"	/* load Mask address into edx */
-		"movq    (%%edx), %%mm0 \n\t"	/* load Mask into mm0 */
-		"xor       %%ecx, %%ecx \n\t"	/* zero ECX */
-		"mov           %3, %%cl \n\t"	/* load loop counter (N) into CL */
-		"movd      %%ecx, %%mm3 \n\t"	/* copy (N) into MM3  */
-		"pcmpeqb   %%mm1, %%mm1 \n\t"	/* generate all 1's in mm1 */
-		"1:                     \n\t"	/* ** Prepare proper bit-Mask in MM1 ** */
-		"psrlw        $1, %%mm1 \n\t"	/* shift 4 WORDS of MM1 1 bit to the right */
-		/*    "pand      %%mm0, %%mm1 \n\t"    // apply Mask to 8 BYTES of MM1 */
-		".byte     0x0f, 0xdb, 0xc8 \n\t" 
-		"dec               %%cl \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"	/* check loop termination, proceed if required */
-		/* ** Shift all bytes of the image ** */
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"2:                     \n\t" 
-		"movq    (%%eax), %%mm0 \n\t"	/* load 8 bytes from SrcDest into MM0 */
-		"psrlw     %%mm3, %%mm0 \n\t"	/* shift 4 WORDS of MM0 (N) bits to the right */
-		/*    "pand      %%mm1, %%mm0 \n\t"    // apply proper bit-Mask to 8 BYTES of MM0 */
-		".byte     0x0f, 0xdb, 0xc1 \n\t" 
-		"movq    %%mm0, (%%edi) \n\t"	/* store result in SrcDest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 2b \n\t"	/* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(N),			/* %3 */
-		"m"(Mask)			/* %4 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	__m64 *mMask = (__m64*)Mask;
+        __m64 mm1;
+	int i;
+	mm1 = _m_pcmpeqb(mm1, mm1);			/* generate all 1's in mm1 */
+	/* Prepare proper bit-Mask in MM1 */
+	for (i = 0; i < N; i++) {
+		mm1 = _m_psrlwi(mm1, 1);		/* shift 4 WORDS of MM1 1 bit to the right */
+		mm1 = _m_pand(mm1, *mMask);		/* apply Mask to 8 BYTES of MM1 */
+	}
+        /* Shift all bytes of the image */
+	for (i = 0; i < SrcLength/8; i++) {
+		__m64 mm0 = _m_psrlwi(*mSrc1, N);	/* shift 4 WORDS of MM0 (N) bits to the right */
+		*mDest = _m_pand(mm0, mm1);		/* apply proper bit-Mask to 8 BYTES of MM0 */
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -2628,7 +2542,7 @@ int SDL_imageFilterShiftRight(unsigned char *Src1, unsigned char *Dest, unsigned
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterShiftRightUintMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char N)
+static int SDL_imageFilterShiftRightUintMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char N)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -2652,26 +2566,16 @@ L13023:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t"
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm0 \n\t"	/* load 8 bytes from SrcDest into MM0 */
-		"psrld   %3, %%mm0 \n\t"
-		"movq    %%mm0, (%%edi) \n\t"	/* store result in SrcDest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"	/* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(N)			/* %3 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		*mDest = _m_psrldi(*mSrc1, N);
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -2759,7 +2663,7 @@ int SDL_imageFilterShiftRightUint(unsigned char *Src1, unsigned char *Dest, unsi
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterMultByByteMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char C)
+static int SDL_imageFilterMultByByteMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char C)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -2825,64 +2729,49 @@ L10252:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t"
-		/* ** Duplicate C in 4 words of MM1 ** */
-		"mov           %3, %%al \n\t"	/* load C into AL */
-		"xor         %%ah, %%ah \n\t"	/* zero AH */
-		"mov         %%ax, %%bx \n\t"	/* copy AX into BX */
-		"shl         $16, %%eax \n\t"	/* shift 2 bytes of EAX left */
-		"mov         %%bx, %%ax \n\t"	/* copy BX into AX */
-		"movd      %%eax, %%mm1 \n\t"	/* copy EAX into MM1 */
-		"movd      %%eax, %%mm2 \n\t"	/* copy EAX into MM2 */
-		"punpckldq %%mm2, %%mm1 \n\t"	/* fill higher words of MM1 with C */
-		"pxor      %%mm0, %%mm0 \n\t"	/* zero MM0 register */
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		"cmp         $128, %%al \n\t"	/* if (C <= 128) execute more efficient code */
-		"jg                  2f \n\t" ".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm3 \n\t"	/* load 8 bytes from Src1 into MM3 */
-		"movq      %%mm3, %%mm4 \n\t"	/* copy MM3 into MM4  */
-		"punpcklbw %%mm0, %%mm3 \n\t"	/* unpack low  bytes of SrcDest into words */
-		"punpckhbw %%mm0, %%mm4 \n\t"	/* unpack high bytes of SrcDest into words */
-		"pmullw    %%mm1, %%mm3 \n\t"	/* mul low  bytes of SrcDest and MM1 */
-		"pmullw    %%mm1, %%mm4 \n\t"	/* mul high bytes of SrcDest and MM1 */
-		"packuswb  %%mm4, %%mm3 \n\t"	/* pack words back into bytes with saturation */
-		"movq    %%mm3, (%%edi) \n\t"	/* store result in Dest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"	/* check loop termination, proceed if required */
-		"jmp                 3f \n\t" ".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"2: movq (%%eax), %%mm3 \n\t"	/* load 8 bytes from Src1 into MM3 */
-		"movq      %%mm3, %%mm4 \n\t"	/* copy MM3 into MM4  */
-		"punpcklbw %%mm0, %%mm3 \n\t"	/* unpack low  bytes of SrcDest into words */
-		"punpckhbw %%mm0, %%mm4 \n\t"	/* unpack high bytes of SrcDest into words */
-		"pmullw    %%mm1, %%mm3 \n\t"	/* mul low  bytes of SrcDest and MM1 */
-		"pmullw    %%mm1, %%mm4 \n\t"	/* mul high bytes of SrcDest and MM1 */
-		/* ** Take abs value of the results (signed words) ** */
-		"movq      %%mm3, %%mm5 \n\t"	/* copy mm3 into mm5 */
-		"movq      %%mm4, %%mm6 \n\t"	/* copy mm4 into mm6 */
-		"psraw       $15, %%mm5 \n\t"	/* fill mm5 words with word sign bit */
-		"psraw       $15, %%mm6 \n\t"	/* fill mm6 words with word sign bit */
-		"pxor      %%mm5, %%mm3 \n\t"	/* take 1's compliment of only neg. words */
-		"pxor      %%mm6, %%mm4 \n\t"	/* take 1's compliment of only neg. words */
-		"psubsw    %%mm5, %%mm3 \n\t"	/* add 1 to only neg. words, W-(-1) or W-0 */
-		"psubsw    %%mm6, %%mm4 \n\t"	/* add 1 to only neg. words, W-(-1) or W-0 */
-		"packuswb  %%mm4, %%mm3 \n\t"	/* pack words back into bytes with saturation */
-		"movq    %%mm3, (%%edi) \n\t"	/* store result in Dest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 2b \n\t"	/* check loop termination, proceed if required */
-		"3: emms               \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(C)			/* %3 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	__m64 mm0 = _m_from_int(0);				/* zero mm0 register */
+	/* Duplicate C in 4 words of MM1 */
+	int i;
+	i = C | C<<16;
+	__m64 mm1 = _m_from_int(i);
+	__m64 mm2 = _m_from_int(i);
+	mm1 = _m_punpckldq(mm1, mm2);				/* fill higher words of MM1 with C */
+	// long long lli = C | C<<16 | (long long)C<<32 | (long long)C<<48;
+        //__m64 mm1 = _m_from_int64(lli); // x86_64 only
+	if (C <= 128) {						/* if (C <= 128) execute more efficient code */
+		for (i = 0; i < SrcLength/8; i++) {
+			__m64 mm3, mm4;
+			mm3 = _m_punpcklbw(*mSrc1, mm0);	/* unpack low  bytes of Src1 into words */
+			mm4 = _m_punpckhbw(*mSrc1, mm0);	/* unpack high bytes of Src1 into words */
+			mm3 = _m_pmullw(mm3, mm1);		/* mul low  bytes of Src1 and MM1 */
+			mm4 = _m_pmullw(mm4, mm1);		/* mul high bytes of Src1 and MM1 */
+			*mDest = _m_packuswb(mm3, mm4);		/* pack words back into bytes with saturation */
+			mSrc1++;
+			mDest++;
+		}
+	} else {
+		for (i = 0; i < SrcLength/8; i++) {
+			__m64 mm3, mm4, mm5, mm6;
+			mm3 = _m_punpcklbw(*mSrc1, mm0);	/* unpack low  bytes of Src1 into words */
+			mm4 = _m_punpckhbw(*mSrc1, mm0);	/* unpack high bytes of Src1 into words */
+			mm3 = _m_pmullw(mm3, mm1);		/* mul low  bytes of Src1 and MM1 */
+			mm4 = _m_pmullw(mm4, mm1);		/* mul high bytes of Src1 and MM1 */
+			/* Take abs value of the results (signed words) */
+			mm5 = _m_psrawi(mm3, 15);		/* fill mm5 words with word sign bit */
+			mm6 = _m_psrawi(mm4, 15);		/* fill mm6 words with word sign bit */
+			mm3 = _m_pxor(mm3, mm5);		/* take 1's compliment of only neg. words */
+			mm4 = _m_pxor(mm4, mm6);		/* take 1's compliment of only neg. words */
+			mm3 = _m_psubsw(mm3, mm5);		/* add 1 to only neg. words, W-(-1) or W-0 */
+			mm4 = _m_psubsw(mm4, mm6);		/* add 1 to only neg. words, W-(-1) or W-0 */
+			*mDest = _m_packuswb(mm3, mm4);		/* pack words back into bytes with saturation */
+			mSrc1++;
+			mDest++;
+		}
+	}
+	_m_empty();						/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -2967,7 +2856,7 @@ int SDL_imageFilterMultByByte(unsigned char *Src1, unsigned char *Dest, unsigned
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterShiftRightAndMultByByteMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char N,
+static int SDL_imageFilterShiftRightAndMultByByteMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char N,
 											  unsigned char C)
 {
 #ifdef USE_MMX
@@ -3012,47 +2901,29 @@ L1026:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t"
-		/* ** Duplicate C in 4 words of MM1 ** */
-		"mov           %4, %%al \n\t"	/* load C into AL */
-		"xor         %%ah, %%ah \n\t"	/* zero AH */
-		"mov         %%ax, %%bx \n\t"	/* copy AX into BX */
-		"shl         $16, %%eax \n\t"	/* shift 2 bytes of EAX left */
-		"mov         %%bx, %%ax \n\t"	/* copy BX into AX */
-		"movd      %%eax, %%mm1 \n\t"	/* copy EAX into MM1 */
-		"movd      %%eax, %%mm2 \n\t"	/* copy EAX into MM2 */
-		"punpckldq %%mm2, %%mm1 \n\t"	/* fill higher words of MM1 with C */
-		"xor       %%ecx, %%ecx \n\t"	/* zero ECX */
-		"mov           %3, %%cl \n\t"	/* load N into CL */
-		"movd      %%ecx, %%mm7 \n\t"	/* copy N into MM7 */
-		"pxor      %%mm0, %%mm0 \n\t"	/* zero MM0 register */
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16             \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm3 \n\t"	/* load 8 bytes from Src1 into MM3 */
-		"movq      %%mm3, %%mm4 \n\t"	/* copy MM3 into MM4  */
-		"punpcklbw %%mm0, %%mm3 \n\t"	/* unpack low  bytes of SrcDest into words */
-		"punpckhbw %%mm0, %%mm4 \n\t"	/* unpack high bytes of SrcDest into words */
-		"psrlw     %%mm7, %%mm3 \n\t"	/* shift 4 WORDS of MM3 (N) bits to the right */
-		"psrlw     %%mm7, %%mm4 \n\t"	/* shift 4 WORDS of MM4 (N) bits to the right */
-		"pmullw    %%mm1, %%mm3 \n\t"	/* mul low  bytes of SrcDest by MM1 */
-		"pmullw    %%mm1, %%mm4 \n\t"	/* mul high bytes of SrcDest by MM1 */
-		"packuswb  %%mm4, %%mm3 \n\t"	/* pack words back into bytes with saturation */
-		"movq    %%mm3, (%%edi) \n\t"	/* store result in Dest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"	/* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(N),			/* %3 */
-		"m"(C)			/* %4 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	__m64 mm0 = _m_from_int(0);			/* zero mm0 register */
+	/* Duplicate C in 4 words of MM1 */
+	int i;
+	i = (C<<16)|C;
+	__m64 mm1 = _m_from_int(i);
+	__m64 mm2 = _m_from_int(i);
+	mm1 = _m_punpckldq(mm1, mm2);			/* fill higher words of MM1 with C */
+	for (i = 0; i < SrcLength/8; i++) {
+		__m64 mm3, mm4, mm5, mm6;
+		mm3 = _m_punpcklbw(*mSrc1, mm0);	/* unpack low  bytes of Src1 into words */
+		mm4 = _m_punpckhbw(*mSrc1, mm0);	/* unpack high bytes of Src1 into words */
+		mm3 = _m_psrlwi(mm3, N);		/* shift 4 WORDS of MM3 (N) bits to the right */
+		mm4 = _m_psrlwi(mm4, N);		/* shift 4 WORDS of MM4 (N) bits to the right */
+		mm3 = _m_pmullw(mm3, mm1);		/* mul low  bytes of Src1 and MM1 */
+		mm4 = _m_pmullw(mm4, mm1);		/* mul high bytes of Src1 and MM1 */
+		*mDest = _m_packuswb(mm3, mm4);		/* pack words back into bytes with saturation */
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -3144,7 +3015,7 @@ int SDL_imageFilterShiftRightAndMultByByte(unsigned char *Src1, unsigned char *D
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterShiftLeftByteMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char N,
+static int SDL_imageFilterShiftLeftByteMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char N,
 									unsigned char *Mask)
 {
 #ifdef USE_MMX
@@ -3184,39 +3055,26 @@ L10271:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "movl         %4, %%edx \n\t"	/* load Mask address into edx */
-		"movq    (%%edx), %%mm0 \n\t"	/* load Mask into mm0 */
-		"xor       %%ecx, %%ecx \n\t"	/* zero ECX */
-		"mov           %3, %%cl \n\t"	/* load loop counter (N) into CL */
-		"movd      %%ecx, %%mm3 \n\t"	/* copy (N) into MM3  */
-		"pcmpeqb   %%mm1, %%mm1 \n\t"	/* generate all 1's in mm1 */
-		"1:                     \n\t"	/* ** Prepare proper bit-Mask in MM1 ** */
-		"psllw        $1, %%mm1 \n\t"	/* shift 4 WORDS of MM1 1 bit to the left */
-		/*    "pand      %%mm0, %%mm1 \n\t"    // apply Mask to 8 BYTES of MM1 */
-		".byte     0x0f, 0xdb, 0xc8 \n\t" "dec %%cl               \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"	/* check loop termination, proceed if required */
-		/* ** Shift all bytes of the image ** */
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load SrcDest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"2: movq (%%eax), %%mm0 \n\t"	/* load 8 bytes from Src1 into MM0 */
-		"psllw     %%mm3, %%mm0 \n\t"	/* shift 4 WORDS of MM0 (N) bits to the left */
-		/*    "pand      %%mm1, %%mm0 \n\t"    // apply proper bit-Mask to 8 BYTES of MM0 */
-		".byte     0x0f, 0xdb, 0xc1 \n\t" "movq    %%mm0, (%%edi) \n\t"	/* store result in Dest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 2b \n\t"	/* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(N),			/* %3 */
-		"m"(Mask)			/* %4 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	__m64 *mMask = (__m64*)Mask;
+        __m64 mm1;
+	int i;
+	mm1 = _m_pcmpeqb(mm1, mm1);			/* generate all 1's in mm1 */
+	/* Prepare proper bit-Mask in MM1 */
+	for (i = 0; i < N; i++) {
+		mm1 = _m_psllwi(mm1, 1);		/* shift 4 WORDS of MM1 1 bit to the left */
+		mm1 = _m_pand(mm1, *mMask);		/* apply Mask to 8 BYTES of MM1 */
+	}
+	/* ** Shift all bytes of the image ** */
+	for (i = 0; i < SrcLength/8; i++) {
+		__m64 mm0 = _m_psllwi(*mSrc1, N);	/* shift 4 WORDS of MM0 (N) bits to the left */
+		*mDest = _m_pand(mm0, mm1);		/* apply proper bit-Mask to 8 BYTES of MM0 */
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -3300,7 +3158,7 @@ int SDL_imageFilterShiftLeftByte(unsigned char *Src1, unsigned char *Dest, unsig
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterShiftLeftUintMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char N)
+static int SDL_imageFilterShiftLeftUintMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char N)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -3324,26 +3182,16 @@ L12023:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t"
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm0 \n\t"	/* load 8 bytes from SrcDest into MM0 */
-		"pslld   %3, %%mm0 \n\t"	/* MM0=SrcDest+C (add 8 bytes with saturation) */
-		"movq    %%mm0, (%%edi) \n\t"	/* store result in SrcDest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"	/* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(N)			/* %3 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	int i;
+	for (i = 0; i < SrcLength/8; i++) {
+		*mDest = _m_pslldi(*mSrc1, N);	/* Src1+C (add 8 bytes with saturation) */
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();				/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -3431,7 +3279,7 @@ int SDL_imageFilterShiftLeftUint(unsigned char *Src1, unsigned char *Dest, unsig
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterShiftLeftMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char N)
+static int SDL_imageFilterShiftLeftMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char N)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -3454,8 +3302,8 @@ L10280:
 		movq mm4, mm3   	/* copy MM3 into MM4  */
 			punpcklbw mm3, mm0   	/* unpack low  bytes of SrcDest into words */
 			punpckhbw mm4, mm0   	/* unpack high bytes of SrcDest into words */
-			psllw mm3, mm7   	/* shift 4 WORDS of MM3 (N) bits to the right */
-			psllw mm4, mm7   	/* shift 4 WORDS of MM4 (N) bits to the right */
+			psllw mm3, mm7   	/* shift 4 WORDS of MM3 (N) bits to the left */
+			psllw mm4, mm7   	/* shift 4 WORDS of MM4 (N) bits to the left */
 			packuswb mm3, mm4   	/* pack words back into bytes with saturation */
 			movq [edi], mm3   	/* store result in Dest */
 			add eax, 8   	/* increase Src1 register pointer by 8 */
@@ -3469,8 +3317,8 @@ L10281:
 		movq mm4, mm3   	/* copy MM3 into MM4  */
 			punpcklbw mm3, mm0   	/* unpack low  bytes of SrcDest into words */
 			punpckhbw mm4, mm0   	/* unpack high bytes of SrcDest into words */
-			psllw mm3, mm7   	/* shift 4 WORDS of MM3 (N) bits to the right */
-			psllw mm4, mm7   	/* shift 4 WORDS of MM4 (N) bits to the right */
+			psllw mm3, mm7   	/* shift 4 WORDS of MM3 (N) bits to the left */
+			psllw mm4, mm7   	/* shift 4 WORDS of MM4 (N) bits to the left */
 			/* ** Take abs value of the signed words ** */
 			movq mm5, mm3   	/* copy mm3 into mm5 */
 			movq mm6, mm4   	/* copy mm4 into mm6 */
@@ -3491,57 +3339,42 @@ L10282:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "xor       %%eax, %%eax \n\t"	/* zero EAX */
-		"mov           %3, %%al \n\t"	/* load N into AL */
-		"movd      %%eax, %%mm7 \n\t"	/* copy N into MM7 */
-		"pxor      %%mm0, %%mm0 \n\t"	/* zero MM0 register */
-		"mov         %1, %%eax  \n\t"	/* load Src1 address into eax */
-		"mov         %0, %%edi  \n\t"	/* load Dest address into edi */
-		"mov         %2, %%ecx  \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr         $3, %%ecx  \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		"cmp           $7, %%al \n\t"	/* if (N <= 7) execute more efficient code */
-		"jg                  2f \n\t" ".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1: movq (%%eax), %%mm3 \n\t"	/* load 8 bytes from Src1 into MM3 */
-		"movq      %%mm3, %%mm4 \n\t"	/* copy MM3 into MM4  */
-		"punpcklbw %%mm0, %%mm3 \n\t"	/* unpack low  bytes of SrcDest into words */
-		"punpckhbw %%mm0, %%mm4 \n\t"	/* unpack high bytes of SrcDest into words */
-		"psllw     %%mm7, %%mm3 \n\t"	/* shift 4 WORDS of MM3 (N) bits to the right */
-		"psllw     %%mm7, %%mm4 \n\t"	/* shift 4 WORDS of MM4 (N) bits to the right */
-		"packuswb  %%mm4, %%mm3 \n\t"	/* pack words back into bytes with saturation */
-		"movq    %%mm3, (%%edi) \n\t"	/* store result in Dest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"	/* check loop termination, proceed if required */
-		"jmp                 3f \n\t" ".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"2: movq (%%eax), %%mm3 \n\t"	/* load 8 bytes from Src1 into MM3 */
-		"movq      %%mm3, %%mm4 \n\t"	/* copy MM3 into MM4  */
-		"punpcklbw %%mm0, %%mm3 \n\t"	/* unpack low  bytes of SrcDest into words */
-		"punpckhbw %%mm0, %%mm4 \n\t"	/* unpack high bytes of SrcDest into words */
-		"psllw     %%mm7, %%mm3 \n\t"	/* shift 4 WORDS of MM3 (N) bits to the right */
-		"psllw     %%mm7, %%mm4 \n\t"	/* shift 4 WORDS of MM4 (N) bits to the right */
-		/* ** Take abs value of the signed words ** */
-		"movq      %%mm3, %%mm5 \n\t"	/* copy mm3 into mm5 */
-		"movq      %%mm4, %%mm6 \n\t"	/* copy mm4 into mm6 */
-		"psraw       $15, %%mm5 \n\t"	/* fill mm5 words with word sign bit */
-		"psraw       $15, %%mm6 \n\t"	/* fill mm6 words with word sign bit */
-		"pxor      %%mm5, %%mm3 \n\t"	/* take 1's compliment of only neg. words */
-		"pxor      %%mm6, %%mm4 \n\t"	/* take 1's compliment of only neg. words */
-		"psubsw    %%mm5, %%mm3 \n\t"	/* add 1 to only neg. words, W-(-1) or W-0 */
-		"psubsw    %%mm6, %%mm4 \n\t"	/* add 1 to only neg. words, W-(-1) or W-0 */
-		"packuswb  %%mm4, %%mm3 \n\t"	/* pack words back into bytes with saturation */
-		"movq    %%mm3, (%%edi) \n\t"	/* store result in Dest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 2b \n\t"	/* check loop termination, proceed if required */
-		"3: emms                \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(N)			/* %3 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	__m64 mm0 = _m_from_int(0);				/* zero mm0 register */
+	int i;
+	if (N <= 7) {						/* if (N <= 7) execute more efficient code */
+		for (i = 0; i < SrcLength/8; i++) {
+			__m64 mm3, mm4;
+			mm3 = _m_punpcklbw(*mSrc1, mm0);	/* unpack low  bytes of Src1 into words */
+			mm4 = _m_punpckhbw(*mSrc1, mm0);	/* unpack high bytes of Src1 into words */
+			mm3 = _m_psllwi(mm3, N);		/* shift 4 WORDS of MM3 (N) bits to the left */
+			mm4 = _m_psllwi(mm4, N);		/* shift 4 WORDS of MM4 (N) bits to the left */
+			*mDest = _m_packuswb(mm3, mm4);		/* pack words back into bytes with saturation */
+			mSrc1++;
+			mDest++;
+		}
+	} else {
+		for (i = 0; i < SrcLength/8; i++) {
+			__m64 mm3, mm4, mm5, mm6;
+			mm3 = _m_punpcklbw(*mSrc1, mm0);	/* unpack low  bytes of Src1 into words */
+			mm4 = _m_punpckhbw(*mSrc1, mm0);	/* unpack high bytes of Src1 into words */
+			mm3 = _m_psllwi(mm3, N);		/* shift 4 WORDS of MM3 (N) bits to the left */
+			mm4 = _m_psllwi(mm4, N);		/* shift 4 WORDS of MM4 (N) bits to the left */
+			/* Take abs value of the signed words */
+			mm5 = _m_psrawi(mm3, 15);		/* fill mm5 words with word sign bit */
+			mm6 = _m_psrawi(mm4, 15);		/* fill mm6 words with word sign bit */
+			mm3 = _m_pxor(mm3, mm5);		/* take 1's compliment of only neg. words */
+			mm4 = _m_pxor(mm4, mm6);		/* take 1's compliment of only neg. words */
+			mm3 = _m_psubsw(mm3, mm5);		/* add 1 to only neg. words, W-(-1) or W-0 */
+			mm4 = _m_psubsw(mm4, mm6);		/* add 1 to only neg. words, W-(-1) or W-0 */
+			*mDest = _m_packuswb(mm3, mm4);		/* pack words back into bytes with saturation */
+			mSrc1++;
+			mDest++;
+		}
+	}
+	_m_empty();						/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -3626,7 +3459,7 @@ int SDL_imageFilterShiftLeft(unsigned char *Src1, unsigned char *Dest, unsigned
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterBinarizeUsingThresholdMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char T)
+static int SDL_imageFilterBinarizeUsingThresholdMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char T)
 {
 #ifdef USE_MMX
 #if !defined(GCC__)
@@ -3663,40 +3496,26 @@ L1029:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t"
-		/* ** Duplicate T in 8 bytes of MM3 ** */
-		"pcmpeqb   %%mm1, %%mm1 \n\t"	/* generate all 1's in mm1 */
-		"pcmpeqb   %%mm2, %%mm2 \n\t"	/* generate all 1's in mm2 */
-		"mov           %3, %%al \n\t"	/* load T into AL */
-		"mov         %%al, %%ah \n\t"	/* copy AL into AH */
-		"mov         %%ax, %%bx \n\t"	/* copy AX into BX */
-		"shl         $16, %%eax \n\t"	/* shift 2 bytes of EAX left */
-		"mov         %%bx, %%ax \n\t"	/* copy BX into AX */
-		"movd      %%eax, %%mm3 \n\t"	/* copy EAX into MM3 */
-		"movd      %%eax, %%mm4 \n\t"	/* copy EAX into MM4 */
-		"punpckldq %%mm4, %%mm3 \n\t"	/* fill higher bytes of MM3 with T */
-		"psubusb   %%mm3, %%mm2 \n\t"	/* store 0xFF - T in MM2 */
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1:                     \n\t" 
-		"movq    (%%eax), %%mm0 \n\t"	/* load 8 bytes from SrcDest into MM0 */
-		"paddusb   %%mm2, %%mm0 \n\t"	/* MM0=SrcDest+(0xFF-T) (add 8 bytes with saturation) */
-		"pcmpeqb   %%mm1, %%mm0 \n\t"	/* binarize 255:0, comparing to 255 */
-		"movq    %%mm0, (%%edi) \n\t"	/* store result in SrcDest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"	/* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(T)			/* %3 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	/* Duplicate T in 8 bytes of MM3 */
+	__m64 mm1 = _m_pcmpeqb(mm1, mm1);			/* generate all 1's in mm1 */
+	__m64 mm2 = _m_pcmpeqb(mm2, mm2);			/* generate all 1's in mm1 */
+	int i;
+	memset(&i, T, 4);
+	__m64 mm3 = _m_from_int(i);
+	__m64 mm4 = _m_from_int(i);
+	mm3 = _m_punpckldq(mm3, mm4);			/* fill higher bytes of MM3 with T */
+	mm2 = _m_psubusb(mm2, mm3);			/* store 0xFF - T in MM2 */
+        //__m64 mm3 = _m_from_int64(lli); // x86_64 only
+	for (i = 0; i < SrcLength/8; i++) {
+		__m64 mm0 = _m_paddusb(*mSrc1, mm2);	/* Src1+(0xFF-T) (add 8 bytes with saturation) */
+		*mDest = _m_pcmpeqb(mm0, mm1);		/* binarize 255:0, comparing to 255 */
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -3775,7 +3594,7 @@ int SDL_imageFilterBinarizeUsingThreshold(unsigned char *Src1, unsigned char *De
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterClipToRangeMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char Tmin,
+static int SDL_imageFilterClipToRangeMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char Tmin,
 								  unsigned char Tmax)
 {
 #ifdef USE_MMX
@@ -3824,51 +3643,35 @@ L1030:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "pcmpeqb   %%mm1, %%mm1 \n\t"	/* generate all 1's in mm1 */
-		/* ** Duplicate Tmax in 8 bytes of MM3 ** */
-		"mov           %4, %%al \n\t"	/* load Tmax into AL */
-		"mov         %%al, %%ah \n\t"	/* copy AL into AH */
-		"mov         %%ax, %%bx \n\t"	/* copy AX into BX */
-		"shl         $16, %%eax \n\t"	/* shift 2 bytes of EAX left */
-		"mov         %%bx, %%ax \n\t"	/* copy BX into AX */
-		"movd      %%eax, %%mm3 \n\t"	/* copy EAX into MM3 */
-		"movd      %%eax, %%mm4 \n\t"	/* copy EAX into MM4 */
-		"punpckldq %%mm4, %%mm3 \n\t"	/* fill higher bytes of MM3 with Tmax */
-		"psubusb   %%mm3, %%mm1 \n\t"	/* store 0xFF - Tmax in MM1 */
-		/* ** Duplicate Tmin in 8 bytes of MM5 ** */
-		"mov           %3, %%al \n\t"	/* load Tmin into AL */
-		"mov         %%al, %%ah \n\t"	/* copy AL into AH */
-		"mov         %%ax, %%bx \n\t"	/* copy AX into BX */
-		"shl         $16, %%eax \n\t"	/* shift 2 bytes of EAX left */
-		"mov         %%bx, %%ax \n\t"	/* copy BX into AX */
-		"movd      %%eax, %%mm5 \n\t"	/* copy EAX into MM5 */
-		"movd      %%eax, %%mm4 \n\t"	/* copy EAX into MM4 */
-		"punpckldq %%mm4, %%mm5 \n\t"	/* fill higher bytes of MM5 with Tmin */
-		"movq      %%mm5, %%mm7 \n\t"	/* copy MM5 into MM7 */
-		"paddusb   %%mm1, %%mm7 \n\t"	/* store 0xFF - Tmax + Tmin in MM7 */
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1:                     \n\t" 
-		"movq    (%%eax), %%mm0 \n\t"	/* load 8 bytes from Src1 into MM0 */
-		"paddusb   %%mm1, %%mm0 \n\t"	/* MM0=SrcDest+(0xFF-Tmax) */
-		"psubusb   %%mm7, %%mm0 \n\t"	/* MM0=MM0-(0xFF-Tmax+Tmin) */
-		"paddusb   %%mm5, %%mm0 \n\t"	/* MM0=MM0+Tmin */
-		"movq    %%mm0, (%%edi) \n\t"	/* store result in Dest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"	/* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(Tmin),		/* %3 */
-		"m"(Tmax)			/* %4 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	__m64 mm1 = _m_pcmpeqb(mm1, mm1);	/* generate all 1's in mm1 */
+	int i;
+	/* Duplicate Tmax in 8 bytes of MM3 */
+	__m64 mm3, mm4;
+	memset(&i, Tmax, 4);
+	mm3 = _m_from_int(i);
+	mm4 = _m_from_int(i);
+	mm3 = _m_punpckldq(mm3, mm4);		/* fill higher bytes of MM3 with Tmax */
+	mm1 = _m_psubusb(mm1, mm3);		/* store 0xFF - Tmax in MM1 */
+        //__m64 mm3 = _m_from_int64(lli); // x86_64 only
+	/* Duplicate Tmax in 8 bytes of MM3 */
+	__m64 mm5, mm7;
+	memset(&i, Tmin, 4);
+	mm5 = _m_from_int(i);
+	mm4 = _m_from_int(i);
+	mm5 = _m_punpckldq(mm5, mm4);		/* fill higher bytes of MM5 with Tmin */
+	mm7 = _m_paddusb(mm5, mm1);	/* store 0xFF - Tmax + Tmin in MM7 */
+	for (i = 0; i < SrcLength/8; i++) {
+		__m64 mm0;
+		mm0 = _m_paddusb(*mSrc1, mm1);	/* MM0=Src1+(0xFF-Tmax) */
+		mm0 = _m_psubusb(mm0, mm7);	/* MM0=MM0-(0xFF-Tmax+Tmin) */
+		*mDest = _m_paddusb(mm0, mm5);	/* MM0+Tmin */
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();				/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -3957,7 +3760,7 @@ int SDL_imageFilterClipToRange(unsigned char *Src1, unsigned char *Dest, unsigne
 
 \return Returns 0 for success or -1 for error.
 */
-int SDL_imageFilterNormalizeLinearMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, int Cmin, int Cmax,
+static int SDL_imageFilterNormalizeLinearMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, int Cmin, int Cmax,
 									  int Nmin, int Nmax)
 {
 #ifdef USE_MMX
@@ -4034,79 +3837,57 @@ L1031:
 			popa
 	}
 #else
-	asm volatile
-		("pusha		     \n\t" "mov           %6, %%ax \n\t"	/* load Nmax in AX */
-		"mov           %4, %%bx \n\t"	/* load Cmax in BX */
-		"sub           %5, %%ax \n\t"	/* AX = Nmax - Nmin */
-		"sub           %3, %%bx \n\t"	/* BX = Cmax - Cmin */
-		"jz                  1f \n\t"	/* check division by zero */
-		"xor         %%dx, %%dx \n\t"	/* prepare for division, zero DX */
-		"div               %%bx \n\t"	/* AX = AX/BX */
-		"jmp                 2f \n\t" "1:                     \n\t" "mov         $255, %%ax \n\t"	/* if div by zero, assume result max. byte value */
-		"2:                    \n\t"	/* ** Duplicate AX in 4 words of MM0 ** */
-		"mov         %%ax, %%bx \n\t"	/* copy AX into BX */
-		"shl         $16, %%eax \n\t"	/* shift 2 bytes of EAX left */
-		"mov         %%bx, %%ax \n\t"	/* copy BX into AX */
-		"movd      %%eax, %%mm0 \n\t"	/* copy EAX into MM0 */
-		"movd      %%eax, %%mm1 \n\t"	/* copy EAX into MM1 */
-		"punpckldq %%mm1, %%mm0 \n\t"	/* fill higher words of MM0 with AX */
-		/* ** Duplicate Cmin in 4 words of MM1 ** */
-		"mov           %3, %%ax \n\t"	/* load Cmin into AX */
-		"mov         %%ax, %%bx \n\t"	/* copy AX into BX */
-		"shl         $16, %%eax \n\t"	/* shift 2 bytes of EAX left */
-		"mov         %%bx, %%ax \n\t"	/* copy BX into AX */
-		"movd      %%eax, %%mm1 \n\t"	/* copy EAX into MM1 */
-		"movd      %%eax, %%mm2 \n\t"	/* copy EAX into MM2 */
-		"punpckldq %%mm2, %%mm1 \n\t"	/* fill higher words of MM1 with Cmin */
-		/* ** Duplicate Nmin in 4 words of MM2 ** */
-		"mov           %5, %%ax \n\t"	/* load Nmin into AX */
-		"mov         %%ax, %%bx \n\t"	/* copy AX into BX */
-		"shl         $16, %%eax \n\t"	/* shift 2 bytes of EAX left */
-		"mov         %%bx, %%ax \n\t"	/* copy BX into AX */
-		"movd      %%eax, %%mm2 \n\t"	/* copy EAX into MM2 */
-		"movd      %%eax, %%mm3 \n\t"	/* copy EAX into MM3 */
-		"punpckldq %%mm3, %%mm2 \n\t"	/* fill higher words of MM2 with Nmin */
-		"pxor      %%mm7, %%mm7 \n\t"	/* zero MM7 register */
-		"mov          %1, %%eax \n\t"	/* load Src1 address into eax */
-		"mov          %0, %%edi \n\t"	/* load Dest address into edi */
-		"mov          %2, %%ecx \n\t"	/* load loop counter (SIZE) into ecx */
-		"shr          $3, %%ecx \n\t"	/* counter/8 (MMX loads 8 bytes at a time) */
-		".align 16              \n\t"	/* 16 byte alignment of the loop entry */
-		"1:                     \n\t" 
-		"movq    (%%eax), %%mm3 \n\t"	/* load 8 bytes from Src1 into MM3 */
-		"movq      %%mm3, %%mm4 \n\t"	/* copy MM3 into MM4  */
-		"punpcklbw %%mm7, %%mm3 \n\t"	/* unpack low  bytes of SrcDest into words */
-		"punpckhbw %%mm7, %%mm4 \n\t"	/* unpack high bytes of SrcDest into words */
-		"psubusb   %%mm1, %%mm3 \n\t"	/* S-Cmin, low  bytes */
-		"psubusb   %%mm1, %%mm4 \n\t"	/* S-Cmin, high bytes */
-		"pmullw    %%mm0, %%mm3 \n\t"	/* MM0*(S-Cmin), low  bytes */
-		"pmullw    %%mm0, %%mm4 \n\t"	/* MM0*(S-Cmin), high bytes */
-		"paddusb   %%mm2, %%mm3 \n\t"	/* MM0*(S-Cmin)+Nmin, low  bytes */
-		"paddusb   %%mm2, %%mm4 \n\t"	/* MM0*(S-Cmin)+Nmin, high bytes */
-		/* ** Take abs value of the signed words ** */
-		"movq      %%mm3, %%mm5 \n\t"	/* copy mm3 into mm5 */
-		"movq      %%mm4, %%mm6 \n\t"	/* copy mm4 into mm6 */
-		"psraw       $15, %%mm5 \n\t"	/* fill mm5 words with word sign bit */
-		"psraw       $15, %%mm6 \n\t"	/* fill mm6 words with word sign bit */
-		"pxor      %%mm5, %%mm3 \n\t"	/* take 1's compliment of only neg. words */
-		"pxor      %%mm6, %%mm4 \n\t"	/* take 1's compliment of only neg. words */
-		"psubsw    %%mm5, %%mm3 \n\t"	/* add 1 to only neg. words, W-(-1) or W-0 */
-		"psubsw    %%mm6, %%mm4 \n\t"	/* add 1 to only neg. words, W-(-1) or W-0 */
-		"packuswb  %%mm4, %%mm3 \n\t"	/* pack words back into bytes with saturation */
-		"movq    %%mm3, (%%edi) \n\t"	/* store result in Dest */
-		"add          $8, %%eax \n\t"	/* increase Src1 register pointer by 8 */
-		"add          $8, %%edi \n\t"	/* increase Dest register pointer by 8 */
-		"dec              %%ecx \n\t"	/* decrease loop counter */
-		"jnz                 1b \n\t"	/* check loop termination, proceed if required */
-		"emms                   \n\t"	/* exit MMX state */
-		"popa                   \n\t":"=m" (Dest)	/* %0 */
-		:"m"(Src1),		/* %1 */
-		"m"(SrcLength),		/* %2 */
-		"m"(Cmin),		/* %3 */
-		"m"(Cmax),		/* %4 */
-		"m"(Nmin),		/* %5 */
-		"m"(Nmax)			/* %6 */
-		);
+	/* i386 and x86_64 */
+	__m64 *mSrc1 = (__m64*)Src1;
+	__m64 *mDest = (__m64*)Dest;
+	__m64 mm0, mm1, mm2, mm3;
+
+	int i;
+	/* Duplicate (Nmax-Nmin)/(Cmax-Cmin) in 4 words of MM0 */
+	unsigned short a = Nmax - Nmin;
+	unsigned short b = Cmax - Cmin;
+	if (b == 0) {
+	    a = 255;
+	} else {
+	    a /= b;
+	}
+	i = (a<<16)|a;
+	mm0 = _m_from_int(i);
+	mm1 = _m_from_int(i);
+	mm0 = _m_punpckldq(mm0, mm1);			/* fill higher words of MM0 with AX */
+	/* Duplicate Cmin in 4 words of MM1 */
+	i = (Cmin<<16)|(short)Cmin;
+	mm1 = _m_from_int(i);
+	mm2 = _m_from_int(i);
+	mm1 = _m_punpckldq(mm1, mm2);			/* fill higher words of MM1 with Cmin */
+	/* Duplicate Nmin in 4 words of MM2 */
+	i = (Nmin<<16)|(short)Nmin;
+	mm2 = _m_from_int(i);
+	mm3 = _m_from_int(i);
+	mm2 = _m_punpckldq(mm2, mm3);			/* fill higher words of MM2 with Nmin */
+	__m64 mm7 = _m_from_int(0);			/* zero mm0 register */
+	for (i = 0; i < SrcLength/8; i++) {
+		__m64 mm3, mm4, mm5, mm6;
+		mm3 = _m_punpcklbw(*mSrc1, mm7);	/* unpack low  bytes of Src1 into words */
+		mm4 = _m_punpckhbw(*mSrc1, mm7);	/* unpack high bytes of Src1 into words */
+		mm3 = _m_psubusb(mm3, mm1);		/* S-Cmin, low	bytes */
+		mm4 = _m_psubusb(mm4, mm1);		/* S-Cmin, high bytes */
+		mm3 = _m_pmullw(mm3, mm0);		/* MM0*(S-Cmin), low  bytes */
+		mm4 = _m_pmullw(mm4, mm0);		/* MM0*(S-Cmin), high bytes */
+		mm3 = _m_paddusb(mm3, mm2);		/* MM0*(S-Cmin)+Nmin, low  bytes */
+		mm4 = _m_paddusb(mm4, mm2);		/* MM0*(S-Cmin)+Nmin, high bytes */
+		/* Take abs value of the signed words */
+		mm5 = _m_psrawi(mm3, 15);		/* fill mm5 words with word sign bit */
+		mm6 = _m_psrawi(mm4, 15);		/* fill mm6 words with word sign bit */
+		mm3 = _m_pxor(mm3, mm5);		/* take 1's compliment of only neg. words */
+		mm4 = _m_pxor(mm4, mm6);		/* take 1's compliment of only neg. words */
+		mm3 = _m_psubsw(mm3, mm5);		/* add 1 to only neg. words, W-(-1) or W-0 */
+		mm4 = _m_psubsw(mm4, mm6);		/* add 1 to only neg. words, W-(-1) or W-0 */
+		*mDest = _m_packuswb(mm3, mm4);		/* pack words back into bytes with saturation */
+		mSrc1++;
+		mDest++;
+	}
+	_m_empty();					/* clean MMX state */
 #endif
 	return (0);
 #else
@@ -4209,7 +3990,8 @@ int SDL_imageFilterConvolveKernel3x3Divide(unsigned char *Src, unsigned char *De
 		return (-1);
 
 	if ((SDL_imageFilterMMXdetect())) {
-#ifdef USE_MMX
+//#ifdef USE_MMX
+#if defined(USE_MMX) && defined(i386)
 #if !defined(GCC__)
 		__asm
 		{
@@ -4398,7 +4180,8 @@ int SDL_imageFilterConvolveKernel5x5Divide(unsigned char *Src, unsigned char *De
 		return (-1);
 
 	if ((SDL_imageFilterMMXdetect())) {
-#ifdef USE_MMX
+//#ifdef USE_MMX
+#if defined(USE_MMX) && defined(i386)
 #if !defined(GCC__)
 		__asm
 		{
@@ -4700,7 +4483,8 @@ int SDL_imageFilterConvolveKernel7x7Divide(unsigned char *Src, unsigned char *De
 		return (-1);
 
 	if ((SDL_imageFilterMMXdetect())) {
-#ifdef USE_MMX
+//#ifdef USE_MMX
+#if defined(USE_MMX) && defined(i386)
 #if !defined(GCC__)
 		__asm
 		{
@@ -5056,7 +4840,8 @@ int SDL_imageFilterConvolveKernel9x9Divide(unsigned char *Src, unsigned char *De
 		return (-1);
 
 	if ((SDL_imageFilterMMXdetect())) {
-#ifdef USE_MMX
+//#ifdef USE_MMX
+#if defined(USE_MMX) && defined(i386)
 #if !defined(GCC__)
 		__asm
 		{
@@ -5603,7 +5388,8 @@ int SDL_imageFilterConvolveKernel3x3ShiftRight(unsigned char *Src, unsigned char
 		return (-1);
 
 	if ((SDL_imageFilterMMXdetect())) {
-#ifdef USE_MMX
+//#ifdef USE_MMX
+#if defined(USE_MMX) && defined(i386)
 #if !defined(GCC__)
 		__asm
 		{
@@ -5779,7 +5565,8 @@ int SDL_imageFilterConvolveKernel5x5ShiftRight(unsigned char *Src, unsigned char
 		return (-1);
 
 	if ((SDL_imageFilterMMXdetect())) {
-#ifdef USE_MMX
+//#ifdef USE_MMX
+#if defined(USE_MMX) && defined(i386)
 #if !defined(GCC__)
 		__asm
 		{
@@ -6079,7 +5866,8 @@ int SDL_imageFilterConvolveKernel7x7ShiftRight(unsigned char *Src, unsigned char
 		return (-1);
 
 	if ((SDL_imageFilterMMXdetect())) {
-#ifdef USE_MMX
+//#ifdef USE_MMX
+#if defined(USE_MMX) && defined(i386)
 #if !defined(GCC__)
 		__asm
 		{
@@ -6441,7 +6229,8 @@ int SDL_imageFilterConvolveKernel9x9ShiftRight(unsigned char *Src, unsigned char
 		return (-1);
 
 	if ((SDL_imageFilterMMXdetect())) {
-#ifdef USE_MMX
+//#ifdef USE_MMX
+#if defined(USE_MMX) && defined(i386)
 #if !defined(GCC__)
 		__asm
 		{
@@ -7019,7 +6808,8 @@ int SDL_imageFilterSobelX(unsigned char *Src, unsigned char *Dest, int rows, int
 		return (-1);
 
 	if ((SDL_imageFilterMMXdetect())) {
-#ifdef USE_MMX
+//#ifdef USE_MMX
+#if defined(USE_MMX) && defined(i386)
 #if !defined(GCC__)
 		__asm
 		{
@@ -7271,7 +7061,8 @@ int SDL_imageFilterSobelXShiftRight(unsigned char *Src, unsigned char *Dest, int
 		return (-1);
 
 	if ((SDL_imageFilterMMXdetect())) {
-#ifdef USE_MMX
+//#ifdef USE_MMX
+#if defined(USE_MMX) && defined(i386)
 #if !defined(GCC__)
 		__asm
 		{
--- a/Test/TestImageFilter.c
+++ b/Test/TestImageFilter.c
@@ -3,25 +3,29 @@
 TestImageFilter.c: test program for MMX filter routines
 
 (C) A. Schiffler, 2006, zlib license
+(C) Sylvain Beucler, 2013, zlib license
 
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <time.h>
 
 #include "SDL.h"
 
 #ifdef WIN32
 #include <windows.h>
 #include "SDL_imageFilter.h"
-#ifndef bcmp
-#define bcmp(s1, s2, n) memcmp ((s1), (s2), (n))
+#ifndef bcmp
+#define bcmp(s1, s2, n) memcmp ((s1), (s2), (n))
 #endif
 #else
 #include "SDL/SDL_imageFilter.h"
 #endif
 
+#define SRC_SIZE 23
+
 int total_count = 0;
 int ok_count = 0;
 
@@ -36,6 +40,7 @@ void setup_src(unsigned char *src1, unsigned char *src2)
 	src1[4]=33;
 	for (i=5; i<14; i++) src1[i]=i;
 	src1[14]=8;
+	for (i=15; i<SRC_SIZE; i++) src1[i]=rand();
 
 	src2[0]=1;
 	src2[1]=3;
@@ -44,27 +49,44 @@ void setup_src(unsigned char *src1, unsigned char *src2)
 	src2[4]=44;
 	for (i=5; i<14; i++) src2[i]=14-i;
 	src2[14]=10;
+	for (i=15; i<SRC_SIZE; i++) src2[i]=src1[i];
 }
 
-void print_result(char *label,unsigned char *src1, unsigned char *src2, unsigned char *dst) 
+void print_result(int mmx, char *label, unsigned char *src1, unsigned char *src2, unsigned char *dst) 
 {
 	char blabel[80];
+        int i;
+	memset((void *)blabel, ' ', 80);
+	blabel[strlen(label)+4]=0;
+
+	printf("\n");
+        printf ("%s   pos   ", blabel);
+        for (i = 0; i < SRC_SIZE; i++)
+            printf("%2d ", i);
+        printf("\n");
+
+        printf ("%s   src1  ", blabel);
+        for (i = 0; i < SRC_SIZE; i++)
+            printf("%02x ", src1[i]);
+        printf("\n");
 
-	memset((void *)blabel,(int)' ',80);
-	blabel[strlen(label)]=0;
-	printf ("%s   pos   %2d %2d %2d %2d %2d %2d %2d %2d %2d .. %2d\n",blabel,0,1,2,3,4,5,6,7,8,14);
-	printf ("%s   src1  %02x %02x %02x %02x %02x %02x %02x %02x %02x .. %02x\n",blabel,src1[0],src1[1],src1[2],src1[3],src1[4],src1[5],src1[6],src1[7],src1[8],src1[14]);
 	if (src2) {
-		printf ("%s   src2  %02x %02x %02x %02x %02x %02x %02x %02x %02x .. %02x\n",blabel,src2[0],src2[1],src2[2],src2[3],src2[4],src2[5],src2[6],src2[7],src2[8],src2[14]);
+            printf ("%s   src2  ", blabel);
+            for (i = 0; i < SRC_SIZE; i++)
+                printf("%02x ", src2[i]);
 	}
-	printf ("%s   dest  %02x %02x %02x %02x %02x %02x %02x %02x %02x .. %02x\n",label, dst[0], dst[1], dst[2], dst[3], dst[4], dst[5], dst[6], dst[7], dst[8],dst[14]);
-	printf ("\n");
+        printf("\n");
+
+	printf ("%s %s   dest  ",mmx?"MMX":" C ",label);
+        for (i = 0; i < SRC_SIZE; i++)
+            printf("%02x ", dst[i]);
+        printf("\n");
 }
 
 void print_compare(unsigned char *dst1, unsigned char *dst2) 
 { 
 	total_count++;
-	if (bcmp(dst1,dst2,15)==0) {
+	if (bcmp(dst1,dst2,SRC_SIZE)==0) {
 		printf ("OK\n");
 		ok_count++;
 	} else {
@@ -79,441 +101,339 @@ void print_line()
 
 void pause()
 {
-	char ch;
-	do {  
-		ch = getchar();  
-		putchar('.');  
-	} while (ch != '\n');
+	char ch;
+	do {
+		ch = getchar();
+		putchar('.');
+	} while (ch != '\n');
 }
 
 /* ----------- main ---------- */
 
 int main(int argc, char *argv[])
 {
-	unsigned char src1[15],src2[15],dstm[15],dstc[15];
+	unsigned char
+		src1[SRC_SIZE], src2[SRC_SIZE],
+		dstm[SRC_SIZE], dstc[SRC_SIZE];
+        printf("src1:\t%s (%p)\tsrc2:\t%s (%p)\tdstm:\t%s (%p)\tdstc:\t%s (%p)\n",
+               ((long long)src1%8) ? "not aligned" : "aligned", src1,
+               ((long long)src2%8) ? "not aligned" : "aligned", src2,
+               ((long long)dstm%8) ? "not aligned" : "aligned", dstm,
+               ((long long)dstc%8) ? "not aligned" : "aligned", dstc);
+
+        int size = 2*1024*1024;
+        unsigned char
+		*t1 = malloc(size), *t2 = malloc(size), *d = malloc(size);
+	// Interestingly, C tests are about 4x faster
+	// on malloc(size) than on char[size]
+        printf("t1:\t%s (%p)\tt2:\t%s (%p)\td:\t%s (%p)\n",
+               ((long long)t1%8) ? "not aligned" : "aligned", t1,
+               ((long long)t2%8) ? "not aligned" : "aligned", t2,
+               ((long long) d%8) ? "not aligned" : "aligned",  d);
+	{
+		/* Initialize to make valgrind happy */
+		srand(time(NULL));
+		int i;
+		for (i = 0; i < size; i++) {
+			/* use more random lower-order bits (int->char) */
+			t1[i] = rand(); t2[i] = rand(); d[i] = rand();
+		}
+	}
+	Uint32 start;
+        int i;
+	
+        SDL_Init(SDL_INIT_TIMER);
 
 	/* SDL_imageFilter Test */
 
 	printf ("TestImageFilter\n\n");
-	printf ("Testing an array of 15 bytes - first 8 bytes should be processed\n");
+	printf ("Testing an array of 23 bytes - first 16 bytes should be processed\n");
 	printf ("by MMX or C code, the last 7 bytes only by C code.\n\n");
-
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2); 
-	SDL_imageFilterBitAnd ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstm,15); 
-	print_result ("MMX BitAnd", src1, src2, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2); 
-	SDL_imageFilterBitAnd ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstc,15); 
-	print_result (" C  BitAnd", src1, src2, dstc);
-
-	print_compare(dstm,dstc);
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterBitOr ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstm,15);
-	print_result ("MMX BitOr", src1, src2, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterBitOr ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstc,15);
-	print_result (" C  BitOr", src1, src2, dstc);
-
-	print_compare(dstm,dstc);
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterAdd ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstm,15);
-	print_result ("MMX Add", src1, src2, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterAdd ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstc,15);
-	print_result (" C  Add", src1, src2, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterAbsDiff ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstm,15);
-	print_result ("MMX AbsDiff", src1, src2, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterAbsDiff ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstc,15);
-	print_result (" C  AbsDiff", src1, src2, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterMean ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstm,15);
-	print_result ("MMX Mean", src1, src2, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterMean ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstc,15);
-	print_result (" C  Mean", src1, src2, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterSub ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstm,15);
-	print_result ("MMX Sub", src1, src2, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterSub ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstc,15);
-	print_result (" C  Sub", src1, src2, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterMult ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstm,15);
-	print_result ("MMX Mult", src1, src2, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterMult ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstc,15);
-	print_result (" C  Mult", src1, src2, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterMultNor ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstm,15);
-	print_result ("ASM MultNor", src1, src2, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterMultNor ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstc,15);
-	print_result (" C  MultNor", src1, src2, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterMultDivby2 ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstm,15);
-	print_result ("MMX MultDivby2", src1, src2, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterMultDivby2 ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstc,15);
-	print_result (" C  MultDivby2", src1, src2, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterMultDivby4 ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstm,15);
-	print_result ("MMX MultDivby4", src1, src2, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterMultDivby4 ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstc,15);
-	print_result (" C  MultDivby4", src1, src2, dstc);
-
-	print_compare(dstm,dstc); 
+	
 	print_line();
+	
+	
+#define	TEST_C   0
+#define	TEST_MMX 1
+        {
+#define FUNC(f) { #f, SDL_imageFilter ## f }
+		struct func {
+			char* name;
+			int (*f)(unsigned char*, unsigned char*, unsigned char*, unsigned int);
+		};
+		struct func funcs[] = {
+			FUNC(BitAnd),
+			FUNC(BitOr),
+			FUNC(Add),
+			FUNC(AbsDiff),
+			FUNC(Mean),
+			FUNC(Sub),
+			FUNC(Mult),
+			FUNC(MultNor),
+			FUNC(MultDivby2),
+			FUNC(MultDivby4),
+			FUNC(Div),
+		};
+		
+		int k;
+		for (k = 0; k < sizeof(funcs)/sizeof(struct func); k++) {
+			Uint32 start;
+			int i;
+			
+			setup_src(src1, src2);
+
+			SDL_imageFilterMMXon();
+			funcs[k].f(src1, src2, dstm, SRC_SIZE);
+			print_result(TEST_MMX, funcs[k].name, src1, src2, dstm);
+			start = SDL_GetTicks();
+			for (i = 0; i < 50; i++) {
+				funcs[k].f(t1, t2, d, size);
+			}
+			printf("MMX %dx%dk: %dms\n", i, size/1024, SDL_GetTicks() - start);
+			
+			SDL_imageFilterMMXoff();
+			funcs[k].f(src1, src2, dstc, SRC_SIZE);
+			print_result(TEST_C, funcs[k].name, src1, src2, dstc);
+			start = SDL_GetTicks();
+			for (i = 0; i < 50; i++) {
+				funcs[k].f(t1, t2, d, size);
+			}
+			printf(" C  %dx%dk: %dms\n", i, size/1024, SDL_GetTicks() - start);
+			
+			print_compare(dstm,dstc);
+			print_line();
+		}
+        }
+
+	/* setup_src(src1, src2); */
+	/* SDL_imageFilterMultNor(src1, src2, dstc, SRC_SIZE); */
+        /* start = SDL_GetTicks(); */
+        /* for (i = 0; i < 50; i++) { */
+        /*     SDL_imageFilterMultNor(t1, t2, d, size); */
+        /* } */
+        /* printf(" C  %dx%d: %dms\n", i, size, SDL_GetTicks() - start); */
+	/* print_result(TEST_C, "MultNor", src1, src2, dstc); */
+        /* { */
+        /*     unsigned char expected[] = { 0x01, 0x0c, 0x03, 0x06, 0xac, 0x2d, 0x30, 0x31, */
+        /*                                  0x30, 0x2d, 0x28, 0x21, 0x18, 0x0d, 0x50, 0xf1, */
+        /*                                  0xe0, 0xcd, 0xb8, 0xa1, 0x88, 0x6d, 0x50 }; */
+        /*     print_compare(dstc, expected); */
+        /* } */
+	/* print_line(); */
+        /* exit(0); */
+
+
+        {
+		Uint32 start;
+		int i;
+		char call[1024];
+		sprintf(call, "BitNegation");
+		
+		setup_src(src1, src2);
+		
+		SDL_imageFilterMMXon();
+		SDL_imageFilterBitNegation(src1, dstm, SRC_SIZE);
+		print_result(TEST_MMX, call, src1, NULL, dstm);
+		start = SDL_GetTicks();
+		for (i = 0; i < 50; i++) {
+			SDL_imageFilterBitNegation(t1, d, size);
+		}
+		printf("MMX %dx%dk: %dms\n", i, size/1024, SDL_GetTicks() - start);
+		
+		SDL_imageFilterMMXoff();
+		SDL_imageFilterBitNegation(src1, dstc, SRC_SIZE);
+		print_result(TEST_C, call, src1, NULL, dstc);
+		start = SDL_GetTicks();
+		for (i = 0; i < 50; i++) {
+			SDL_imageFilterBitNegation(t1, d, size);
+		}
+		printf(" C  %dx%dk: %dms\n", i, size/1024, SDL_GetTicks() - start);
+		
+		print_compare(dstm,dstc);
+		print_line();
+        }
+
+	
+        {
+#undef FUNC
+#define FUNC(f, c) { #f, SDL_imageFilter ## f, c }
+		struct func {
+			char* name;
+			int (*f)(unsigned char*, unsigned char*, unsigned int, unsigned char);
+			unsigned char arg;
+		};
+		struct func funcs[] = {
+			FUNC(AddByte,                3),
+			FUNC(AddByteToHalf,          3),
+			FUNC(SubByte,                3),
+			FUNC(ShiftRight,             1),
+			FUNC(ShiftRightUint,         4),
+			FUNC(MultByByte,             3),
+			FUNC(ShiftLeftByte,          3),
+			FUNC(ShiftLeft,              3),
+			FUNC(ShiftLeftUint,          4),
+			FUNC(BinarizeUsingThreshold, 9),
+		};
+		
+		int k;
+		for (k = 0; k < sizeof(funcs)/sizeof(struct func); k++) {
+			Uint32 start;
+			int i;
+			char call[1024];
+			sprintf(call, "%s(%u)", funcs[k].name, funcs[k].arg);
+			
+			setup_src(src1, src2);
+
+			SDL_imageFilterMMXon();
+			funcs[k].f(src1, dstm, SRC_SIZE, funcs[k].arg);
+			print_result(TEST_MMX, call, src1, NULL, dstm);
+			start = SDL_GetTicks();
+			for (i = 0; i < 50; i++) {
+				funcs[k].f(t1, d, size, funcs[k].arg);
+			}
+			printf("MMX %dx%dk: %dms\n", i, size/1024, SDL_GetTicks() - start);
+			
+			SDL_imageFilterMMXoff();
+			funcs[k].f(src1, dstc, SRC_SIZE, funcs[k].arg);
+			print_result(TEST_C, call, src1, NULL, dstc);
+			start = SDL_GetTicks();
+			for (i = 0; i < 50; i++) {
+				funcs[k].f(t1, d, size, funcs[k].arg);
+			}
+			printf(" C  %dx%dk: %dms\n", i, size/1024, SDL_GetTicks() - start);
+			
+			print_compare(dstm,dstc);
+			print_line();
+		}
+        }
+
+	
+        {
+#undef FUNC
+#define FUNC(f, c1, c2) { #f, SDL_imageFilter ## f, c1, c2 }
+		struct func {
+			char* name;
+			int (*f)(unsigned char*, unsigned char*, unsigned int, unsigned char, unsigned char);
+			unsigned char arg1, arg2;
+		};
+		struct func funcs[] = {
+			FUNC(ShiftRightAndMultByByte, 1, 3),
+			FUNC(ClipToRange, 3, 8),
+		};
+		
+		int k;
+		for (k = 0; k < sizeof(funcs)/sizeof(struct func); k++) {
+			Uint32 start;
+			int i;
+			char call[1024];
+			sprintf(call, "%s(%u,%u)", funcs[k].name, funcs[k].arg1, funcs[k].arg2);
+			
+			setup_src(src1, src2);
+
+			SDL_imageFilterMMXon();
+			funcs[k].f(src1, dstm, SRC_SIZE, funcs[k].arg1, funcs[k].arg2);
+			print_result(TEST_MMX, call, src1, NULL, dstm);
+			start = SDL_GetTicks();
+			for (i = 0; i < 50; i++) {
+				funcs[k].f(t1, d, size, funcs[k].arg1, funcs[k].arg2);
+			}
+			printf("MMX %dx%dk: %dms\n", i, size/1024, SDL_GetTicks() - start);
+			
+			SDL_imageFilterMMXoff();
+			funcs[k].f(src1, dstc, SRC_SIZE, funcs[k].arg1, funcs[k].arg2);
+			print_result(TEST_C, call, src1, NULL, dstc);
+			start = SDL_GetTicks();
+			for (i = 0; i < 50; i++) {
+				funcs[k].f(t1, d, size, funcs[k].arg1, funcs[k].arg2);
+			}
+			printf(" C  %dx%dk: %dms\n", i, size/1024, SDL_GetTicks() - start);
+			
+			print_compare(dstm,dstc);
+			print_line();
+		}
+        }
+
+        
+        {
+		Uint32 start;
+		int i;
+		char call[1024];
+		sprintf(call, "NormalizeLinear(0,33,0,255)");
+		
+		setup_src(src1, src2);
+		
+		SDL_imageFilterMMXon();
+		SDL_imageFilterNormalizeLinear(src1, dstm, SRC_SIZE, 0,33, 0,255);
+		print_result(TEST_MMX, call, src1, NULL, dstm);
+		start = SDL_GetTicks();
+		for (i = 0; i < 50; i++) {
+			SDL_imageFilterNormalizeLinear(t1, d, size, 0,33, 0,255);
+		}
+		printf("MMX %dx%dk: %dms\n", i, size/1024, SDL_GetTicks() - start);
+		
+		SDL_imageFilterMMXoff();
+		SDL_imageFilterNormalizeLinear(src1, dstc, SRC_SIZE, 0,33, 0,255);
+		print_result(TEST_C, call, src1, NULL, dstc);
+		start = SDL_GetTicks();
+		for (i = 0; i < 50; i++) {
+			SDL_imageFilterNormalizeLinear(t1, d, size, 0,33, 0,255);
+		}
+		printf(" C  %dx%dk: %dms\n", i, size/1024, SDL_GetTicks() - start);
+		
+		print_compare(dstm,dstc);
+		print_line();
+        }
 
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterDiv ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstm,15);
-	print_result ("ASM Div", src1, src2, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterDiv ((unsigned char *)src1,(unsigned char *)src2,(unsigned char *)dstc,15);
-	print_result (" C  Div", src1, src2, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterBitNegation ((unsigned char *)src1,(unsigned char *)dstm,15);
-	print_result ("MMX BitNegation", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterBitNegation ((unsigned char *)src1,(unsigned char *)dstc,15);
-	print_result (" C  BitNegation", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterAddByte ((unsigned char *)src1,(unsigned char *)dstm,15, 3);
-	print_result ("MMX AddByte(3)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterAddByte ((unsigned char *)src1,(unsigned char *)dstc,15, 3);
-	print_result (" C  AddByte(3)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterAddByteToHalf ((unsigned char *)src1,(unsigned char *)dstm,15, 3);
-	print_result ("MMX AddByteToHalf(3)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterAddByteToHalf ((unsigned char *)src1,(unsigned char *)dstc,15, 3);
-	print_result (" C  AddByteToHalf(3)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterSubByte ((unsigned char *)src1,(unsigned char *)dstm,15, 3);
-	print_result ("MMX SubByte(3)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterSubByte ((unsigned char *)src1,(unsigned char *)dstc,15, 3);
-	print_result (" C  SubByte(3)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterShiftRight ((unsigned char *)src1,(unsigned char *)dstm,15, 1);
-	print_result ("MMX ShiftRight(1)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterShiftRight ((unsigned char *)src1,(unsigned char *)dstc,15, 1);
-	print_result (" C  ShiftRight(1)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterMultByByte ((unsigned char *)src1,(unsigned char *)dstm,15, 3);
-	print_result ("MMX MultByByte(3)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterMultByByte ((unsigned char *)src1,(unsigned char *)dstc,15, 3);
-	print_result (" C  MultByByte(3)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterShiftRightAndMultByByte ((unsigned char *)src1,(unsigned char *)dstm,15, 1, 3);
-	print_result ("MMX ShiftRightAndMultByByte(1,3)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterShiftRightAndMultByByte ((unsigned char *)src1,(unsigned char *)dstc,15, 1, 3);
-	print_result (" C  ShuftRightAndMultByByte(1,3)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterShiftLeftByte ((unsigned char *)src1,(unsigned char *)dstm,15, 3);
-	print_result ("MMX ShiftLeftByte(3)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterShiftLeftByte ((unsigned char *)src1,(unsigned char *)dstc,15, 3);
-	print_result (" C  ShiftLeftByte(3)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterShiftLeft ((unsigned char *)src1,(unsigned char *)dstm,15, 3);
-	print_result ("MMX ShiftLeft(3)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterShiftLeft ((unsigned char *)src1,(unsigned char *)dstc,15, 3);
-	print_result (" C  ShiftLeft(3)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterBinarizeUsingThreshold ((unsigned char *)src1,(unsigned char *)dstm,15, 2);
-	print_result ("MMX BinarizeUsingThreshold(2)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterBinarizeUsingThreshold ((unsigned char *)src1,(unsigned char *)dstc,15, 2);
-	print_result (" C  BinarizeUsingThreshold(2)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterClipToRange ((unsigned char *)src1,(unsigned char *)dstm,15, 1,7);
-	print_result ("MMX ClipToRange(1,7)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterClipToRange ((unsigned char *)src1,(unsigned char *)dstc,15, 1,7);
-	print_result (" C  ClipToRange(1,7)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterNormalizeLinear ((unsigned char *)src1,(unsigned char *)dstm,15, 0,33,0,255);
-	print_result ("MMX NormalizeLinear(0,33,0,255)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterNormalizeLinear ((unsigned char *)src1,(unsigned char *)dstc,15, 0,33,0,255);
-	print_result (" C  NormalizeLinear(0,33,0,255)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
 
 	/* Uint functions */
+	/* Disabled, since broken *//* ??? */
+        {
+#undef FUNC
+#define FUNC(f, c) { #f, SDL_imageFilter ## f, c }
+		struct func {
+			char* name;
+			int (*f)(unsigned char*, unsigned char*, unsigned int, unsigned int);
+			unsigned int arg;
+		};
+		struct func funcs[] = {
+			FUNC(AddUint,       0x01020304),
+			FUNC(SubUint,       0x01020304),
+		};
+		
+		int k;
+		for (k = 0; k < sizeof(funcs)/sizeof(struct func); k++) {
+			Uint32 start;
+			int i;
+			char call[1024];
+			sprintf(call, "%s(%u)", funcs[k].name, funcs[k].arg);
+			
+			setup_src(src1, src2);
+
+			SDL_imageFilterMMXon();
+			funcs[k].f(src1, dstm, SRC_SIZE, funcs[k].arg);
+			print_result(TEST_MMX, call, src1, NULL, dstm);
+			start = SDL_GetTicks();
+			for (i = 0; i < 50; i++) {
+				funcs[k].f(t1, d, size, funcs[k].arg);
+			}
+			printf("MMX %dx%dk: %dms\n", i, size/1024, SDL_GetTicks() - start);
+			
+			SDL_imageFilterMMXoff();
+			funcs[k].f(src1, dstc, SRC_SIZE, funcs[k].arg);
+			print_result(TEST_C, call, src1, NULL, dstc);
+			start = SDL_GetTicks();
+			for (i = 0; i < 50; i++) {
+				funcs[k].f(t1, d, size, funcs[k].arg);
+			}
+			printf(" C  %dx%dk: %dms\n", i, size/1024, SDL_GetTicks() - start);
+			
+			print_compare(dstm,dstc);
+			print_line();
+		}
+        }
 
-	/* Disabled, since broken */
-	/*
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterAddUint ((unsigned char *)src1,(unsigned char *)dstm,15, 0x01020304);
-	print_result ("MMX AddUint(0x01020304)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterAddUint ((unsigned char *)src1,(unsigned char *)dstc,15, 0x01020304);
-	print_result (" C  AddUint(0x01020304)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
 
 	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterSubUint ((unsigned char *)src1,(unsigned char *)dstm,15, 0x01020304);
-	print_result ("MMX SubUint(0x01020304)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterSubUint ((unsigned char *)src1,(unsigned char *)dstc,15, 0x01020304);
-	print_result (" C  SubUint(0x01020304)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterShiftRightUint ((unsigned char *)src1,(unsigned char *)dstm,15, 4);
-	print_result ("MMX ShiftRightUint(4)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterShiftRightUint ((unsigned char *)src1,(unsigned char *)dstc,15, 4);
-	print_result (" C  ShiftRightUint(4)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	SDL_imageFilterMMXon();
-
-	setup_src(src1, src2);
-	SDL_imageFilterShiftLeftUint ((unsigned char *)src1,(unsigned char *)dstm,15, 4);
-	print_result ("MMX ShiftLeftUint(4)", src1, NULL, dstm);
-
-	SDL_imageFilterMMXoff();
-
-	setup_src(src1, src2);
-	SDL_imageFilterShiftLeftUint ((unsigned char *)src1,(unsigned char *)dstc,15, 4);
-	print_result (" C  ShiftLeftUint(4)", src1, NULL, dstc);
-
-	print_compare(dstm,dstc); 
-	print_line();
-
-	*/
-
-#ifdef USE_MMX
-	SDL_imageFilterMMXon();
 	if (SDL_imageFilterMMXdetect())
 	{
 		printf("MMX was detected\n\n");
@@ -522,17 +442,17 @@ int main(int argc, char *argv[])
 	{
 		printf("MMX was NOT detected\n\n");
 	}
-#else
-	printf("MMX support disabled in SDL_gfx.\n\n");
-#endif
 
 	printf ("Result: %i of %i passed OK.\n", ok_count, total_count);
 
 #ifdef WIN32 
-	printf("Press Enter to continue ...");
+	printf("Press Enter to continue ...");
 	pause();
 #endif
 
+	SDL_Quit();
+	free(d);
+	free(t2);
+	free(t1);
 	exit(0);
 }
-
--- a/configure.in
+++ b/configure.in
@@ -105,15 +105,13 @@ LIBS="$LIBS $MATHLIB"
 dnl Check for NASM (for x86 assembly blit routines)
 AC_ARG_ENABLE(mmx,[  --enable-mmx            use mmx assembly on x86 [default=yes], disable this on non-x86 platforms],, enable_mmx=yes)
 
-dnl MMX not used on 64-bit platforms, as `popa' and `pusha' are not supported
-dnl in 64-bit mode.
-AC_CHECK_SIZEOF([long])
-if test "$ac_cv_sizeof_long" = "8"; then
-       enable_mmx=no
-fi
- 
 if test x$enable_mmx = xyes; then
- CFLAGS="$CFLAGS -O -DUSE_MMX"
+  CFLAGS="$CFLAGS -O -DUSE_MMX"
+  dnl MMX enabled by default in GCC on x86_64, but not i386:
+  AC_CHECK_SIZEOF([long])
+  if test "$ac_cv_sizeof_long" = "4"; then
+          CFLAGS="$CFLAGS -mmmx"
+  fi
 fi
 
 dnl Check for SDL
@@ -131,3 +129,7 @@ AC_OUTPUT([
 Makefile
 SDL_gfx.pc
 ])
+
+echo
+echo "Options summary:"
+echo "* --enable-mmx: $enable_mmx"
