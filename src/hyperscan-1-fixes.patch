This file is part of MXE.
See index.html for further information.

Contains ad hoc patches for cross building.

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Boris Nagaev <bnagaev@gmail.com>
Date: Tue, 17 May 2016 19:02:54 +0200
Subject: [PATCH] add output of Ragel from build

Workaround not to include Ragel as a dependency.

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1111111..2222222 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -18,7 +18,6 @@ INCLUDE (CheckLibraryExists)
 INCLUDE (CheckSymbolExists)
 include (CMakeDependentOption)
 include (${CMAKE_MODULE_PATH}/platform.cmake)
-include (${CMAKE_MODULE_PATH}/ragel.cmake)
 
 find_package(PkgConfig QUIET)
 
@@ -82,7 +81,6 @@ endif()
 
 # -- make this work? set(python_ADDITIONAL_VERSIONS 2.7 2.6)
 find_package(PythonInterp)
-find_program(RAGEL ragel)
 
 if(PYTHONINTERP_FOUND)
     set(PYTHON ${PYTHON_EXECUTABLE})
@@ -90,10 +88,6 @@ else()
     message(FATAL_ERROR "No python interpreter found")
 endif()
 
-if(${RAGEL} STREQUAL "RAGEL-NOTFOUND")
-    message(FATAL_ERROR "Ragel state machine compiler not found")
-endif()
-
 option(OPTIMISE "Turns off compiler optimizations (on by default unless debug output enabled or coverage testing)" TRUE)
 
 option(DEBUG_OUTPUT "Enable debug output (warning: very verbose)" FALSE)
@@ -362,12 +356,10 @@ set(RAGEL_C_FLAGS "-Wno-unused")
 endif()
 
 set_source_files_properties(
-    ${CMAKE_BINARY_DIR}/src/parser/Parser.cpp
+    ${CMAKE_SOURCE_DIR}/src/parser/Parser.cpp
     PROPERTIES
         COMPILE_FLAGS "${RAGEL_C_FLAGS}")
 
-ragelmaker(src/parser/Parser.rl)
-
 SET(hs_HEADERS
     src/hs.h
     src/hs_common.h
@@ -935,7 +927,6 @@ endif()
 # we want the static lib for testing
 add_library(hs STATIC ${hs_SRCS} $<TARGET_OBJECTS:hs_exec>)
 
-add_dependencies(hs ragel_Parser)
 add_dependencies(hs autogen_compiler autogen_teddy_compiler)
 
 if (NOT BUILD_SHARED_LIBS)
@@ -944,7 +935,6 @@ endif()
 
 if (BUILD_STATIC_AND_SHARED OR BUILD_SHARED_LIBS)
     add_library(hs_shared SHARED ${hs_SRCS} $<TARGET_OBJECTS:hs_exec_shared>)
-    add_dependencies(hs_shared ragel_Parser)
     add_dependencies(hs_shared autogen_compiler autogen_teddy_compiler)
     set_target_properties(hs_shared PROPERTIES
         OUTPUT_NAME hs
diff --git a/src/parser/Parser.cpp b/src/parser/Parser.cpp
new file mode 100644
index 1111111..2222222
--- /dev/null
+++ b/src/parser/Parser.cpp
@@ -0,0 +1,5436 @@
+
+#line 1 "hyperscan-4.1.0/src/parser/Parser.rl"
+/*
+ * Copyright (c) 2015, Intel Corporation
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *  * Neither the name of Intel Corporation nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \file
+ * \brief Parser code (generated with Ragel from Parser.rl).
+ */
+
+#include "config.h"
+
+/* Parser.cpp is a built source, may not be in same dir as parser files */
+#include "parser/check_refs.h"
+#include "parser/ComponentAlternation.h"
+#include "parser/ComponentAssertion.h"
+#include "parser/ComponentAtomicGroup.h"
+#include "parser/ComponentBackReference.h"
+#include "parser/ComponentBoundary.h"
+#include "parser/ComponentByte.h"
+#include "parser/ComponentClass.h"
+#include "parser/ComponentCondReference.h"
+#include "parser/ComponentEmpty.h"
+#include "parser/ComponentEUS.h"
+#include "parser/Component.h"
+#include "parser/ComponentRepeat.h"
+#include "parser/ComponentSequence.h"
+#include "parser/ComponentWordBoundary.h"
+#include "parser/parse_error.h"
+#include "parser/Parser.h"
+#include "ue2common.h"
+#include "util/compare.h"
+#include "util/make_unique.h"
+#include "util/ue2_containers.h"
+#include "util/unicode_def.h"
+#include "util/verify_types.h"
+
+#include <cassert>
+#include <cctype>
+#include <cstring>
+#include <cstdlib>
+#include <map>
+#include <sstream>
+#include <string>
+#include <vector>
+
+using namespace std;
+
+namespace ue2 {
+
+#define PUSH_SEQUENCE do {\
+        sequences.push_back(ExprState(currentSeq, (size_t)(ts - ptr), \
+                mode)); \
+    } while(0)
+#define POP_SEQUENCE do {\
+        currentSeq = sequences.back().seq; \
+        mode = sequences.back().mode; \
+        sequences.pop_back(); \
+    } while(0)
+
+namespace {
+
+/** \brief Structure representing current state as we're parsing (current
+ * sequence, current options). Stored in the 'sequences' vector. */
+struct ExprState {
+    ExprState(ComponentSequence *seq_in, size_t offset,
+              const ParseMode &mode_in) :
+        seq(seq_in), seqOffset(offset), mode(mode_in) {}
+
+    ComponentSequence *seq; //!< current sequence
+    size_t seqOffset; //!< offset seq was entered, for error reporting
+    ParseMode mode; //!< current mode flags
+};
+
+} // namespace
+
+static
+unsigned parseAsDecimal(unsigned oct) {
+    // The input was parsed as octal, but should have been parsed as decimal.
+    // Deconstruct the octal number and reconstruct into decimal
+    unsigned ret = 0;
+    unsigned multiplier = 1;
+    while (oct) {
+        ret += (oct & 0x7) * multiplier;
+        oct >>= 3;
+        multiplier *= 10;
+    }
+    return ret;
+}
+
+/** \brief Maximum value for a positive integer. We use INT_MAX, as that's what
+ * PCRE uses. */
+static constexpr u32 MAX_NUMBER = INT_MAX;
+
+static
+void pushDec(u32 *acc, u8 raw_digit) {
+    assert(raw_digit >= '0' && raw_digit <= '9');
+    u32 digit_val = raw_digit - '0';
+
+    // Ensure that we don't overflow.
+    u64a val = ((u64a)*acc * 10) + digit_val;
+    if (val > MAX_NUMBER) {
+        throw LocatedParseError("Number is too big");
+    }
+
+    *acc = verify_u32(val);
+}
+
+static
+void pushOct(u32 *acc, u8 raw_digit) {
+    assert(raw_digit >= '0' && raw_digit <= '7');
+    u32 digit_val = raw_digit - '0';
+
+    // Ensure that we don't overflow.
+    u64a val = ((u64a)*acc * 8) + digit_val;
+    if (val > MAX_NUMBER) {
+        throw LocatedParseError("Number is too big");
+    }
+
+    *acc = verify_u32(val);
+}
+
+static
+void throwInvalidRepeat(void) {
+    throw LocatedParseError("Invalid repeat");
+}
+
+static
+void throwInvalidUtf8(void) {
+    throw ParseError("Expression is not valid UTF-8.");
+}
+
+/**
+ * Adds the given child component to the parent sequence, returning a pointer
+ * to the new (child) "current sequence".
+ */
+static
+ComponentSequence *enterSequence(ComponentSequence *parent,
+                                 unique_ptr<ComponentSequence> child) {
+    assert(parent);
+    assert(child);
+
+    ComponentSequence *seq = child.get();
+    parent->addComponent(move(child));
+    return seq;
+}
+
+static
+void addLiteral(ComponentSequence *currentSeq, unsigned char c,
+                const ParseMode &mode) {
+    if (mode.utf8 && mode.caseless) {
+        /* leverage ComponentClass to generate the vertices */
+        auto cc = getComponentClass(mode);
+        assert(cc);
+        cc->add(c);
+        cc->finalize();
+        currentSeq->addComponent(move(cc));
+    } else {
+        currentSeq->addComponent(getLiteralComponentClass(c, mode.caseless));
+    }
+}
+
+static
+void addEscaped(ComponentSequence *currentSeq, unichar accum,
+                const ParseMode &mode, const char *err_msg) {
+    if (mode.utf8) {
+        /* leverage ComponentClass to generate the vertices */
+        auto cc = getComponentClass(mode);
+        assert(cc);
+        cc->add(accum);
+        cc->finalize();
+        currentSeq->addComponent(move(cc));
+    } else {
+        if (accum > 255) {
+            throw LocatedParseError(err_msg);
+        }
+        addLiteral(currentSeq, (unsigned char)accum, mode);
+    }
+}
+
+static
+void addEscapedOctal(ComponentSequence *currentSeq, unichar accum,
+                     const ParseMode &mode) {
+    addEscaped(currentSeq, accum, mode, "Octal value is greater than \\377");
+}
+
+static
+void addEscapedHex(ComponentSequence *currentSeq, unichar accum,
+                   const ParseMode &mode) {
+    addEscaped(currentSeq, accum, mode,
+               "Hexadecimal value is greater than \\xFF");
+}
+
+#define SLASH_C_ERROR "\\c must be followed by an ASCII character"
+
+static
+u8 decodeCtrl(u8 raw) {
+    if (raw & 0x80) {
+        throw LocatedParseError(SLASH_C_ERROR);
+    }
+    return mytoupper(raw) ^ 0x40;
+}
+
+static
+unichar readUtf8CodePoint2c(const u8 *ts) {
+    assert(ts[0] >= 0xc0 && ts[0] < 0xe0);
+    assert(ts[1] >= 0x80 && ts[1] < 0xc0);
+
+    unichar val = ts[0] & 0x1f;
+    val <<= 6;
+    val |= ts[1] & 0x3f;
+    DEBUG_PRINTF("utf8 %02hhx %02hhx ->\\x{%x}\n", ts[0],
+                 ts[1], val);
+    return val;
+}
+
+static
+unichar readUtf8CodePoint3c(const u8 *ts) {
+    assert(ts[0] >= 0xe0 && ts[0] < 0xf0);
+    assert(ts[1] >= 0x80 && ts[1] < 0xc0);
+    assert(ts[2] >= 0x80 && ts[2] < 0xc0);
+    unichar val = ts[0] & 0x0f;
+    val <<= 6;
+    val |= ts[1] & 0x3f;
+    val <<= 6;
+    val |= ts[2] & 0x3f;
+    DEBUG_PRINTF("utf8 %02hhx %02hhx %02hhx ->\\x{%x}\n", ts[0],
+                 ts[1], ts[2], val);
+    return val;
+}
+
+static
+unichar readUtf8CodePoint4c(const u8 *ts) {
+    assert(ts[0] >= 0xf0 && ts[0] < 0xf8);
+    assert(ts[1] >= 0x80 && ts[1] < 0xc0);
+    assert(ts[2] >= 0x80 && ts[2] < 0xc0);
+    assert(ts[3] >= 0x80 && ts[3] < 0xc0);
+    unichar val = ts[0] & 0x07;
+    val <<= 6;
+    val |= ts[1] & 0x3f;
+    val <<= 6;
+    val |= ts[2] & 0x3f;
+    val <<= 6;
+    val |= ts[3] & 0x3f;
+    DEBUG_PRINTF("utf8 %02hhx %02hhx %02hhx %02hhx ->\\x{%x}\n", ts[0],
+                 ts[1], ts[2], ts[3], val);
+    return val;
+}
+
+
+#line 1833 "hyperscan-4.1.0/src/parser/Parser.rl"
+
+
+
+#line 280 "hyperscan-build/src/parser/Parser.cpp"
+static const short _regex_actions[] = {
+	0, 1, 0, 1, 1, 1, 2, 1, 
+	3, 1, 4, 1, 7, 1, 8, 1, 
+	9, 1, 10, 1, 11, 1, 12, 1, 
+	13, 1, 15, 1, 16, 1, 17, 1, 
+	18, 1, 19, 1, 20, 1, 21, 1, 
+	22, 1, 23, 1, 24, 1, 25, 1, 
+	26, 1, 27, 1, 28, 1, 29, 1, 
+	30, 1, 31, 1, 32, 1, 33, 1, 
+	34, 1, 35, 1, 36, 1, 37, 1, 
+	38, 1, 39, 1, 40, 1, 41, 1, 
+	42, 1, 43, 1, 44, 1, 45, 1, 
+	46, 1, 47, 1, 48, 1, 49, 1, 
+	50, 1, 51, 1, 52, 1, 53, 1, 
+	54, 1, 55, 1, 56, 1, 57, 1, 
+	58, 1, 59, 1, 60, 1, 61, 1, 
+	62, 1, 63, 1, 64, 1, 65, 1, 
+	66, 1, 67, 1, 68, 1, 69, 1, 
+	70, 1, 71, 1, 72, 1, 73, 1, 
+	74, 1, 75, 1, 76, 1, 77, 1, 
+	78, 1, 79, 1, 80, 1, 81, 1, 
+	82, 1, 83, 1, 84, 1, 85, 1, 
+	86, 1, 87, 1, 88, 1, 89, 1, 
+	90, 1, 91, 1, 92, 1, 93, 1, 
+	94, 1, 95, 1, 96, 1, 97, 1, 
+	98, 1, 99, 1, 100, 1, 101, 1, 
+	102, 1, 103, 1, 104, 1, 105, 1, 
+	106, 1, 107, 1, 108, 1, 109, 1, 
+	110, 1, 111, 1, 112, 1, 113, 1, 
+	114, 1, 115, 1, 116, 1, 117, 1, 
+	118, 1, 119, 1, 120, 1, 121, 1, 
+	122, 1, 123, 1, 124, 1, 125, 1, 
+	126, 1, 127, 1, 128, 1, 129, 1, 
+	130, 1, 131, 1, 132, 1, 133, 1, 
+	134, 1, 135, 1, 136, 1, 137, 1, 
+	138, 1, 139, 1, 140, 1, 141, 1, 
+	142, 1, 143, 1, 144, 1, 145, 1, 
+	146, 1, 147, 1, 148, 1, 149, 1, 
+	150, 1, 151, 1, 152, 1, 153, 1, 
+	154, 1, 155, 1, 156, 1, 157, 1, 
+	158, 1, 159, 1, 160, 1, 161, 1, 
+	162, 1, 163, 1, 164, 1, 165, 1, 
+	166, 1, 167, 1, 168, 1, 169, 1, 
+	170, 1, 171, 1, 172, 1, 173, 1, 
+	174, 1, 175, 1, 176, 1, 177, 1, 
+	178, 1, 179, 1, 180, 1, 181, 1, 
+	182, 1, 183, 1, 184, 1, 185, 1, 
+	186, 1, 187, 1, 188, 1, 189, 1, 
+	190, 1, 191, 1, 192, 1, 193, 1, 
+	194, 1, 195, 1, 196, 1, 197, 1, 
+	198, 1, 199, 1, 200, 1, 201, 1, 
+	202, 1, 203, 1, 204, 1, 205, 1, 
+	206, 1, 207, 1, 208, 1, 209, 1, 
+	210, 1, 211, 1, 212, 1, 213, 1, 
+	214, 1, 215, 1, 216, 1, 217, 1, 
+	218, 1, 219, 1, 220, 1, 221, 1, 
+	222, 1, 223, 1, 224, 1, 225, 1, 
+	226, 1, 227, 1, 228, 1, 229, 1, 
+	230, 1, 231, 1, 232, 1, 233, 1, 
+	234, 1, 235, 1, 236, 1, 239, 1, 
+	241, 1, 242, 1, 243, 1, 244, 1, 
+	245, 1, 246, 1, 247, 1, 248, 1, 
+	249, 1, 250, 1, 251, 1, 252, 1, 
+	253, 1, 254, 1, 255, 1, 256, 1, 
+	257, 1, 258, 1, 259, 1, 260, 1, 
+	261, 1, 262, 1, 263, 1, 264, 1, 
+	265, 1, 266, 1, 267, 1, 268, 1, 
+	269, 1, 270, 1, 271, 1, 272, 1, 
+	273, 1, 274, 1, 275, 1, 276, 1, 
+	277, 1, 278, 1, 279, 1, 280, 1, 
+	281, 1, 282, 1, 283, 1, 284, 1, 
+	285, 1, 286, 1, 287, 1, 288, 1, 
+	289, 1, 290, 1, 294, 1, 295, 1, 
+	296, 1, 297, 1, 298, 1, 299, 1, 
+	300, 1, 301, 1, 302, 1, 303, 1, 
+	304, 1, 305, 1, 306, 1, 307, 1, 
+	308, 1, 309, 1, 310, 1, 311, 1, 
+	312, 1, 313, 1, 314, 1, 315, 1, 
+	316, 1, 317, 1, 318, 1, 319, 1, 
+	320, 1, 321, 1, 322, 1, 323, 1, 
+	324, 1, 325, 1, 329, 1, 330, 1, 
+	331, 1, 332, 1, 333, 1, 334, 1, 
+	335, 1, 336, 1, 337, 1, 339, 1, 
+	340, 1, 341, 1, 342, 1, 343, 1, 
+	344, 1, 345, 1, 346, 1, 347, 1, 
+	348, 1, 349, 1, 350, 1, 351, 1, 
+	352, 1, 353, 1, 354, 1, 355, 1, 
+	356, 1, 357, 1, 358, 1, 359, 1, 
+	360, 1, 361, 1, 362, 1, 363, 1, 
+	364, 1, 365, 1, 366, 1, 367, 1, 
+	368, 1, 369, 1, 370, 1, 371, 1, 
+	372, 1, 373, 1, 374, 1, 375, 1, 
+	376, 1, 377, 1, 378, 1, 379, 1, 
+	380, 1, 381, 1, 382, 1, 383, 1, 
+	384, 1, 385, 1, 386, 1, 387, 1, 
+	388, 1, 389, 1, 390, 1, 391, 1, 
+	392, 1, 393, 1, 394, 1, 395, 1, 
+	396, 1, 397, 1, 398, 1, 399, 1, 
+	400, 1, 401, 1, 402, 1, 403, 1, 
+	404, 1, 405, 1, 406, 1, 407, 1, 
+	408, 1, 409, 1, 410, 1, 411, 1, 
+	412, 1, 413, 1, 414, 1, 415, 1, 
+	416, 1, 417, 1, 418, 1, 419, 1, 
+	420, 1, 421, 1, 422, 1, 423, 2, 
+	3, 0, 2, 4, 5, 2, 5, 1, 
+	2, 9, 10, 2, 9, 237, 2, 9, 
+	238, 2, 9, 326, 2, 10, 1, 2, 
+	10, 327, 2, 10, 328, 2, 11, 240, 
+	2, 11, 338, 2, 12, 240, 2, 12, 
+	338, 2, 13, 240, 2, 13, 338, 2, 
+	14, 362, 2, 14, 363, 2, 25, 0, 
+	2, 25, 3, 2, 25, 6, 2, 25, 
+	14, 3, 25, 5, 293, 3, 25, 10, 
+	292, 3, 25, 14, 15, 4, 25, 9, 
+	291, 10
+};
+
+static const char _regex_cond_offsets[] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 1, 
+	2, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	3, 3, 3, 4, 5, 6, 12, 12, 
+	12, 12, 12, 12, 12, 12, 12, 12, 
+	12, 12, 12, 12, 12, 12, 12, 12, 
+	12, 12, 12, 12, 12, 12, 12, 12, 
+	12, 12, 12, 12, 12, 12, 12, 12, 
+	12, 12, 12, 12, 13, 14, 15, 15, 
+	15, 15, 15, 15, 15, 15, 15, 15, 
+	15, 15, 15, 15, 15, 15, 15, 15, 
+	15, 15, 15, 15, 15, 15, 15, 15, 
+	15, 15, 15, 15, 15, 15, 20, 20, 
+	20, 20, 20, 20, 20, 20, 20, 20, 
+	20, 20, 20, 20, 21, 22, 23, 25, 
+	25, 25, 25, 25, 25, 25
+};
+
+static const char _regex_cond_lengths[] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 1, 1, 
+	1, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 1, 1, 1, 6, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 1, 1, 1, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 5, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 1, 1, 1, 2, 0, 
+	0, 0, 0, 0, 0, 0
+};
+
+static const short _regex_cond_keys[] = {
+	128u, 191u, 128u, 191u, 128u, 191u, 128u, 191u, 
+	128u, 191u, 128u, 191u, 35u, 35u, 128u, 191u, 
+	192u, 223u, 224u, 239u, 240u, 247u, 248u, 255u, 
+	128u, 191u, 128u, 191u, 128u, 191u, 128u, 191u, 
+	192u, 223u, 224u, 239u, 240u, 247u, 248u, 255u, 
+	128u, 191u, 128u, 191u, 128u, 191u, 93u, 93u, 
+	94u, 94u, 0
+};
+
+static const char _regex_cond_spaces[] = {
+	0, 0, 0, 0, 0, 0, 1, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 2, 
+	2, 0
+};
+
+static const short _regex_key_offsets[] = {
+	0, 0, 1, 23, 31, 39, 46, 54, 
+	55, 63, 71, 79, 86, 94, 97, 99, 
+	108, 115, 123, 131, 134, 140, 148, 151, 
+	158, 165, 173, 180, 184, 191, 194, 197, 
+	199, 202, 205, 207, 210, 213, 215, 216, 
+	218, 219, 227, 229, 232, 235, 236, 244, 
+	252, 260, 268, 275, 283, 290, 298, 305, 
+	313, 315, 318, 325, 329, 332, 335, 337, 
+	339, 341, 342, 343, 344, 346, 347, 348, 
+	349, 350, 352, 353, 354, 355, 356, 357, 
+	358, 359, 360, 361, 362, 363, 364, 365, 
+	368, 369, 370, 371, 372, 373, 374, 375, 
+	376, 377, 378, 379, 380, 381, 382, 383, 
+	384, 385, 386, 387, 388, 389, 391, 392, 
+	393, 394, 395, 396, 398, 399, 400, 401, 
+	402, 403, 404, 405, 407, 408, 409, 410, 
+	411, 412, 413, 414, 415, 416, 417, 418, 
+	419, 420, 421, 422, 423, 424, 425, 426, 
+	428, 429, 430, 431, 432, 433, 434, 435, 
+	436, 437, 438, 439, 440, 441, 442, 443, 
+	444, 445, 446, 447, 449, 450, 451, 452, 
+	453, 454, 455, 456, 457, 458, 460, 461, 
+	462, 463, 464, 465, 466, 467, 468, 469, 
+	470, 471, 472, 473, 474, 475, 476, 477, 
+	478, 479, 480, 481, 482, 483, 484, 485, 
+	486, 487, 488, 489, 490, 491, 492, 493, 
+	494, 495, 496, 497, 498, 499, 500, 501, 
+	502, 503, 504, 505, 506, 507, 508, 509, 
+	510, 511, 512, 513, 514, 515, 516, 518, 
+	519, 520, 521, 522, 523, 524, 525, 526, 
+	527, 528, 529, 530, 531, 532, 533, 534, 
+	535, 536, 537, 538, 539, 540, 541, 542, 
+	543, 544, 545, 546, 547, 548, 549, 550, 
+	551, 552, 553, 554, 555, 556, 557, 558, 
+	560, 561, 562, 563, 564, 565, 566, 567, 
+	568, 569, 570, 571, 572, 573, 574, 575, 
+	576, 577, 578, 579, 581, 582, 583, 584, 
+	585, 586, 587, 588, 589, 590, 591, 592, 
+	593, 594, 595, 596, 600, 601, 602, 603, 
+	604, 605, 606, 607, 608, 609, 610, 611, 
+	612, 613, 614, 615, 616, 617, 619, 620, 
+	621, 622, 623, 624, 625, 626, 627, 628, 
+	630, 631, 632, 633, 634, 635, 636, 639, 
+	640, 641, 642, 643, 644, 645, 646, 647, 
+	649, 650, 651, 652, 653, 654, 655, 657, 
+	658, 659, 660, 661, 662, 663, 664, 665, 
+	666, 667, 668, 669, 670, 671, 672, 673, 
+	674, 675, 676, 677, 678, 679, 680, 681, 
+	682, 683, 684, 685, 686, 687, 688, 689, 
+	690, 691, 692, 693, 694, 695, 696, 697, 
+	698, 699, 700, 701, 703, 704, 705, 706, 
+	707, 708, 709, 713, 714, 715, 716, 717, 
+	718, 719, 720, 721, 722, 723, 724, 725, 
+	726, 727, 728, 729, 730, 731, 732, 733, 
+	734, 735, 736, 737, 738, 739, 740, 741, 
+	742, 743, 744, 745, 746, 747, 748, 749, 
+	751, 752, 753, 754, 755, 756, 757, 758, 
+	759, 760, 761, 762, 763, 764, 765, 766, 
+	767, 768, 769, 770, 772, 773, 774, 775, 
+	776, 777, 778, 779, 780, 781, 782, 783, 
+	784, 785, 786, 787, 788, 789, 790, 791, 
+	792, 793, 794, 795, 796, 797, 798, 799, 
+	800, 801, 802, 804, 805, 806, 807, 808, 
+	809, 810, 811, 812, 813, 814, 815, 816, 
+	819, 821, 822, 823, 824, 825, 826, 827, 
+	828, 829, 832, 833, 834, 835, 836, 837, 
+	838, 839, 840, 841, 842, 843, 844, 845, 
+	846, 848, 849, 850, 852, 853, 854, 855, 
+	856, 857, 858, 859, 860, 861, 862, 863, 
+	864, 865, 866, 867, 868, 869, 870, 871, 
+	872, 873, 874, 875, 876, 879, 882, 884, 
+	899, 902, 905, 907, 921, 926, 931, 935, 
+	939, 942, 945, 949, 953, 956, 959, 963, 
+	967, 971, 974, 977, 981, 985, 989, 993, 
+	996, 999, 1003, 1007, 1011, 1015, 1018, 1021, 
+	1025, 1029, 1033, 1037, 1040, 1043, 1047, 1051, 
+	1055, 1059, 1062, 1065, 1069, 1073, 1077, 1081, 
+	1084, 1087, 1092, 1096, 1100, 1104, 1107, 1110, 
+	1114, 1118, 1122, 1125, 1128, 1132, 1136, 1140, 
+	1144, 1147, 1150, 1154, 1158, 1162, 1166, 1169, 
+	1172, 1176, 1180, 1184, 1187, 1190, 1194, 1198, 
+	1202, 1206, 1210, 1213, 1216, 1221, 1226, 1230, 
+	1234, 1237, 1240, 1244, 1248, 1251, 1254, 1258, 
+	1262, 1266, 1269, 1272, 1276, 1280, 1284, 1288, 
+	1291, 1294, 1298, 1302, 1306, 1310, 1313, 1316, 
+	1320, 1324, 1328, 1332, 1335, 1338, 1342, 1346, 
+	1350, 1354, 1357, 1360, 1364, 1368, 1372, 1376, 
+	1379, 1382, 1387, 1391, 1395, 1399, 1402, 1405, 
+	1409, 1413, 1417, 1420, 1423, 1427, 1431, 1435, 
+	1439, 1442, 1445, 1449, 1453, 1457, 1461, 1464, 
+	1467, 1471, 1475, 1479, 1482, 1485, 1489, 1493, 
+	1497, 1501, 1505, 1508, 1511, 1514, 1517, 1519, 
+	1521, 1524, 1531, 1533, 1535, 1537, 1573, 1575, 
+	1582, 1589, 1603, 1605, 1611, 1614, 1623, 1624, 
+	1627, 1630, 1637, 1639, 1641, 1643, 1646, 1691, 
+	1693, 1695, 1699, 1703, 1705, 1706, 1706, 1712, 
+	1714, 1716, 1718, 1720, 1723, 1724, 1725, 1732, 
+	1738, 1744, 1746, 1748, 1750, 1752, 1754, 1755, 
+	1757, 1780, 1783, 1788, 1797, 1799, 1800, 1802, 
+	1807, 1810, 1812, 1814, 1815, 1817, 1827, 1833, 
+	1834, 1839, 1843, 1851, 1853, 1862, 1866, 1867, 
+	1868, 1872, 1873, 1876, 1876, 1883, 1901, 1904, 
+	1943, 1945, 1947, 1949, 1951, 1952, 1952, 1953, 
+	1954, 1961, 1967, 1973, 1975, 1977, 1979, 1988, 
+	1990, 1991, 1992, 1993, 1994, 1995
+};
+
+static const short _regex_trans_keys[] = {
+	41u, 33u, 35u, 38u, 39u, 40u, 41u, 43u, 
+	45u, 58u, 60u, 61u, 62u, 63u, 67u, 80u, 
+	105u, 109u, 115u, 120u, 123u, 48u, 57u, 41u, 
+	95u, 48u, 57u, 65u, 90u, 97u, 122u, 39u, 
+	95u, 48u, 57u, 65u, 90u, 97u, 122u, 95u, 
+	48u, 57u, 65u, 90u, 97u, 122u, 39u, 95u, 
+	48u, 57u, 65u, 90u, 97u, 122u, 41u, 41u, 
+	95u, 48u, 57u, 65u, 90u, 97u, 122u, 41u, 
+	95u, 48u, 57u, 65u, 90u, 97u, 122u, 41u, 
+	95u, 48u, 57u, 65u, 90u, 97u, 122u, 95u, 
+	48u, 57u, 65u, 90u, 97u, 122u, 62u, 95u, 
+	48u, 57u, 65u, 90u, 97u, 122u, 33u, 60u, 
+	61u, 33u, 61u, 38u, 41u, 95u, 48u, 57u, 
+	65u, 90u, 97u, 122u, 95u, 48u, 57u, 65u, 
+	90u, 97u, 122u, 41u, 95u, 48u, 57u, 65u, 
+	90u, 97u, 122u, 41u, 95u, 48u, 57u, 65u, 
+	90u, 97u, 122u, 41u, 48u, 57u, 41u, 58u, 
+	105u, 109u, 115u, 120u, 62u, 95u, 48u, 57u, 
+	65u, 90u, 97u, 122u, 41u, 48u, 57u, 95u, 
+	48u, 57u, 65u, 90u, 97u, 122u, 95u, 48u, 
+	57u, 65u, 90u, 97u, 122u, 41u, 95u, 48u, 
+	57u, 65u, 90u, 97u, 122u, 95u, 48u, 57u, 
+	65u, 90u, 97u, 122u, 105u, 109u, 115u, 120u, 
+	41u, 45u, 58u, 105u, 109u, 115u, 120u, 46u, 
+	92u, 93u, 46u, 92u, 93u, 46u, 92u, 58u, 
+	92u, 93u, 58u, 92u, 93u, 58u, 92u, 61u, 
+	92u, 93u, 61u, 92u, 93u, 61u, 92u, 39u, 
+	48u, 57u, 62u, 45u, 95u, 48u, 57u, 65u, 
+	90u, 97u, 122u, 48u, 57u, 125u, 48u, 57u, 
+	125u, 48u, 57u, 125u, 95u, 125u, 48u, 57u, 
+	65u, 90u, 97u, 122u, 95u, 125u, 48u, 57u, 
+	65u, 90u, 97u, 122u, 95u, 125u, 48u, 57u, 
+	65u, 90u, 97u, 122u, 95u, 125u, 48u, 57u, 
+	65u, 90u, 97u, 122u, 95u, 48u, 57u, 65u, 
+	90u, 97u, 122u, 39u, 95u, 48u, 57u, 65u, 
+	90u, 97u, 122u, 95u, 48u, 57u, 65u, 90u, 
+	97u, 122u, 62u, 95u, 48u, 57u, 65u, 90u, 
+	97u, 122u, 95u, 48u, 57u, 65u, 90u, 97u, 
+	122u, 95u, 125u, 48u, 57u, 65u, 90u, 97u, 
+	122u, 48u, 55u, 125u, 48u, 55u, 125u, 48u, 
+	57u, 65u, 70u, 97u, 102u, 44u, 125u, 48u, 
+	57u, 125u, 48u, 57u, 125u, 48u, 57u, 640u, 
+	703u, 640u, 703u, 640u, 703u, 80u, 41u, 70u, 
+	49u, 56u, 54u, 41u, 41u, 121u, 97u, 109u, 
+	98u, 105u, 99u, 101u, 110u, 105u, 97u, 110u, 
+	101u, 115u, 116u, 97u, 110u, 108u, 109u, 116u, 
+	105u, 110u, 101u, 115u, 101u, 117u, 109u, 97u, 
+	107u, 110u, 103u, 97u, 108u, 105u, 112u, 111u, 
+	109u, 111u, 102u, 111u, 97u, 104u, 105u, 109u, 
+	105u, 108u, 108u, 101u, 103u, 104u, 105u, 110u, 
+	101u, 115u, 101u, 105u, 100u, 110u, 114u, 97u, 
+	100u, 105u, 97u, 110u, 95u, 65u, 98u, 111u, 
+	114u, 105u, 103u, 105u, 110u, 97u, 108u, 105u, 
+	97u, 110u, 97u, 101u, 109u, 114u, 111u, 107u, 
+	101u, 101u, 109u, 111u, 110u, 116u, 105u, 99u, 
+	110u, 101u, 105u, 102u, 111u, 114u, 109u, 112u, 
+	114u, 114u, 105u, 111u, 116u, 105u, 108u, 108u, 
+	105u, 99u, 115u, 118u, 101u, 114u, 101u, 116u, 
+	97u, 110u, 97u, 103u, 97u, 114u, 105u, 121u, 
+	112u, 116u, 105u, 97u, 110u, 95u, 72u, 105u, 
+	101u, 114u, 111u, 103u, 108u, 121u, 112u, 104u, 
+	115u, 104u, 105u, 111u, 112u, 105u, 99u, 111u, 
+	114u, 103u, 105u, 97u, 110u, 97u, 103u, 111u, 
+	108u, 105u, 116u, 105u, 99u, 116u, 104u, 105u, 
+	99u, 101u, 101u, 107u, 106u, 114u, 97u, 114u, 
+	97u, 116u, 105u, 109u, 117u, 107u, 104u, 105u, 
+	110u, 117u, 108u, 110u, 111u, 111u, 98u, 114u, 
+	101u, 119u, 114u, 97u, 103u, 97u, 110u, 97u, 
+	112u, 101u, 114u, 105u, 97u, 108u, 95u, 65u, 
+	114u, 97u, 109u, 97u, 105u, 99u, 104u, 115u, 
+	101u, 114u, 105u, 116u, 101u, 100u, 99u, 114u, 
+	105u, 112u, 116u, 105u, 111u, 110u, 97u, 108u, 
+	95u, 80u, 97u, 104u, 114u, 108u, 97u, 118u, 
+	105u, 116u, 104u, 105u, 97u, 110u, 118u, 97u, 
+	110u, 101u, 115u, 101u, 105u, 110u, 116u, 121u, 
+	116u, 104u, 105u, 110u, 97u, 100u, 97u, 97u, 
+	107u, 97u, 110u, 97u, 97u, 104u, 95u, 76u, 
+	105u, 97u, 109u, 114u, 111u, 115u, 104u, 116u, 
+	104u, 105u, 101u, 114u, 111u, 116u, 105u, 110u, 
+	112u, 99u, 104u, 97u, 109u, 110u, 115u, 98u, 
+	117u, 101u, 97u, 114u, 95u, 66u, 117u, 99u, 
+	100u, 105u, 97u, 110u, 105u, 97u, 110u, 108u, 
+	110u, 97u, 121u, 97u, 108u, 97u, 109u, 100u, 
+	97u, 105u, 99u, 116u, 101u, 105u, 95u, 77u, 
+	97u, 121u, 101u, 107u, 110u, 103u, 111u, 108u, 
+	105u, 97u, 110u, 97u, 110u, 109u, 97u, 114u, 
+	119u, 95u, 84u, 97u, 105u, 95u, 76u, 117u, 
+	101u, 111u, 104u, 97u, 109u, 95u, 100u, 67u, 
+	104u, 105u, 107u, 105u, 95u, 73u, 80u, 83u, 
+	84u, 116u, 97u, 108u, 105u, 99u, 101u, 114u, 
+	115u, 105u, 97u, 110u, 111u, 117u, 116u, 104u, 
+	95u, 65u, 114u, 97u, 98u, 105u, 97u, 110u, 
+	117u, 114u, 107u, 105u, 99u, 105u, 121u, 97u, 
+	109u, 97u, 110u, 121u, 97u, 97u, 111u, 103u, 
+	115u, 95u, 80u, 97u, 101u, 110u, 105u, 99u, 
+	105u, 97u, 110u, 106u, 97u, 110u, 103u, 110u, 
+	105u, 99u, 109u, 117u, 97u, 114u, 105u, 116u, 
+	97u, 110u, 114u, 97u, 115u, 104u, 116u, 114u, 
+	97u, 97u, 118u, 105u, 97u, 110u, 110u, 104u, 
+	97u, 108u, 97u, 110u, 100u, 97u, 110u, 101u, 
+	115u, 101u, 108u, 114u, 111u, 116u, 105u, 95u, 
+	78u, 97u, 103u, 114u, 105u, 105u, 97u, 99u, 
+	103u, 105u, 109u, 97u, 98u, 108u, 111u, 103u, 
+	97u, 110u, 119u, 97u, 95u, 76u, 84u, 86u, 
+	101u, 104u, 97u, 109u, 105u, 101u, 116u, 105u, 
+	108u, 108u, 117u, 103u, 117u, 97u, 97u, 105u, 
+	110u, 97u, 98u, 102u, 101u, 116u, 97u, 110u, 
+	105u, 110u, 97u, 103u, 104u, 97u, 114u, 105u, 
+	116u, 105u, 99u, 105u, 110u, 115u, 112u, 100u, 
+	123u, 94u, 125u, 94u, 46u, 92u, 93u, 46u, 
+	92u, 93u, 46u, 92u, 58u, 92u, 93u, 94u, 
+	97u, 98u, 99u, 100u, 103u, 108u, 112u, 115u, 
+	117u, 119u, 120u, 58u, 92u, 93u, 58u, 92u, 
+	93u, 58u, 92u, 58u, 92u, 93u, 97u, 98u, 
+	99u, 100u, 103u, 108u, 112u, 115u, 117u, 119u, 
+	120u, 58u, 92u, 93u, 108u, 115u, 58u, 92u, 
+	93u, 110u, 112u, 58u, 92u, 93u, 117u, 58u, 
+	92u, 93u, 109u, 58u, 92u, 93u, 58u, 92u, 
+	93u, 58u, 92u, 93u, 104u, 58u, 92u, 93u, 
+	97u, 58u, 92u, 93u, 58u, 92u, 93u, 58u, 
+	92u, 93u, 99u, 58u, 92u, 93u, 105u, 58u, 
+	92u, 93u, 105u, 58u, 92u, 93u, 58u, 92u, 
+	93u, 58u, 92u, 93u, 108u, 58u, 92u, 93u, 
+	97u, 58u, 92u, 93u, 110u, 58u, 92u, 93u, 
+	107u, 58u, 92u, 93u, 58u, 92u, 93u, 58u, 
+	92u, 93u, 110u, 58u, 92u, 93u, 116u, 58u, 
+	92u, 93u, 114u, 58u, 92u, 93u, 108u, 58u, 
+	92u, 93u, 58u, 92u, 93u, 58u, 92u, 93u, 
+	105u, 58u, 92u, 93u, 103u, 58u, 92u, 93u, 
+	105u, 58u, 92u, 93u, 116u, 58u, 92u, 93u, 
+	58u, 92u, 93u, 58u, 92u, 93u, 114u, 58u, 
+	92u, 93u, 97u, 58u, 92u, 93u, 112u, 58u, 
+	92u, 93u, 104u, 58u, 92u, 93u, 58u, 92u, 
+	93u, 58u, 92u, 93u, 111u, 58u, 92u, 93u, 
+	119u, 58u, 92u, 93u, 101u, 58u, 92u, 93u, 
+	114u, 58u, 92u, 93u, 58u, 92u, 93u, 58u, 
+	92u, 93u, 114u, 117u, 58u, 92u, 93u, 105u, 
+	58u, 92u, 93u, 110u, 58u, 92u, 93u, 116u, 
+	58u, 92u, 93u, 58u, 92u, 93u, 58u, 92u, 
+	93u, 110u, 58u, 92u, 93u, 99u, 58u, 92u, 
+	93u, 116u, 58u, 92u, 93u, 58u, 92u, 93u, 
+	58u, 92u, 93u, 112u, 58u, 92u, 93u, 97u, 
+	58u, 92u, 93u, 99u, 58u, 92u, 93u, 101u, 
+	58u, 92u, 93u, 58u, 92u, 93u, 58u, 92u, 
+	93u, 112u, 58u, 92u, 93u, 112u, 58u, 92u, 
+	93u, 101u, 58u, 92u, 93u, 114u, 58u, 92u, 
+	93u, 58u, 92u, 93u, 58u, 92u, 93u, 111u, 
+	58u, 92u, 93u, 114u, 58u, 92u, 93u, 100u, 
+	58u, 92u, 93u, 58u, 92u, 93u, 58u, 92u, 
+	93u, 100u, 58u, 92u, 93u, 105u, 58u, 92u, 
+	93u, 103u, 58u, 92u, 93u, 105u, 58u, 92u, 
+	93u, 116u, 58u, 92u, 93u, 58u, 92u, 93u, 
+	58u, 92u, 93u, 108u, 115u, 58u, 92u, 93u, 
+	110u, 112u, 58u, 92u, 93u, 117u, 58u, 92u, 
+	93u, 109u, 58u, 92u, 93u, 58u, 92u, 93u, 
+	58u, 92u, 93u, 104u, 58u, 92u, 93u, 97u, 
+	58u, 92u, 93u, 58u, 92u, 93u, 58u, 92u, 
+	93u, 99u, 58u, 92u, 93u, 105u, 58u, 92u, 
+	93u, 105u, 58u, 92u, 93u, 58u, 92u, 93u, 
+	58u, 92u, 93u, 108u, 58u, 92u, 93u, 97u, 
+	58u, 92u, 93u, 110u, 58u, 92u, 93u, 107u, 
+	58u, 92u, 93u, 58u, 92u, 93u, 58u, 92u, 
+	93u, 110u, 58u, 92u, 93u, 116u, 58u, 92u, 
+	93u, 114u, 58u, 92u, 93u, 108u, 58u, 92u, 
+	93u, 58u, 92u, 93u, 58u, 92u, 93u, 105u, 
+	58u, 92u, 93u, 103u, 58u, 92u, 93u, 105u, 
+	58u, 92u, 93u, 116u, 58u, 92u, 93u, 58u, 
+	92u, 93u, 58u, 92u, 93u, 114u, 58u, 92u, 
+	93u, 97u, 58u, 92u, 93u, 112u, 58u, 92u, 
+	93u, 104u, 58u, 92u, 93u, 58u, 92u, 93u, 
+	58u, 92u, 93u, 111u, 58u, 92u, 93u, 119u, 
+	58u, 92u, 93u, 101u, 58u, 92u, 93u, 114u, 
+	58u, 92u, 93u, 58u, 92u, 93u, 58u, 92u, 
+	93u, 114u, 117u, 58u, 92u, 93u, 105u, 58u, 
+	92u, 93u, 110u, 58u, 92u, 93u, 116u, 58u, 
+	92u, 93u, 58u, 92u, 93u, 58u, 92u, 93u, 
+	110u, 58u, 92u, 93u, 99u, 58u, 92u, 93u, 
+	116u, 58u, 92u, 93u, 58u, 92u, 93u, 58u, 
+	92u, 93u, 112u, 58u, 92u, 93u, 97u, 58u, 
+	92u, 93u, 99u, 58u, 92u, 93u, 101u, 58u, 
+	92u, 93u, 58u, 92u, 93u, 58u, 92u, 93u, 
+	112u, 58u, 92u, 93u, 112u, 58u, 92u, 93u, 
+	101u, 58u, 92u, 93u, 114u, 58u, 92u, 93u, 
+	58u, 92u, 93u, 58u, 92u, 93u, 111u, 58u, 
+	92u, 93u, 114u, 58u, 92u, 93u, 100u, 58u, 
+	92u, 93u, 58u, 92u, 93u, 58u, 92u, 93u, 
+	100u, 58u, 92u, 93u, 105u, 58u, 92u, 93u, 
+	103u, 58u, 92u, 93u, 105u, 58u, 92u, 93u, 
+	116u, 58u, 92u, 93u, 58u, 92u, 93u, 61u, 
+	92u, 93u, 61u, 92u, 93u, 61u, 92u, 48u, 
+	55u, 125u, 48u, 55u, 125u, 48u, 57u, 65u, 
+	70u, 97u, 102u, 640u, 703u, 640u, 703u, 640u, 
+	703u, 0u, 32u, 36u, 40u, 41u, 42u, 43u, 
+	46u, 63u, 91u, 92u, 94u, 123u, 124u, 1315u, 
+	1571u, 1u, 8u, 9u, 13u, 14u, 34u, 37u, 
+	127u, 384u, 511u, 640u, 703u, 704u, 735u, 736u, 
+	751u, 752u, 759u, 760u, 767u, 42u, 63u, 95u, 
+	48u, 57u, 65u, 90u, 97u, 122u, 95u, 48u, 
+	57u, 65u, 90u, 97u, 122u, 39u, 48u, 60u, 
+	63u, 82u, 95u, 49u, 55u, 56u, 57u, 65u, 
+	90u, 97u, 122u, 48u, 57u, 105u, 109u, 115u, 
+	120u, 48u, 57u, 41u, 48u, 57u, 33u, 61u, 
+	95u, 48u, 57u, 65u, 90u, 97u, 122u, 123u, 
+	41u, 48u, 57u, 60u, 61u, 62u, 41u, 45u, 
+	58u, 105u, 109u, 115u, 120u, 43u, 63u, 43u, 
+	63u, 43u, 63u, 46u, 58u, 61u, 48u, 65u, 
+	66u, 67u, 68u, 69u, 71u, 72u, 75u, 76u, 
+	78u, 80u, 81u, 82u, 83u, 85u, 86u, 87u, 
+	88u, 90u, 97u, 98u, 99u, 100u, 101u, 102u, 
+	103u, 104u, 107u, 108u, 110u, 111u, 112u, 114u, 
+	115u, 116u, 117u, 118u, 119u, 120u, 122u, 49u, 
+	55u, 56u, 57u, 48u, 55u, 48u, 55u, 48u, 
+	55u, 56u, 57u, 48u, 55u, 56u, 57u, 48u, 
+	57u, 123u, 39u, 45u, 60u, 123u, 48u, 57u, 
+	48u, 57u, 48u, 57u, 48u, 57u, 48u, 57u, 
+	39u, 60u, 123u, 123u, 123u, 123u, 48u, 57u, 
+	65u, 70u, 97u, 102u, 48u, 57u, 65u, 70u, 
+	97u, 102u, 48u, 57u, 65u, 70u, 97u, 102u, 
+	48u, 57u, 43u, 63u, 640u, 703u, 640u, 703u, 
+	640u, 703u, 85u, 67u, 84u, 65u, 66u, 67u, 
+	68u, 69u, 71u, 72u, 73u, 74u, 75u, 76u, 
+	77u, 78u, 79u, 80u, 82u, 83u, 84u, 85u, 
+	86u, 88u, 89u, 90u, 110u, 114u, 118u, 97u, 
+	101u, 111u, 114u, 117u, 97u, 99u, 102u, 104u, 
+	110u, 111u, 115u, 117u, 121u, 109u, 112u, 101u, 
+	103u, 116u, 101u, 108u, 111u, 114u, 117u, 97u, 
+	101u, 105u, 103u, 117u, 109u, 110u, 97u, 97u, 
+	104u, 38u, 97u, 101u, 105u, 108u, 109u, 111u, 
+	116u, 117u, 121u, 97u, 99u, 101u, 110u, 111u, 
+	121u, 101u, 100u, 101u, 107u, 108u, 111u, 103u, 
+	108u, 114u, 115u, 99u, 100u, 101u, 102u, 104u, 
+	105u, 111u, 115u, 101u, 117u, 97u, 99u, 104u, 
+	105u, 107u, 109u, 111u, 117u, 121u, 97u, 101u, 
+	104u, 105u, 103u, 97u, 97u, 112u, 115u, 119u, 
+	105u, 108u, 112u, 115u, 67u, 76u, 77u, 78u, 
+	80u, 83u, 90u, 45u, 91u, 92u, 93u, 0u, 
+	127u, 384u, 511u, 640u, 703u, 704u, 735u, 736u, 
+	751u, 752u, 759u, 760u, 767u, 46u, 58u, 61u, 
+	48u, 68u, 69u, 72u, 76u, 78u, 80u, 81u, 
+	83u, 85u, 86u, 87u, 97u, 98u, 99u, 100u, 
+	101u, 102u, 103u, 104u, 108u, 110u, 111u, 112u, 
+	114u, 115u, 116u, 117u, 118u, 119u, 120u, 49u, 
+	55u, 56u, 57u, 65u, 90u, 105u, 122u, 48u, 
+	55u, 48u, 55u, 48u, 55u, 48u, 55u, 123u, 
+	123u, 123u, 123u, 48u, 57u, 65u, 70u, 97u, 
+	102u, 48u, 57u, 65u, 70u, 97u, 102u, 48u, 
+	57u, 65u, 70u, 97u, 102u, 640u, 703u, 640u, 
+	703u, 640u, 703u, 92u, 1117u, 1118u, 0u, 91u, 
+	95u, 255u, 861u, 862u, 69u, 81u, 92u, 69u, 
+	92u, 69u, 41u, 10u, 0
+};
+
+static const char _regex_single_lengths[] = {
+	0, 1, 20, 2, 2, 1, 2, 1, 
+	2, 2, 2, 1, 2, 3, 2, 3, 
+	1, 2, 2, 1, 6, 2, 1, 1, 
+	1, 2, 1, 4, 7, 3, 3, 2, 
+	3, 3, 2, 3, 3, 2, 1, 0, 
+	1, 2, 0, 1, 1, 1, 2, 2, 
+	2, 2, 1, 2, 1, 2, 1, 2, 
+	0, 1, 1, 2, 1, 1, 0, 0, 
+	0, 1, 1, 1, 2, 1, 1, 1, 
+	1, 2, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 3, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 2, 1, 1, 
+	1, 1, 1, 2, 1, 1, 1, 1, 
+	1, 1, 1, 2, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 2, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 2, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 2, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 2, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 2, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 2, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 4, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 2, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 2, 
+	1, 1, 1, 1, 1, 1, 3, 1, 
+	1, 1, 1, 1, 1, 1, 1, 2, 
+	1, 1, 1, 1, 1, 1, 2, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 2, 1, 1, 1, 1, 
+	1, 1, 4, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 2, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 2, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 2, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 3, 
+	2, 1, 1, 1, 1, 1, 1, 1, 
+	1, 3, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	2, 1, 1, 2, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 3, 3, 2, 15, 
+	3, 3, 2, 14, 5, 5, 4, 4, 
+	3, 3, 4, 4, 3, 3, 4, 4, 
+	4, 3, 3, 4, 4, 4, 4, 3, 
+	3, 4, 4, 4, 4, 3, 3, 4, 
+	4, 4, 4, 3, 3, 4, 4, 4, 
+	4, 3, 3, 4, 4, 4, 4, 3, 
+	3, 5, 4, 4, 4, 3, 3, 4, 
+	4, 4, 3, 3, 4, 4, 4, 4, 
+	3, 3, 4, 4, 4, 4, 3, 3, 
+	4, 4, 4, 3, 3, 4, 4, 4, 
+	4, 4, 3, 3, 5, 5, 4, 4, 
+	3, 3, 4, 4, 3, 3, 4, 4, 
+	4, 3, 3, 4, 4, 4, 4, 3, 
+	3, 4, 4, 4, 4, 3, 3, 4, 
+	4, 4, 4, 3, 3, 4, 4, 4, 
+	4, 3, 3, 4, 4, 4, 4, 3, 
+	3, 5, 4, 4, 4, 3, 3, 4, 
+	4, 4, 3, 3, 4, 4, 4, 4, 
+	3, 3, 4, 4, 4, 4, 3, 3, 
+	4, 4, 4, 3, 3, 4, 4, 4, 
+	4, 4, 3, 3, 3, 3, 2, 0, 
+	1, 1, 0, 0, 0, 16, 2, 1, 
+	1, 6, 0, 4, 1, 3, 1, 1, 
+	3, 7, 2, 2, 2, 3, 41, 0, 
+	0, 0, 0, 0, 1, 0, 4, 0, 
+	0, 0, 0, 3, 1, 1, 1, 0, 
+	0, 0, 2, 0, 0, 0, 1, 2, 
+	23, 3, 5, 9, 2, 1, 2, 5, 
+	3, 2, 2, 1, 2, 10, 6, 1, 
+	5, 4, 8, 2, 9, 4, 1, 1, 
+	4, 1, 3, 0, 7, 4, 3, 31, 
+	0, 0, 0, 0, 1, 0, 1, 1, 
+	1, 0, 0, 0, 0, 0, 3, 2, 
+	1, 1, 1, 1, 1, 1
+};
+
+static const char _regex_range_lengths[] = {
+	0, 0, 1, 3, 3, 3, 3, 0, 
+	3, 3, 3, 3, 3, 0, 0, 3, 
+	3, 3, 3, 1, 0, 3, 1, 3, 
+	3, 3, 3, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 1, 
+	0, 3, 1, 1, 1, 0, 3, 3, 
+	3, 3, 3, 3, 3, 3, 3, 3, 
+	1, 1, 3, 1, 1, 1, 1, 1, 
+	1, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 1, 
+	1, 3, 1, 1, 1, 10, 0, 3, 
+	3, 4, 1, 1, 1, 3, 0, 1, 
+	0, 0, 0, 0, 0, 0, 2, 1, 
+	1, 2, 2, 1, 0, 0, 1, 1, 
+	1, 1, 1, 0, 0, 0, 3, 3, 
+	3, 1, 0, 1, 1, 1, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 7, 0, 4, 
+	1, 1, 1, 1, 0, 0, 0, 0, 
+	3, 3, 3, 1, 1, 1, 3, 0, 
+	0, 0, 0, 0, 0, 0
+};
+
+static const short _regex_index_offsets[] = {
+	0, 0, 2, 24, 30, 36, 41, 47, 
+	49, 55, 61, 67, 72, 78, 82, 85, 
+	92, 97, 103, 109, 112, 119, 125, 128, 
+	133, 138, 144, 149, 154, 162, 166, 170, 
+	173, 177, 181, 184, 188, 192, 195, 197, 
+	199, 201, 207, 209, 212, 215, 217, 223, 
+	229, 235, 241, 246, 252, 257, 263, 268, 
+	274, 276, 279, 284, 288, 291, 294, 296, 
+	298, 300, 302, 304, 306, 309, 311, 313, 
+	315, 317, 320, 322, 324, 326, 328, 330, 
+	332, 334, 336, 338, 340, 342, 344, 346, 
+	350, 352, 354, 356, 358, 360, 362, 364, 
+	366, 368, 370, 372, 374, 376, 378, 380, 
+	382, 384, 386, 388, 390, 392, 395, 397, 
+	399, 401, 403, 405, 408, 410, 412, 414, 
+	416, 418, 420, 422, 425, 427, 429, 431, 
+	433, 435, 437, 439, 441, 443, 445, 447, 
+	449, 451, 453, 455, 457, 459, 461, 463, 
+	466, 468, 470, 472, 474, 476, 478, 480, 
+	482, 484, 486, 488, 490, 492, 494, 496, 
+	498, 500, 502, 504, 507, 509, 511, 513, 
+	515, 517, 519, 521, 523, 525, 528, 530, 
+	532, 534, 536, 538, 540, 542, 544, 546, 
+	548, 550, 552, 554, 556, 558, 560, 562, 
+	564, 566, 568, 570, 572, 574, 576, 578, 
+	580, 582, 584, 586, 588, 590, 592, 594, 
+	596, 598, 600, 602, 604, 606, 608, 610, 
+	612, 614, 616, 618, 620, 622, 624, 626, 
+	628, 630, 632, 634, 636, 638, 640, 643, 
+	645, 647, 649, 651, 653, 655, 657, 659, 
+	661, 663, 665, 667, 669, 671, 673, 675, 
+	677, 679, 681, 683, 685, 687, 689, 691, 
+	693, 695, 697, 699, 701, 703, 705, 707, 
+	709, 711, 713, 715, 717, 719, 721, 723, 
+	726, 728, 730, 732, 734, 736, 738, 740, 
+	742, 744, 746, 748, 750, 752, 754, 756, 
+	758, 760, 762, 764, 767, 769, 771, 773, 
+	775, 777, 779, 781, 783, 785, 787, 789, 
+	791, 793, 795, 797, 802, 804, 806, 808, 
+	810, 812, 814, 816, 818, 820, 822, 824, 
+	826, 828, 830, 832, 834, 836, 839, 841, 
+	843, 845, 847, 849, 851, 853, 855, 857, 
+	860, 862, 864, 866, 868, 870, 872, 876, 
+	878, 880, 882, 884, 886, 888, 890, 892, 
+	895, 897, 899, 901, 903, 905, 907, 910, 
+	912, 914, 916, 918, 920, 922, 924, 926, 
+	928, 930, 932, 934, 936, 938, 940, 942, 
+	944, 946, 948, 950, 952, 954, 956, 958, 
+	960, 962, 964, 966, 968, 970, 972, 974, 
+	976, 978, 980, 982, 984, 986, 988, 990, 
+	992, 994, 996, 998, 1001, 1003, 1005, 1007, 
+	1009, 1011, 1013, 1018, 1020, 1022, 1024, 1026, 
+	1028, 1030, 1032, 1034, 1036, 1038, 1040, 1042, 
+	1044, 1046, 1048, 1050, 1052, 1054, 1056, 1058, 
+	1060, 1062, 1064, 1066, 1068, 1070, 1072, 1074, 
+	1076, 1078, 1080, 1082, 1084, 1086, 1088, 1090, 
+	1093, 1095, 1097, 1099, 1101, 1103, 1105, 1107, 
+	1109, 1111, 1113, 1115, 1117, 1119, 1121, 1123, 
+	1125, 1127, 1129, 1131, 1134, 1136, 1138, 1140, 
+	1142, 1144, 1146, 1148, 1150, 1152, 1154, 1156, 
+	1158, 1160, 1162, 1164, 1166, 1168, 1170, 1172, 
+	1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 
+	1190, 1192, 1194, 1197, 1199, 1201, 1203, 1205, 
+	1207, 1209, 1211, 1213, 1215, 1217, 1219, 1221, 
+	1225, 1228, 1230, 1232, 1234, 1236, 1238, 1240, 
+	1242, 1244, 1248, 1250, 1252, 1254, 1256, 1258, 
+	1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 
+	1276, 1279, 1281, 1283, 1286, 1288, 1290, 1292, 
+	1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 
+	1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 
+	1326, 1328, 1330, 1332, 1334, 1338, 1342, 1345, 
+	1361, 1365, 1369, 1372, 1387, 1393, 1399, 1404, 
+	1409, 1413, 1417, 1422, 1427, 1431, 1435, 1440, 
+	1445, 1450, 1454, 1458, 1463, 1468, 1473, 1478, 
+	1482, 1486, 1491, 1496, 1501, 1506, 1510, 1514, 
+	1519, 1524, 1529, 1534, 1538, 1542, 1547, 1552, 
+	1557, 1562, 1566, 1570, 1575, 1580, 1585, 1590, 
+	1594, 1598, 1604, 1609, 1614, 1619, 1623, 1627, 
+	1632, 1637, 1642, 1646, 1650, 1655, 1660, 1665, 
+	1670, 1674, 1678, 1683, 1688, 1693, 1698, 1702, 
+	1706, 1711, 1716, 1721, 1725, 1729, 1734, 1739, 
+	1744, 1749, 1754, 1758, 1762, 1768, 1774, 1779, 
+	1784, 1788, 1792, 1797, 1802, 1806, 1810, 1815, 
+	1820, 1825, 1829, 1833, 1838, 1843, 1848, 1853, 
+	1857, 1861, 1866, 1871, 1876, 1881, 1885, 1889, 
+	1894, 1899, 1904, 1909, 1913, 1917, 1922, 1927, 
+	1932, 1937, 1941, 1945, 1950, 1955, 1960, 1965, 
+	1969, 1973, 1979, 1984, 1989, 1994, 1998, 2002, 
+	2007, 2012, 2017, 2021, 2025, 2030, 2035, 2040, 
+	2045, 2049, 2053, 2058, 2063, 2068, 2073, 2077, 
+	2081, 2086, 2091, 2096, 2100, 2104, 2109, 2114, 
+	2119, 2124, 2129, 2133, 2137, 2141, 2145, 2148, 
+	2150, 2153, 2158, 2160, 2162, 2164, 2191, 2194, 
+	2199, 2204, 2215, 2217, 2223, 2226, 2233, 2235, 
+	2238, 2242, 2250, 2253, 2256, 2259, 2263, 2307, 
+	2309, 2311, 2314, 2317, 2319, 2321, 2322, 2328, 
+	2330, 2332, 2334, 2336, 2340, 2342, 2344, 2349, 
+	2353, 2357, 2359, 2362, 2364, 2366, 2368, 2370, 
+	2373, 2397, 2401, 2407, 2417, 2420, 2422, 2425, 
+	2431, 2435, 2438, 2441, 2443, 2446, 2457, 2464, 
+	2466, 2472, 2477, 2486, 2489, 2499, 2504, 2506, 
+	2508, 2513, 2515, 2519, 2520, 2528, 2540, 2544, 
+	2580, 2582, 2584, 2586, 2588, 2590, 2591, 2593, 
+	2595, 2600, 2604, 2608, 2610, 2612, 2614, 2621, 
+	2624, 2626, 2628, 2630, 2632, 2634
+};
+
+static const short _regex_indicies[] = {
+	0, 1, 3, 4, 5, 6, 7, 8, 
+	9, 10, 12, 13, 14, 15, 16, 17, 
+	18, 19, 19, 19, 19, 20, 11, 2, 
+	22, 23, 23, 23, 23, 21, 24, 25, 
+	25, 25, 25, 21, 27, 27, 27, 27, 
+	26, 28, 27, 27, 27, 27, 26, 29, 
+	26, 29, 30, 30, 30, 30, 26, 31, 
+	30, 32, 30, 30, 26, 29, 30, 32, 
+	30, 30, 26, 33, 33, 33, 33, 26, 
+	28, 33, 33, 33, 33, 26, 34, 35, 
+	36, 26, 37, 38, 26, 39, 40, 30, 
+	41, 30, 30, 26, 42, 42, 42, 42, 
+	26, 40, 42, 42, 42, 42, 26, 40, 
+	30, 41, 30, 30, 26, 43, 44, 21, 
+	45, 46, 47, 47, 47, 47, 21, 24, 
+	48, 48, 48, 48, 21, 49, 50, 21, 
+	48, 48, 48, 48, 21, 51, 51, 51, 
+	51, 21, 52, 51, 51, 51, 51, 21, 
+	23, 23, 23, 23, 21, 47, 47, 47, 
+	47, 21, 45, 53, 46, 54, 54, 54, 
+	54, 21, 57, 58, 55, 56, 57, 58, 
+	59, 56, 57, 58, 56, 61, 62, 55, 
+	60, 61, 62, 63, 60, 61, 62, 60, 
+	65, 66, 55, 64, 65, 66, 59, 64, 
+	65, 66, 64, 69, 68, 70, 67, 69, 
+	71, 72, 74, 73, 74, 74, 67, 75, 
+	67, 77, 76, 67, 77, 78, 67, 77, 
+	67, 74, 80, 79, 74, 74, 67, 74, 
+	80, 81, 74, 74, 67, 74, 80, 74, 
+	74, 74, 67, 74, 82, 74, 74, 74, 
+	67, 84, 84, 84, 84, 83, 85, 84, 
+	84, 84, 84, 83, 86, 86, 86, 86, 
+	83, 87, 86, 86, 86, 86, 83, 88, 
+	88, 88, 88, 83, 88, 89, 88, 88, 
+	88, 83, 91, 90, 92, 91, 90, 95, 
+	94, 94, 94, 93, 97, 99, 98, 96, 
+	101, 100, 96, 102, 100, 96, 104, 103, 
+	105, 103, 106, 103, 108, 107, 109, 107, 
+	110, 107, 111, 112, 107, 113, 107, 114, 
+	107, 115, 107, 117, 116, 118, 119, 116, 
+	120, 116, 121, 116, 122, 116, 123, 116, 
+	124, 116, 125, 116, 126, 116, 127, 116, 
+	128, 116, 129, 116, 130, 116, 131, 116, 
+	132, 116, 133, 134, 135, 116, 136, 116, 
+	137, 116, 138, 116, 139, 116, 140, 116, 
+	141, 116, 142, 116, 143, 116, 144, 116, 
+	145, 116, 146, 116, 147, 116, 148, 116, 
+	149, 116, 150, 116, 151, 116, 152, 116, 
+	153, 116, 154, 116, 155, 116, 156, 116, 
+	157, 158, 116, 159, 116, 160, 116, 161, 
+	116, 162, 116, 163, 116, 164, 165, 116, 
+	166, 116, 167, 116, 168, 116, 169, 116, 
+	170, 116, 171, 116, 172, 116, 174, 175, 
+	173, 176, 173, 177, 173, 178, 173, 179, 
+	173, 180, 173, 181, 173, 182, 173, 183, 
+	173, 184, 173, 185, 173, 186, 173, 187, 
+	173, 188, 173, 189, 173, 190, 173, 191, 
+	173, 192, 173, 193, 173, 194, 173, 195, 
+	196, 173, 197, 173, 198, 173, 199, 173, 
+	200, 173, 201, 173, 202, 173, 204, 203, 
+	205, 203, 206, 203, 207, 203, 208, 203, 
+	209, 203, 210, 173, 211, 173, 212, 173, 
+	213, 173, 214, 173, 215, 173, 216, 173, 
+	217, 218, 173, 219, 173, 220, 173, 221, 
+	173, 222, 173, 223, 173, 224, 173, 225, 
+	173, 226, 173, 227, 173, 228, 229, 116, 
+	230, 116, 231, 116, 232, 116, 233, 116, 
+	234, 116, 235, 116, 236, 116, 237, 116, 
+	238, 116, 239, 116, 240, 116, 241, 116, 
+	242, 116, 243, 116, 244, 116, 245, 116, 
+	246, 116, 247, 116, 248, 116, 249, 116, 
+	250, 116, 251, 116, 252, 116, 253, 116, 
+	254, 116, 255, 116, 256, 116, 257, 116, 
+	258, 116, 259, 116, 260, 116, 261, 116, 
+	262, 116, 263, 116, 264, 116, 265, 116, 
+	266, 116, 267, 116, 268, 116, 269, 116, 
+	270, 116, 271, 116, 272, 116, 273, 116, 
+	274, 116, 275, 116, 276, 116, 277, 116, 
+	278, 116, 279, 116, 280, 116, 281, 116, 
+	282, 116, 283, 116, 284, 116, 285, 116, 
+	286, 287, 116, 288, 116, 289, 116, 290, 
+	116, 291, 116, 292, 116, 293, 116, 294, 
+	116, 295, 116, 296, 116, 297, 116, 298, 
+	116, 300, 299, 301, 299, 302, 299, 303, 
+	299, 304, 299, 305, 116, 306, 116, 307, 
+	116, 308, 116, 309, 116, 310, 116, 311, 
+	116, 312, 116, 313, 116, 314, 116, 315, 
+	116, 316, 116, 317, 116, 318, 116, 319, 
+	116, 320, 116, 321, 116, 322, 116, 323, 
+	116, 324, 116, 325, 116, 326, 116, 327, 
+	116, 328, 116, 329, 330, 116, 331, 116, 
+	332, 116, 333, 116, 334, 116, 335, 116, 
+	336, 116, 337, 116, 338, 116, 339, 116, 
+	340, 116, 341, 116, 342, 116, 343, 116, 
+	344, 116, 345, 116, 346, 116, 347, 116, 
+	348, 116, 349, 116, 350, 351, 116, 352, 
+	116, 353, 116, 354, 116, 355, 116, 356, 
+	116, 357, 116, 358, 116, 359, 116, 360, 
+	116, 361, 116, 362, 116, 363, 116, 364, 
+	116, 365, 116, 366, 116, 367, 368, 369, 
+	370, 116, 371, 116, 372, 116, 373, 116, 
+	374, 116, 375, 116, 376, 116, 377, 116, 
+	378, 116, 379, 116, 380, 116, 381, 116, 
+	382, 116, 383, 116, 384, 116, 385, 116, 
+	386, 116, 387, 116, 388, 389, 116, 390, 
+	116, 391, 116, 392, 116, 393, 116, 394, 
+	116, 395, 116, 396, 116, 397, 116, 398, 
+	116, 400, 401, 399, 402, 399, 403, 399, 
+	404, 399, 405, 399, 406, 399, 407, 399, 
+	408, 409, 410, 399, 411, 399, 412, 399, 
+	413, 399, 414, 399, 415, 399, 416, 399, 
+	417, 399, 418, 399, 419, 420, 399, 421, 
+	399, 422, 399, 423, 399, 424, 399, 425, 
+	399, 426, 399, 428, 429, 427, 430, 427, 
+	431, 427, 432, 427, 433, 427, 434, 427, 
+	435, 427, 436, 427, 437, 427, 438, 427, 
+	439, 427, 441, 440, 442, 440, 443, 440, 
+	444, 440, 445, 440, 446, 440, 447, 440, 
+	448, 440, 449, 440, 450, 427, 451, 427, 
+	452, 427, 453, 427, 454, 427, 455, 427, 
+	456, 427, 457, 427, 458, 427, 459, 427, 
+	460, 427, 461, 427, 463, 462, 464, 462, 
+	465, 462, 466, 462, 467, 462, 468, 462, 
+	469, 462, 470, 462, 471, 462, 472, 462, 
+	473, 116, 474, 116, 475, 116, 476, 477, 
+	116, 478, 116, 479, 116, 480, 116, 481, 
+	116, 482, 116, 483, 116, 484, 485, 486, 
+	487, 116, 488, 116, 489, 116, 490, 116, 
+	491, 116, 492, 116, 493, 116, 494, 116, 
+	495, 116, 496, 116, 497, 116, 498, 116, 
+	499, 116, 500, 116, 501, 116, 502, 116, 
+	503, 116, 504, 116, 505, 116, 506, 116, 
+	507, 116, 508, 116, 509, 116, 510, 116, 
+	511, 116, 512, 116, 513, 116, 514, 116, 
+	515, 116, 516, 116, 517, 116, 518, 116, 
+	519, 116, 520, 116, 521, 116, 522, 116, 
+	523, 116, 525, 526, 524, 527, 524, 528, 
+	524, 529, 524, 530, 524, 531, 524, 532, 
+	524, 533, 524, 534, 524, 535, 524, 536, 
+	524, 537, 524, 538, 524, 539, 116, 540, 
+	116, 541, 116, 542, 116, 543, 116, 544, 
+	116, 545, 116, 547, 548, 546, 549, 546, 
+	550, 546, 551, 546, 552, 546, 553, 546, 
+	554, 546, 555, 546, 556, 546, 557, 546, 
+	558, 546, 559, 546, 560, 546, 561, 546, 
+	562, 546, 563, 546, 564, 546, 565, 546, 
+	566, 546, 567, 546, 568, 546, 569, 546, 
+	570, 546, 571, 546, 572, 546, 573, 546, 
+	574, 546, 575, 546, 576, 546, 577, 546, 
+	578, 546, 579, 580, 546, 581, 546, 582, 
+	546, 583, 546, 584, 546, 585, 546, 586, 
+	546, 587, 546, 588, 546, 589, 546, 590, 
+	546, 591, 546, 592, 546, 593, 594, 595, 
+	116, 596, 597, 116, 598, 116, 599, 116, 
+	600, 116, 601, 116, 602, 116, 603, 116, 
+	604, 116, 605, 116, 606, 607, 608, 116, 
+	609, 116, 610, 116, 611, 116, 612, 116, 
+	613, 116, 614, 116, 615, 116, 616, 116, 
+	617, 116, 618, 116, 619, 116, 620, 116, 
+	621, 116, 622, 116, 623, 624, 116, 625, 
+	116, 626, 116, 627, 628, 116, 629, 116, 
+	630, 116, 631, 116, 632, 116, 633, 116, 
+	634, 116, 635, 116, 636, 116, 637, 116, 
+	638, 116, 639, 116, 640, 116, 641, 116, 
+	642, 116, 643, 116, 644, 116, 645, 116, 
+	646, 116, 647, 116, 648, 116, 650, 649, 
+	652, 651, 653, 649, 649, 651, 656, 657, 
+	654, 655, 656, 657, 658, 655, 656, 657, 
+	655, 660, 661, 654, 662, 663, 664, 665, 
+	666, 667, 668, 669, 670, 671, 672, 673, 
+	659, 660, 661, 654, 659, 660, 661, 674, 
+	659, 660, 661, 659, 660, 661, 654, 675, 
+	676, 677, 678, 679, 680, 681, 682, 683, 
+	684, 685, 659, 660, 661, 654, 686, 687, 
+	659, 660, 661, 654, 688, 689, 659, 660, 
+	661, 654, 690, 659, 660, 661, 654, 691, 
+	659, 692, 661, 654, 659, 660, 661, 693, 
+	659, 660, 661, 654, 694, 659, 660, 661, 
+	654, 695, 659, 696, 661, 654, 659, 660, 
+	661, 697, 659, 660, 661, 654, 698, 659, 
+	660, 661, 654, 699, 659, 660, 661, 654, 
+	700, 659, 701, 661, 654, 659, 660, 661, 
+	702, 659, 660, 661, 654, 703, 659, 660, 
+	661, 654, 704, 659, 660, 661, 654, 705, 
+	659, 660, 661, 654, 706, 659, 707, 661, 
+	654, 659, 660, 661, 708, 659, 660, 661, 
+	654, 709, 659, 660, 661, 654, 710, 659, 
+	660, 661, 654, 711, 659, 660, 661, 654, 
+	712, 659, 713, 661, 654, 659, 660, 661, 
+	714, 659, 660, 661, 654, 715, 659, 660, 
+	661, 654, 716, 659, 660, 661, 654, 717, 
+	659, 660, 661, 654, 718, 659, 719, 661, 
+	654, 659, 660, 661, 720, 659, 660, 661, 
+	654, 721, 659, 660, 661, 654, 722, 659, 
+	660, 661, 654, 723, 659, 660, 661, 654, 
+	724, 659, 725, 661, 654, 659, 660, 661, 
+	726, 659, 660, 661, 654, 727, 659, 660, 
+	661, 654, 728, 659, 660, 661, 654, 729, 
+	659, 660, 661, 654, 730, 659, 731, 661, 
+	654, 659, 660, 661, 732, 659, 660, 661, 
+	654, 733, 734, 659, 660, 661, 654, 735, 
+	659, 660, 661, 654, 736, 659, 660, 661, 
+	654, 737, 659, 738, 661, 654, 659, 660, 
+	661, 739, 659, 660, 661, 654, 740, 659, 
+	660, 661, 654, 741, 659, 660, 661, 654, 
+	742, 659, 743, 661, 654, 659, 660, 661, 
+	744, 659, 660, 661, 654, 745, 659, 660, 
+	661, 654, 746, 659, 660, 661, 654, 747, 
+	659, 660, 661, 654, 748, 659, 749, 661, 
+	654, 659, 660, 661, 750, 659, 660, 661, 
+	654, 751, 659, 660, 661, 654, 752, 659, 
+	660, 661, 654, 753, 659, 660, 661, 654, 
+	754, 659, 755, 661, 654, 659, 660, 661, 
+	756, 659, 660, 661, 654, 757, 659, 660, 
+	661, 654, 758, 659, 660, 661, 654, 759, 
+	659, 760, 661, 654, 659, 660, 661, 761, 
+	659, 660, 661, 654, 762, 659, 660, 661, 
+	654, 763, 659, 660, 661, 654, 764, 659, 
+	660, 661, 654, 765, 659, 660, 661, 654, 
+	766, 659, 767, 661, 654, 659, 660, 661, 
+	768, 659, 660, 661, 654, 769, 770, 659, 
+	660, 661, 654, 771, 772, 659, 660, 661, 
+	654, 773, 659, 660, 661, 654, 774, 659, 
+	775, 661, 654, 659, 660, 661, 776, 659, 
+	660, 661, 654, 777, 659, 660, 661, 654, 
+	778, 659, 779, 661, 654, 659, 660, 661, 
+	780, 659, 660, 661, 654, 781, 659, 660, 
+	661, 654, 782, 659, 660, 661, 654, 783, 
+	659, 784, 661, 654, 659, 660, 661, 785, 
+	659, 660, 661, 654, 786, 659, 660, 661, 
+	654, 787, 659, 660, 661, 654, 788, 659, 
+	660, 661, 654, 789, 659, 790, 661, 654, 
+	659, 660, 661, 791, 659, 660, 661, 654, 
+	792, 659, 660, 661, 654, 793, 659, 660, 
+	661, 654, 794, 659, 660, 661, 654, 795, 
+	659, 796, 661, 654, 659, 660, 661, 797, 
+	659, 660, 661, 654, 798, 659, 660, 661, 
+	654, 799, 659, 660, 661, 654, 800, 659, 
+	660, 661, 654, 801, 659, 802, 661, 654, 
+	659, 660, 661, 803, 659, 660, 661, 654, 
+	804, 659, 660, 661, 654, 805, 659, 660, 
+	661, 654, 806, 659, 660, 661, 654, 807, 
+	659, 808, 661, 654, 659, 660, 661, 809, 
+	659, 660, 661, 654, 810, 659, 660, 661, 
+	654, 811, 659, 660, 661, 654, 812, 659, 
+	660, 661, 654, 813, 659, 814, 661, 654, 
+	659, 660, 661, 815, 659, 660, 661, 654, 
+	816, 817, 659, 660, 661, 654, 818, 659, 
+	660, 661, 654, 819, 659, 660, 661, 654, 
+	820, 659, 821, 661, 654, 659, 660, 661, 
+	822, 659, 660, 661, 654, 823, 659, 660, 
+	661, 654, 824, 659, 660, 661, 654, 825, 
+	659, 826, 661, 654, 659, 660, 661, 827, 
+	659, 660, 661, 654, 828, 659, 660, 661, 
+	654, 829, 659, 660, 661, 654, 830, 659, 
+	660, 661, 654, 831, 659, 832, 661, 654, 
+	659, 660, 661, 833, 659, 660, 661, 654, 
+	834, 659, 660, 661, 654, 835, 659, 660, 
+	661, 654, 836, 659, 660, 661, 654, 837, 
+	659, 838, 661, 654, 659, 660, 661, 839, 
+	659, 660, 661, 654, 840, 659, 660, 661, 
+	654, 841, 659, 660, 661, 654, 842, 659, 
+	843, 661, 654, 659, 660, 661, 844, 659, 
+	660, 661, 654, 845, 659, 660, 661, 654, 
+	846, 659, 660, 661, 654, 847, 659, 660, 
+	661, 654, 848, 659, 660, 661, 654, 849, 
+	659, 850, 661, 654, 659, 660, 661, 851, 
+	659, 853, 854, 654, 852, 853, 854, 658, 
+	852, 853, 854, 852, 856, 855, 857, 856, 
+	855, 860, 859, 859, 859, 858, 862, 861, 
+	863, 861, 864, 861, 865, 867, 868, 870, 
+	871, 872, 873, 874, 875, 876, 877, 878, 
+	879, 880, 866, 885, 866, 867, 866, 866, 
+	866, 881, 882, 883, 884, 881, 869, 887, 
+	888, 886, 23, 23, 23, 23, 889, 25, 
+	25, 25, 25, 889, 891, 30, 894, 895, 
+	896, 30, 892, 893, 30, 30, 890, 44, 
+	889, 47, 47, 47, 47, 44, 889, 43, 
+	44, 889, 897, 898, 48, 48, 48, 48, 
+	889, 899, 889, 49, 50, 889, 900, 901, 
+	902, 889, 45, 53, 46, 54, 54, 54, 
+	54, 889, 904, 905, 903, 907, 908, 906, 
+	910, 911, 909, 56, 60, 64, 912, 915, 
+	918, 919, 920, 921, 922, 923, 924, 925, 
+	926, 926, 927, 928, 929, 930, 926, 931, 
+	932, 933, 934, 935, 936, 937, 938, 939, 
+	940, 941, 942, 943, 926, 944, 945, 946, 
+	947, 948, 949, 926, 950, 951, 952, 953, 
+	916, 917, 914, 955, 954, 956, 954, 958, 
+	959, 957, 961, 959, 960, 959, 962, 965, 
+	964, 967, 68, 969, 71, 971, 970, 968, 
+	973, 972, 974, 972, 976, 975, 977, 975, 
+	979, 980, 981, 978, 983, 982, 986, 985, 
+	991, 988, 989, 990, 987, 992, 993, 994, 
+	987, 94, 94, 94, 995, 98, 996, 998, 
+	999, 997, 1001, 1000, 1002, 1000, 1003, 1000, 
+	1005, 1004, 1007, 1008, 1006, 1010, 1011, 1012, 
+	1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 
+	1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 
+	1029, 1030, 1031, 1032, 1009, 1034, 1035, 1036, 
+	1033, 1037, 1038, 1039, 1040, 1041, 1033, 1043, 
+	1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 
+	1042, 1053, 1054, 1052, 1055, 1033, 1056, 1057, 
+	1033, 1058, 1059, 1060, 1061, 1062, 1033, 1063, 
+	1064, 1065, 1033, 1067, 1068, 1066, 1069, 1070, 
+	1033, 1071, 1033, 1072, 1073, 1033, 1075, 1076, 
+	1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 
+	1074, 1086, 1087, 1088, 1089, 1090, 1091, 1085, 
+	1093, 1092, 1095, 1096, 1097, 1098, 1099, 1094, 
+	1100, 1101, 1102, 1103, 1033, 1105, 1106, 1107, 
+	1108, 1109, 1110, 1111, 1112, 1104, 1113, 1114, 
+	1033, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 
+	1123, 1124, 1115, 1125, 1126, 1127, 1128, 1033, 
+	1129, 1033, 1130, 1033, 1131, 1132, 1133, 1134, 
+	1033, 1135, 1033, 1137, 1138, 1139, 1136, 649, 
+	1141, 1142, 1143, 1144, 1145, 1146, 1147, 1140, 
+	1149, 1150, 1151, 1152, 1148, 1148, 1153, 1154, 
+	1155, 1156, 1153, 869, 655, 1158, 852, 1157, 
+	1160, 1164, 1165, 1166, 1167, 1167, 1168, 1169, 
+	1170, 1167, 1171, 1172, 1173, 1174, 1175, 1176, 
+	1177, 1178, 1179, 1180, 1167, 1181, 1182, 1183, 
+	1184, 1185, 1186, 1167, 1187, 1188, 1189, 1161, 
+	1162, 1163, 1163, 1159, 1191, 1190, 1192, 1190, 
+	1194, 1193, 1195, 1193, 1198, 1197, 1200, 1202, 
+	1201, 1205, 1204, 1210, 1207, 1208, 1209, 1206, 
+	1211, 1212, 1213, 1206, 859, 859, 859, 1214, 
+	1216, 1215, 1217, 1215, 1218, 1215, 1220, 1221, 
+	1222, 1219, 1219, 1219, 869, 1224, 1225, 1223, 
+	1227, 1226, 1229, 1228, 1231, 1230, 1233, 1232, 
+	1235, 1234, 1237, 1236, 0
+};
+
+static const short _regex_trans_targs[] = {
+	741, 741, 741, 741, 741, 743, 744, 745, 
+	741, 746, 747, 748, 741, 749, 741, 741, 
+	750, 751, 752, 753, 741, 741, 741, 3, 
+	741, 4, 741, 6, 7, 741, 8, 741, 
+	9, 12, 741, 14, 741, 741, 741, 16, 
+	741, 18, 17, 741, 19, 741, 741, 20, 
+	21, 741, 22, 25, 741, 27, 28, 741, 
+	29, 30, 31, 741, 32, 33, 34, 741, 
+	35, 36, 37, 741, 38, 741, 767, 40, 
+	42, 46, 49, 43, 44, 741, 45, 47, 
+	741, 48, 741, 741, 51, 741, 53, 741, 
+	55, 741, 741, 57, 741, 741, 58, 741, 
+	741, 60, 59, 778, 61, 778, 778, 741, 
+	741, 64, 741, 782, 66, 782, 68, 69, 
+	71, 70, 782, 782, 784, 784, 74, 77, 
+	75, 76, 784, 78, 79, 80, 81, 784, 
+	83, 84, 85, 86, 784, 88, 93, 95, 
+	89, 90, 91, 92, 784, 94, 784, 96, 
+	784, 98, 99, 100, 101, 784, 103, 104, 
+	105, 106, 107, 784, 109, 110, 112, 111, 
+	784, 113, 114, 784, 116, 121, 117, 118, 
+	119, 120, 784, 122, 784, 784, 124, 140, 
+	125, 126, 127, 128, 129, 130, 131, 132, 
+	133, 134, 135, 136, 137, 138, 139, 784, 
+	141, 142, 784, 144, 145, 784, 146, 147, 
+	148, 149, 784, 784, 151, 152, 784, 154, 
+	155, 784, 157, 158, 159, 160, 161, 162, 
+	784, 164, 168, 165, 166, 167, 784, 169, 
+	170, 171, 172, 784, 174, 178, 175, 176, 
+	177, 784, 179, 180, 181, 182, 183, 184, 
+	784, 186, 187, 188, 189, 190, 191, 192, 
+	193, 194, 195, 196, 197, 198, 199, 200, 
+	201, 202, 784, 204, 205, 206, 207, 208, 
+	784, 210, 211, 212, 213, 214, 784, 216, 
+	217, 218, 219, 220, 221, 222, 784, 224, 
+	225, 226, 784, 228, 229, 784, 231, 236, 
+	232, 233, 234, 235, 784, 237, 238, 239, 
+	240, 784, 793, 784, 243, 784, 245, 246, 
+	784, 248, 249, 250, 784, 252, 253, 254, 
+	255, 256, 784, 258, 259, 260, 261, 262, 
+	263, 264, 265, 266, 267, 268, 269, 270, 
+	784, 272, 278, 273, 274, 275, 276, 277, 
+	784, 279, 280, 281, 282, 283, 284, 285, 
+	286, 287, 288, 289, 290, 291, 292, 296, 
+	293, 294, 295, 784, 297, 298, 299, 300, 
+	784, 302, 303, 304, 305, 306, 784, 308, 
+	311, 315, 320, 309, 310, 784, 312, 313, 
+	314, 784, 316, 317, 318, 319, 784, 321, 
+	322, 323, 324, 784, 326, 333, 327, 328, 
+	329, 330, 331, 332, 784, 334, 784, 784, 
+	784, 336, 337, 784, 339, 340, 341, 784, 
+	343, 345, 350, 344, 784, 346, 347, 348, 
+	349, 784, 784, 352, 355, 353, 354, 784, 
+	356, 357, 784, 784, 359, 365, 360, 361, 
+	362, 363, 364, 784, 366, 367, 368, 784, 
+	784, 370, 371, 372, 373, 374, 375, 376, 
+	377, 784, 379, 380, 381, 382, 383, 384, 
+	784, 386, 387, 388, 389, 784, 784, 391, 
+	392, 393, 394, 395, 396, 397, 398, 784, 
+	784, 401, 402, 784, 404, 409, 405, 406, 
+	407, 408, 784, 410, 411, 416, 422, 434, 
+	412, 413, 414, 415, 784, 417, 418, 419, 
+	420, 421, 784, 423, 424, 425, 426, 427, 
+	428, 429, 430, 431, 432, 433, 784, 435, 
+	436, 437, 438, 784, 440, 441, 784, 443, 
+	444, 445, 446, 784, 784, 448, 453, 449, 
+	450, 451, 452, 784, 454, 455, 456, 457, 
+	458, 459, 784, 461, 462, 463, 784, 465, 
+	466, 784, 784, 468, 474, 469, 470, 471, 
+	472, 473, 784, 475, 476, 477, 478, 479, 
+	480, 784, 482, 483, 484, 485, 784, 487, 
+	488, 489, 490, 784, 492, 493, 494, 495, 
+	496, 497, 784, 499, 508, 500, 501, 502, 
+	503, 504, 505, 506, 507, 784, 509, 510, 
+	784, 512, 520, 529, 513, 516, 514, 515, 
+	784, 517, 518, 519, 784, 521, 522, 523, 
+	526, 784, 524, 525, 784, 527, 528, 784, 
+	530, 784, 532, 533, 534, 784, 536, 537, 
+	784, 538, 784, 540, 544, 541, 542, 543, 
+	784, 545, 546, 547, 548, 784, 550, 551, 
+	552, 553, 554, 784, 784, 784, 784, 784, 
+	784, 0, 561, 562, 563, 811, 813, 564, 
+	565, 566, 813, 568, 569, 570, 571, 652, 
+	667, 673, 679, 685, 691, 697, 708, 714, 
+	720, 725, 813, 572, 587, 593, 599, 605, 
+	611, 617, 628, 634, 640, 645, 573, 582, 
+	574, 578, 575, 576, 577, 813, 579, 580, 
+	581, 813, 583, 584, 585, 586, 813, 588, 
+	589, 590, 591, 592, 813, 594, 595, 596, 
+	597, 598, 813, 600, 601, 602, 603, 604, 
+	813, 606, 607, 608, 609, 610, 813, 612, 
+	613, 614, 615, 616, 813, 618, 623, 619, 
+	620, 621, 622, 813, 624, 625, 626, 627, 
+	813, 629, 630, 631, 632, 633, 813, 635, 
+	636, 637, 638, 639, 813, 641, 642, 643, 
+	644, 813, 646, 647, 648, 649, 650, 651, 
+	813, 653, 662, 654, 658, 655, 656, 657, 
+	813, 659, 660, 661, 813, 663, 664, 665, 
+	666, 813, 668, 669, 670, 671, 672, 813, 
+	674, 675, 676, 677, 678, 813, 680, 681, 
+	682, 683, 684, 813, 686, 687, 688, 689, 
+	690, 813, 692, 693, 694, 695, 696, 813, 
+	698, 703, 699, 700, 701, 702, 813, 704, 
+	705, 706, 707, 813, 709, 710, 711, 712, 
+	713, 813, 715, 716, 717, 718, 719, 813, 
+	721, 722, 723, 724, 813, 726, 727, 728, 
+	729, 730, 731, 813, 732, 733, 734, 813, 
+	736, 813, 813, 737, 813, 813, 813, 740, 
+	813, 741, 741, 741, 741, 0, 742, 741, 
+	754, 755, 741, 756, 757, 758, 741, 777, 
+	741, 741, 779, 780, 781, 741, 741, 1, 
+	2, 741, 741, 5, 9, 10, 11, 13, 
+	15, 741, 741, 741, 23, 24, 26, 741, 
+	741, 741, 741, 741, 741, 741, 741, 741, 
+	741, 741, 741, 759, 761, 763, 741, 741, 
+	741, 741, 741, 741, 741, 741, 741, 764, 
+	741, 741, 741, 741, 741, 741, 741, 741, 
+	741, 765, 741, 741, 741, 766, 741, 771, 
+	741, 772, 773, 741, 741, 741, 741, 741, 
+	774, 741, 741, 760, 741, 741, 762, 763, 
+	741, 763, 741, 741, 741, 741, 741, 741, 
+	741, 39, 769, 41, 741, 768, 741, 741, 
+	770, 741, 741, 50, 52, 54, 741, 56, 
+	741, 741, 741, 741, 775, 775, 775, 776, 
+	741, 741, 741, 741, 741, 741, 741, 741, 
+	741, 741, 62, 63, 782, 783, 782, 65, 
+	67, 784, 785, 786, 787, 789, 790, 791, 
+	792, 794, 795, 796, 797, 798, 800, 801, 
+	802, 803, 804, 805, 806, 807, 808, 809, 
+	810, 784, 72, 73, 82, 87, 97, 102, 
+	108, 115, 784, 123, 784, 784, 143, 784, 
+	788, 784, 156, 163, 784, 150, 153, 173, 
+	185, 203, 209, 215, 223, 227, 230, 241, 
+	247, 251, 784, 242, 244, 257, 271, 301, 
+	307, 325, 784, 784, 335, 338, 342, 784, 
+	784, 784, 784, 784, 351, 784, 358, 784, 
+	799, 784, 378, 385, 784, 369, 784, 784, 
+	390, 399, 784, 784, 400, 403, 439, 442, 
+	784, 784, 784, 784, 784, 447, 784, 784, 
+	784, 460, 464, 784, 467, 784, 481, 486, 
+	784, 784, 784, 491, 498, 511, 531, 535, 
+	539, 549, 555, 556, 557, 558, 559, 784, 
+	784, 784, 784, 784, 812, 812, 812, 812, 
+	812, 812, 812, 812, 813, 813, 814, 815, 
+	813, 813, 827, 828, 829, 813, 567, 813, 
+	816, 818, 813, 813, 813, 813, 813, 813, 
+	820, 813, 813, 813, 813, 813, 813, 821, 
+	813, 813, 813, 813, 813, 813, 822, 823, 
+	813, 813, 813, 813, 813, 824, 813, 817, 
+	813, 813, 819, 813, 813, 813, 813, 813, 
+	813, 813, 735, 813, 813, 813, 813, 825, 
+	825, 825, 826, 813, 813, 813, 813, 813, 
+	813, 738, 739, 830, 831, 830, 830, 830, 
+	830, 830, 832, 833, 832, 832, 834, 835, 
+	834, 834, 836, 836, 837, 837
+};
+
+static const short _regex_trans_actions[] = {
+	801, 605, 739, 705, 697, 45, 877, 877, 
+	871, 45, 886, 45, 874, 877, 703, 715, 
+	0, 45, 45, 897, 711, 815, 721, 0, 
+	717, 3, 813, 3, 0, 735, 3, 733, 
+	844, 3, 725, 0, 723, 729, 727, 0, 
+	731, 3, 0, 719, 0, 699, 701, 27, 
+	3, 737, 0, 3, 647, 0, 25, 803, 
+	0, 0, 0, 577, 0, 0, 0, 575, 
+	0, 0, 0, 805, 0, 649, 17, 0, 
+	7, 844, 3, 17, 17, 637, 17, 844, 
+	635, 844, 639, 811, 3, 645, 3, 643, 
+	3, 641, 807, 0, 651, 809, 0, 653, 
+	819, 0, 11, 29, 13, 31, 0, 817, 
+	743, 0, 745, 57, 0, 49, 0, 0, 
+	0, 0, 51, 47, 357, 313, 0, 0, 
+	0, 0, 125, 0, 0, 0, 0, 127, 
+	0, 0, 0, 0, 129, 0, 0, 0, 
+	0, 0, 0, 0, 131, 0, 133, 0, 
+	135, 0, 0, 0, 0, 137, 0, 0, 
+	0, 0, 0, 139, 0, 0, 0, 0, 
+	141, 0, 0, 143, 0, 0, 0, 0, 
+	0, 0, 145, 0, 147, 339, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 149, 
+	0, 0, 151, 0, 0, 153, 0, 0, 
+	0, 0, 155, 341, 0, 0, 157, 0, 
+	0, 159, 0, 0, 0, 0, 0, 0, 
+	161, 0, 0, 0, 0, 0, 163, 0, 
+	0, 0, 0, 165, 0, 0, 0, 0, 
+	0, 167, 0, 0, 0, 0, 0, 0, 
+	169, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 171, 0, 0, 0, 0, 0, 
+	173, 0, 0, 0, 0, 0, 175, 0, 
+	0, 0, 0, 0, 0, 0, 177, 0, 
+	0, 0, 179, 0, 0, 181, 0, 0, 
+	0, 0, 0, 0, 183, 0, 0, 0, 
+	0, 185, 45, 355, 0, 187, 0, 0, 
+	189, 0, 0, 0, 191, 0, 0, 0, 
+	0, 0, 193, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	195, 0, 0, 0, 0, 0, 0, 0, 
+	197, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 199, 0, 0, 0, 0, 
+	201, 0, 0, 0, 0, 0, 203, 0, 
+	0, 0, 0, 0, 0, 205, 0, 0, 
+	0, 207, 0, 0, 0, 0, 209, 0, 
+	0, 0, 0, 211, 0, 0, 0, 0, 
+	0, 0, 0, 0, 213, 0, 215, 343, 
+	217, 0, 0, 219, 0, 0, 0, 221, 
+	0, 0, 0, 0, 223, 0, 0, 0, 
+	0, 225, 227, 0, 0, 0, 0, 229, 
+	0, 0, 231, 345, 0, 0, 0, 0, 
+	0, 0, 0, 233, 0, 0, 0, 235, 
+	347, 0, 0, 0, 0, 0, 0, 0, 
+	0, 237, 0, 0, 0, 0, 0, 0, 
+	239, 0, 0, 0, 0, 241, 349, 0, 
+	0, 0, 0, 0, 0, 0, 0, 243, 
+	245, 0, 0, 247, 0, 0, 0, 0, 
+	0, 0, 249, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 251, 0, 0, 0, 
+	0, 0, 253, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 255, 0, 
+	0, 0, 0, 257, 0, 0, 259, 0, 
+	0, 0, 0, 261, 351, 0, 0, 0, 
+	0, 0, 0, 263, 0, 0, 0, 0, 
+	0, 0, 265, 0, 0, 0, 267, 0, 
+	0, 269, 353, 0, 0, 0, 0, 0, 
+	0, 0, 271, 0, 0, 0, 0, 0, 
+	0, 273, 0, 0, 0, 0, 275, 0, 
+	0, 0, 0, 277, 0, 0, 0, 0, 
+	0, 0, 279, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 281, 0, 0, 
+	283, 0, 0, 0, 0, 0, 0, 0, 
+	285, 0, 0, 0, 287, 0, 0, 0, 
+	0, 289, 0, 0, 291, 0, 0, 293, 
+	0, 295, 0, 0, 0, 297, 0, 0, 
+	301, 0, 299, 0, 0, 0, 0, 0, 
+	303, 0, 0, 0, 0, 305, 0, 0, 
+	0, 0, 0, 307, 309, 117, 119, 121, 
+	123, 39, 0, 35, 33, 37, 537, 0, 
+	0, 0, 375, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 433, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 379, 0, 0, 
+	0, 383, 0, 0, 0, 0, 387, 0, 
+	0, 0, 0, 0, 391, 0, 0, 0, 
+	0, 0, 395, 0, 0, 0, 0, 0, 
+	399, 0, 0, 0, 0, 0, 403, 0, 
+	0, 0, 0, 0, 407, 0, 0, 0, 
+	0, 0, 0, 411, 0, 0, 0, 0, 
+	415, 0, 0, 0, 0, 0, 419, 0, 
+	0, 0, 0, 0, 423, 0, 0, 0, 
+	0, 427, 0, 0, 0, 0, 0, 0, 
+	431, 0, 0, 0, 0, 0, 0, 0, 
+	377, 0, 0, 0, 381, 0, 0, 0, 
+	0, 385, 0, 0, 0, 0, 0, 389, 
+	0, 0, 0, 0, 0, 393, 0, 0, 
+	0, 0, 0, 397, 0, 0, 0, 0, 
+	0, 401, 0, 0, 0, 0, 0, 405, 
+	0, 0, 0, 0, 0, 0, 409, 0, 
+	0, 0, 0, 413, 0, 0, 0, 0, 
+	0, 417, 0, 0, 0, 0, 0, 421, 
+	0, 0, 0, 0, 425, 0, 0, 0, 
+	0, 0, 0, 429, 0, 0, 0, 531, 
+	0, 469, 533, 0, 473, 535, 501, 0, 
+	503, 607, 751, 749, 611, 0, 45, 571, 
+	0, 0, 583, 0, 45, 0, 609, 883, 
+	573, 747, 0, 45, 45, 603, 753, 0, 
+	0, 795, 793, 1, 829, 829, 1, 0, 
+	3, 709, 707, 713, 1, 1, 0, 757, 
+	589, 587, 759, 593, 591, 761, 597, 595, 
+	755, 791, 695, 5, 826, 889, 613, 621, 
+	585, 669, 581, 691, 673, 689, 657, 0, 
+	579, 687, 665, 677, 661, 693, 615, 631, 
+	619, 0, 667, 633, 629, 880, 671, 45, 
+	625, 45, 0, 627, 663, 623, 675, 659, 
+	7, 617, 765, 15, 841, 769, 832, 893, 
+	767, 901, 821, 785, 685, 683, 783, 655, 
+	775, 7, 17, 823, 773, 17, 850, 771, 
+	17, 847, 789, 1, 1, 1, 777, 0, 
+	787, 681, 679, 779, 19, 23, 21, 45, 
+	856, 868, 862, 781, 799, 763, 601, 599, 
+	797, 741, 0, 0, 53, 45, 55, 0, 
+	0, 315, 45, 45, 45, 45, 45, 45, 
+	45, 45, 45, 45, 45, 45, 45, 45, 
+	45, 45, 45, 45, 45, 45, 45, 0, 
+	0, 337, 0, 0, 0, 0, 0, 0, 
+	0, 0, 317, 0, 59, 61, 0, 63, 
+	45, 65, 0, 0, 319, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 335, 0, 0, 0, 0, 0, 
+	0, 0, 321, 77, 0, 0, 0, 67, 
+	69, 71, 73, 75, 0, 323, 0, 79, 
+	45, 81, 0, 0, 325, 0, 327, 83, 
+	0, 0, 85, 87, 0, 0, 0, 0, 
+	329, 89, 91, 93, 95, 0, 97, 99, 
+	101, 0, 0, 331, 0, 103, 0, 0, 
+	105, 107, 109, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 311, 
+	333, 111, 113, 115, 373, 359, 361, 363, 
+	365, 367, 369, 371, 507, 489, 45, 0, 
+	509, 505, 0, 45, 45, 529, 0, 497, 
+	5, 9, 471, 495, 487, 437, 455, 491, 
+	0, 435, 483, 459, 479, 449, 439, 0, 
+	485, 451, 447, 493, 453, 443, 45, 0, 
+	445, 481, 441, 457, 477, 7, 515, 15, 
+	835, 517, 15, 838, 511, 467, 465, 525, 
+	475, 519, 0, 513, 463, 461, 521, 19, 
+	23, 21, 45, 853, 865, 859, 523, 527, 
+	499, 0, 0, 547, 0, 541, 539, 549, 
+	545, 543, 553, 0, 555, 551, 559, 0, 
+	561, 557, 565, 563, 569, 567
+};
+
+static const short _regex_to_state_actions[] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	41, 0, 41, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 41, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 41, 0, 
+	41, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 41, 41, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 41, 0, 
+	41, 0, 41, 0, 41, 41
+};
+
+static const short _regex_from_state_actions[] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 43, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 43, 0, 
+	43, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 43, 43, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 43, 0, 
+	43, 0, 43, 0, 43, 43
+};
+
+static const short _regex_eof_actions[] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	39, 39, 39, 39, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0
+};
+
+static const short _regex_eof_trans[] = {
+	0, 1, 1, 22, 22, 27, 27, 27, 
+	27, 27, 27, 27, 27, 27, 27, 27, 
+	27, 27, 27, 22, 22, 22, 22, 22, 
+	22, 22, 22, 22, 22, 56, 56, 56, 
+	56, 56, 56, 56, 56, 56, 68, 68, 
+	68, 68, 68, 68, 68, 68, 68, 68, 
+	68, 68, 84, 84, 84, 84, 84, 84, 
+	91, 91, 94, 97, 97, 97, 104, 104, 
+	104, 108, 108, 108, 108, 108, 108, 108, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 174, 174, 174, 174, 174, 
+	174, 174, 174, 174, 174, 174, 174, 174, 
+	174, 174, 174, 174, 174, 174, 174, 174, 
+	174, 174, 174, 174, 174, 174, 204, 204, 
+	204, 204, 204, 204, 174, 174, 174, 174, 
+	174, 174, 174, 174, 174, 174, 174, 174, 
+	174, 174, 174, 174, 174, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 300, 300, 300, 300, 300, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 400, 
+	400, 400, 400, 400, 400, 400, 400, 400, 
+	400, 400, 400, 400, 400, 400, 400, 400, 
+	400, 400, 400, 400, 400, 400, 428, 428, 
+	428, 428, 428, 428, 428, 428, 428, 428, 
+	428, 441, 441, 441, 441, 441, 441, 441, 
+	441, 441, 428, 428, 428, 428, 428, 428, 
+	428, 428, 428, 428, 428, 428, 463, 463, 
+	463, 463, 463, 463, 463, 463, 463, 463, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 525, 
+	525, 525, 525, 525, 525, 525, 525, 525, 
+	525, 525, 525, 525, 117, 117, 117, 117, 
+	117, 117, 117, 547, 547, 547, 547, 547, 
+	547, 547, 547, 547, 547, 547, 547, 547, 
+	547, 547, 547, 547, 547, 547, 547, 547, 
+	547, 547, 547, 547, 547, 547, 547, 547, 
+	547, 547, 547, 547, 547, 547, 547, 547, 
+	547, 547, 547, 547, 547, 547, 547, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	117, 117, 117, 117, 117, 117, 117, 117, 
+	0, 0, 0, 0, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 655, 
+	655, 655, 655, 655, 655, 655, 655, 856, 
+	856, 859, 862, 862, 862, 0, 887, 890, 
+	890, 891, 890, 890, 890, 890, 890, 890, 
+	890, 890, 904, 907, 910, 913, 914, 955, 
+	955, 958, 961, 963, 964, 967, 969, 973, 
+	973, 976, 976, 979, 983, 985, 988, 988, 
+	996, 997, 998, 1001, 1001, 1001, 0, 1007, 
+	0, 1034, 1034, 1043, 1053, 1034, 1034, 1034, 
+	1034, 1067, 1034, 1034, 1034, 1075, 1086, 1093, 
+	1095, 1034, 1105, 1034, 1116, 1034, 1034, 1034, 
+	1034, 1034, 1137, 0, 0, 0, 1158, 1158, 
+	1191, 1191, 1194, 1194, 1197, 1200, 1202, 1204, 
+	1207, 1207, 1215, 1216, 1216, 1216, 0, 1224, 
+	0, 1229, 0, 1233, 0, 0
+};
+
+static const int regex_start = 741;
+static const int regex_error = 0;
+
+static const int regex_en_readVerb = 782;
+static const int regex_en_readUCP = 784;
+static const int regex_en_readBracedUCP = 560;
+static const int regex_en_readUCPSingle = 812;
+static const int regex_en_charClassGuts = 813;
+static const int regex_en_readClass = 830;
+static const int regex_en_readQuotedLiteral = 832;
+static const int regex_en_readQuotedClass = 834;
+static const int regex_en_readComment = 836;
+static const int regex_en_readNewlineTerminatedComment = 837;
+static const int regex_en_main = 741;
+
+
+#line 1836 "hyperscan-4.1.0/src/parser/Parser.rl"
+
+/** \brief Main parser call, returns root Component or nullptr. */
+unique_ptr<Component> parse(const char *const c_ptr, ParseMode &globalMode) {
+    const u8 * const ptr = (const u8 * const)c_ptr;
+    const u8 *p = ptr;
+    const u8 *pe = ptr + strlen(c_ptr);
+    const u8 *eof = pe;
+    int cs;
+    UNUSED int act;
+    int top;
+    vector<int> stack;
+    const u8 *ts, *te;
+    unichar accumulator = 0;
+    unichar octAccumulator = 0; /* required as we are also accumulating for
+                                 * back ref when looking for octals */
+    unsigned repeatN = 0;
+    unsigned repeatM = 0;
+    string label;
+
+    ParseMode mode = globalMode;
+    ParseMode newMode;
+
+    bool negated = false;
+    bool inComment = false;
+
+    // Stack of sequences and flags used to store state when we enter
+    // sub-sequences.
+    vector<ExprState> sequences;
+
+    // Index of the next capturing group. Note that zero is reserved for the
+    // root sequence.
+    unsigned groupIndex = 1;
+
+    // Set storing group names that are currently in use.
+    ue2::flat_set<string> groupNames;
+
+    // Root sequence.
+    unique_ptr<ComponentSequence> rootSeq = ue2::make_unique<ComponentSequence>();
+    rootSeq->setCaptureIndex(0);
+
+    // Current sequence being appended to
+    ComponentSequence *currentSeq = rootSeq.get();
+
+    // The current character class being appended to. This is used as the
+    // accumulator for both character class and UCP properties.
+    unique_ptr<ComponentClass> currentCls;
+
+    // True if the machine is currently inside a character class, i.e. square
+    // brackets [..].
+    bool inCharClass = false;
+
+    // True if the machine is inside a character class but it has not processed
+    // any "real" elements yet, i.e. it's still processing meta-characters like
+    // '^'.
+    bool inCharClassEarly = false;
+
+    // Location at which the current character class began.
+    const u8 *currentClsBegin = p;
+
+    const u8 *ucp_start_p = p; /* for (*UCP) verb */
+
+    // We throw exceptions on various parsing failures beyond this point: we
+    // use a try/catch block here to clean up our allocated memory before we
+    // re-throw the exception to the caller.
+    try {
+        // Embed the Ragel machine here
+        
+#line 2481 "hyperscan-build/src/parser/Parser.cpp"
+	{
+	cs = regex_start;
+	top = 0;
+	ts = 0;
+	te = 0;
+	act = 0;
+	}
+
+#line 1903 "hyperscan-4.1.0/src/parser/Parser.rl"
+        
+#line 2492 "hyperscan-build/src/parser/Parser.cpp"
+	{
+	int _klen;
+	unsigned int _trans;
+	short _widec;
+	const short *_acts;
+	unsigned int _nacts;
+	const short *_keys;
+
+	if ( p == pe )
+		goto _test_eof;
+	if ( cs == 0 )
+		goto _out;
+_resume:
+	_acts = _regex_actions + _regex_from_state_actions[cs];
+	_nacts = (unsigned int) *_acts++;
+	while ( _nacts-- > 0 ) {
+		switch ( *_acts++ ) {
+	case 24:
+#line 1 "NONE"
+	{ts = p;}
+	break;
+#line 2514 "hyperscan-build/src/parser/Parser.cpp"
+		}
+	}
+
+	_widec = (*p);
+	_klen = _regex_cond_lengths[cs];
+	_keys = _regex_cond_keys + (_regex_cond_offsets[cs]*2);
+	if ( _klen > 0 ) {
+		const short *_lower = _keys;
+		const short *_mid;
+		const short *_upper = _keys + (_klen<<1) - 2;
+		while (1) {
+			if ( _upper < _lower )
+				break;
+
+			_mid = _lower + (((_upper-_lower) >> 1) & ~1);
+			if ( _widec < _mid[0] )
+				_upper = _mid - 2;
+			else if ( _widec > _mid[1] )
+				_lower = _mid + 2;
+			else {
+				switch ( _regex_cond_spaces[_regex_cond_offsets[cs] + ((_mid - _keys)>>1)] ) {
+	case 0: {
+		_widec = (short)(256u + ((*p) - 0u));
+		if ( 
+#line 476 "hyperscan-4.1.0/src/parser/Parser.rl"
+ mode.utf8  ) _widec += 256;
+		break;
+	}
+	case 1: {
+		_widec = (short)(1280u + ((*p) - 0u));
+		if ( 
+#line 477 "hyperscan-4.1.0/src/parser/Parser.rl"
+ mode.ignore_space  ) _widec += 256;
+		break;
+	}
+	case 2: {
+		_widec = (short)(768u + ((*p) - 0u));
+		if ( 
+#line 478 "hyperscan-4.1.0/src/parser/Parser.rl"
+ inCharClassEarly  ) _widec += 256;
+		break;
+	}
+				}
+				break;
+			}
+		}
+	}
+
+	_keys = _regex_trans_keys + _regex_key_offsets[cs];
+	_trans = _regex_index_offsets[cs];
+
+	_klen = _regex_single_lengths[cs];
+	if ( _klen > 0 ) {
+		const short *_lower = _keys;
+		const short *_mid;
+		const short *_upper = _keys + _klen - 1;
+		while (1) {
+			if ( _upper < _lower )
+				break;
+
+			_mid = _lower + ((_upper-_lower) >> 1);
+			if ( _widec < *_mid )
+				_upper = _mid - 1;
+			else if ( _widec > *_mid )
+				_lower = _mid + 1;
+			else {
+				_trans += (unsigned int)(_mid - _keys);
+				goto _match;
+			}
+		}
+		_keys += _klen;
+		_trans += _klen;
+	}
+
+	_klen = _regex_range_lengths[cs];
+	if ( _klen > 0 ) {
+		const short *_lower = _keys;
+		const short *_mid;
+		const short *_upper = _keys + (_klen<<1) - 2;
+		while (1) {
+			if ( _upper < _lower )
+				break;
+
+			_mid = _lower + (((_upper-_lower) >> 1) & ~1);
+			if ( _widec < _mid[0] )
+				_upper = _mid - 2;
+			else if ( _widec > _mid[1] )
+				_lower = _mid + 2;
+			else {
+				_trans += (unsigned int)((_mid - _keys)>>1);
+				goto _match;
+			}
+		}
+		_trans += _klen;
+	}
+
+_match:
+	_trans = _regex_indicies[_trans];
+_eof_trans:
+	cs = _regex_trans_targs[_trans];
+
+	if ( _regex_trans_actions[_trans] == 0 )
+		goto _again;
+
+	_acts = _regex_actions + _regex_trans_actions[_trans];
+	_nacts = (unsigned int) *_acts++;
+	while ( _nacts-- > 0 )
+	{
+		switch ( *_acts++ )
+		{
+	case 0:
+#line 286 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ label.clear();}
+	break;
+	case 1:
+#line 287 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ label.push_back((*p));}
+	break;
+	case 2:
+#line 288 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ octAccumulator = 0;}
+	break;
+	case 3:
+#line 289 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ accumulator = 0;}
+	break;
+	case 4:
+#line 290 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{
+        octAccumulator = 0;
+        pushOct(&octAccumulator, (*p));
+    }
+	break;
+	case 5:
+#line 294 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{
+        accumulator = 0;
+        pushDec(&accumulator, (*p));
+    }
+	break;
+	case 6:
+#line 298 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ repeatN = 0; repeatM = 0; }
+	break;
+	case 7:
+#line 299 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ pushDec(&repeatN, (*p)); }
+	break;
+	case 8:
+#line 300 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ pushDec(&repeatM, (*p)); }
+	break;
+	case 9:
+#line 301 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ pushOct(&octAccumulator, (*p)); }
+	break;
+	case 10:
+#line 302 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ pushDec(&accumulator, (*p)); }
+	break;
+	case 11:
+#line 303 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{
+        accumulator *= 16;
+        accumulator += (*p) - '0';
+    }
+	break;
+	case 12:
+#line 307 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{
+        accumulator *= 16;
+        accumulator += 10 + (*p) - 'a';
+    }
+	break;
+	case 13:
+#line 311 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{
+        accumulator *= 16;
+        accumulator += 10 + (*p) - 'A';
+    }
+	break;
+	case 14:
+#line 431 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{
+        newMode = mode;
+    }
+	break;
+	case 15:
+#line 438 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{
+        switch ((*p)) {
+            case 'i':
+                newMode.caseless = true;
+                break;
+            case 'm':
+                newMode.multiline = true;
+                break;
+            case 's':
+                newMode.dotall = true;
+                break;
+            case 'x':
+                newMode.ignore_space = true;
+                break;
+            default:
+                assert(0); // this action only called for [imsx]
+                break;
+        }
+    }
+	break;
+	case 16:
+#line 457 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{
+        switch ((*p)) {
+            case 'i':
+                newMode.caseless = false;
+                break;
+            case 'm':
+                newMode.multiline = false;
+                break;
+            case 's':
+                newMode.dotall = false;
+                break;
+            case 'x':
+                newMode.ignore_space = false;
+                break;
+            default:
+                assert(0); // this action only called for [imsx]
+                break;
+        }
+    }
+	break;
+	case 17:
+#line 511 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{repeatM = repeatN;}
+	break;
+	case 18:
+#line 511 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{repeatM = ComponentRepeat::NoLimit;}
+	break;
+	case 19:
+#line 724 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ negated = !negated; }
+	break;
+	case 20:
+#line 725 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ p--; {
+        DEBUG_PRINTF("stack %zu top %d\n", stack.size(), top);
+        if ((int)stack.size() == top) {
+            stack.resize(2 * (top + 1));
+        }
+    {stack[top++] = cs; cs = 784; goto _again;}} }
+	break;
+	case 21:
+#line 726 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ if (!inCharClass) { // not inside [..]
+                                 currentCls->finalize();
+                                 currentSeq->addComponent(move(currentCls));
+                             }
+                             {cs = stack[--top]; goto _again;} 
+                           }
+	break;
+	case 22:
+#line 732 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ throw LocatedParseError("Malformed property"); }
+	break;
+	case 25:
+#line 1 "NONE"
+	{te = p+1;}
+	break;
+	case 26:
+#line 551 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+            if (ts != ptr + 2) {
+                throw LocatedParseError("(*UTF8) must be at start of "
+                                        "expression, encountered");
+            }
+            mode.utf8 = true;
+            globalMode.utf8 = true; /* once you unicode, you can't stop */
+            ucp_start_p = te; /* (*UCP) can appear after us */
+            {cs = stack[--top]; goto _again;}
+        }}
+	break;
+	case 27:
+#line 561 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+            if (ts != ucp_start_p + 2) {
+                throw LocatedParseError("(*UCP) must be at start of "
+                                        "expression, encountered");
+            }
+            mode.ucp = true;
+            globalMode.ucp = true; /* once you unicode, you can't stop */
+            {cs = stack[--top]; goto _again;}
+        }}
+	break;
+	case 28:
+#line 570 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+            throw LocatedParseError("(*UTF16) not supported");
+        }}
+	break;
+	case 29:
+#line 573 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+            throw LocatedParseError("Unknown control verb");
+        }}
+	break;
+	case 30:
+#line 573 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+            throw LocatedParseError("Unknown control verb");
+        }}
+	break;
+	case 31:
+#line 573 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+            throw LocatedParseError("Unknown control verb");
+        }}
+	break;
+	case 32:
+#line 583 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_CC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 33:
+#line 584 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_CF, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 34:
+#line 585 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_CN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 35:
+#line 587 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_CS, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 36:
+#line 589 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_LL, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 37:
+#line 590 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_LM, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 38:
+#line 591 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_LO, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 39:
+#line 592 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_LT, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 40:
+#line 593 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_LU, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 41:
+#line 594 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_L_AND, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 42:
+#line 596 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_MC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 43:
+#line 598 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_MN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 44:
+#line 600 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_ND, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 45:
+#line 601 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_NL, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 46:
+#line 602 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_NO, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 47:
+#line 604 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_PC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 48:
+#line 605 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_PD, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 49:
+#line 606 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_PE, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 50:
+#line 607 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_PF, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 51:
+#line 608 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_PI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 52:
+#line 609 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_PO, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 53:
+#line 610 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_PS, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 54:
+#line 612 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_SC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 55:
+#line 613 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_SK, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 56:
+#line 614 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_SM, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 57:
+#line 615 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_SO, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 58:
+#line 617 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_ZL, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 59:
+#line 618 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_ZP, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 60:
+#line 619 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_ZS, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 61:
+#line 620 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_XAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 62:
+#line 621 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_XPS, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 63:
+#line 622 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_XSP, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 64:
+#line 623 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_XWD, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 65:
+#line 624 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_ARABIC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 66:
+#line 625 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_ARMENIAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 67:
+#line 626 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_AVESTAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 68:
+#line 627 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_BALINESE, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 69:
+#line 628 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_BAMUM, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 70:
+#line 629 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_BATAK, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 71:
+#line 630 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_BENGALI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 72:
+#line 631 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_BOPOMOFO, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 73:
+#line 632 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_BRAHMI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 74:
+#line 633 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_BRAILLE, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 75:
+#line 634 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_BUGINESE, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 76:
+#line 635 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_BUHID, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 77:
+#line 636 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_CANADIAN_ABORIGINAL, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 78:
+#line 637 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_CARIAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 79:
+#line 638 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_CHAM, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 80:
+#line 639 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_CHEROKEE, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 81:
+#line 640 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_COMMON, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 82:
+#line 641 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_COPTIC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 83:
+#line 642 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_CUNEIFORM, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 84:
+#line 643 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_CYPRIOT, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 85:
+#line 644 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_CYRILLIC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 86:
+#line 645 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_DESERET, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 87:
+#line 646 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_DEVANAGARI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 88:
+#line 647 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_EGYPTIAN_HIEROGLYPHS, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 89:
+#line 648 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_ETHIOPIC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 90:
+#line 649 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_GEORGIAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 91:
+#line 650 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_GLAGOLITIC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 92:
+#line 651 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_GOTHIC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 93:
+#line 652 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_GREEK, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 94:
+#line 653 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_GUJARATI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 95:
+#line 654 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_GURMUKHI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 96:
+#line 656 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_HANGUL, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 97:
+#line 657 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_HANUNOO, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 98:
+#line 658 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_HEBREW, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 99:
+#line 659 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_HIRAGANA, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 100:
+#line 660 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_IMPERIAL_ARAMAIC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 101:
+#line 661 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_INHERITED, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 102:
+#line 662 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_INSCRIPTIONAL_PAHLAVI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 103:
+#line 663 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_INSCRIPTIONAL_PARTHIAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 104:
+#line 664 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_JAVANESE, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 105:
+#line 665 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_KAITHI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 106:
+#line 666 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_KANNADA, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 107:
+#line 667 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_KATAKANA, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 108:
+#line 668 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_KAYAH_LI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 109:
+#line 669 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_KHAROSHTHI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 110:
+#line 670 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_KHMER, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 111:
+#line 671 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_LAO, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 112:
+#line 672 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_LATIN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 113:
+#line 673 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_LEPCHA, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 114:
+#line 674 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_LIMBU, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 115:
+#line 675 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_LINEAR_B, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 116:
+#line 676 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_LISU, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 117:
+#line 677 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_LYCIAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 118:
+#line 678 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_LYDIAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 119:
+#line 679 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_MALAYALAM, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 120:
+#line 680 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_MANDAIC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 121:
+#line 681 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_MEETEI_MAYEK, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 122:
+#line 682 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_MONGOLIAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 123:
+#line 683 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_MYANMAR, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 124:
+#line 684 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_NEW_TAI_LUE, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 125:
+#line 685 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_NKO, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 126:
+#line 686 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_OGHAM, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 127:
+#line 687 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_OL_CHIKI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 128:
+#line 688 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_OLD_ITALIC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 129:
+#line 689 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_OLD_PERSIAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 130:
+#line 690 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_OLD_SOUTH_ARABIAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 131:
+#line 691 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_OLD_TURKIC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 132:
+#line 692 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_ORIYA, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 133:
+#line 693 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_OSMANYA, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 134:
+#line 694 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_PHAGS_PA, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 135:
+#line 695 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_PHOENICIAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 136:
+#line 696 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_REJANG, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 137:
+#line 697 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_RUNIC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 138:
+#line 698 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_SAMARITAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 139:
+#line 699 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_SAURASHTRA, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 140:
+#line 700 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_SHAVIAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 141:
+#line 701 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_SINHALA, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 142:
+#line 702 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_SUNDANESE, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 143:
+#line 703 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_SYLOTI_NAGRI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 144:
+#line 704 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_SYRIAC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 145:
+#line 705 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_TAGALOG, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 146:
+#line 706 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_TAGBANWA, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 147:
+#line 707 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_TAI_LE, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 148:
+#line 708 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_TAI_THAM, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 149:
+#line 709 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_TAI_VIET, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 150:
+#line 710 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_TAMIL, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 151:
+#line 711 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_TELUGU, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 152:
+#line 712 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_THAANA, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 153:
+#line 713 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_THAI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 154:
+#line 714 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_TIBETAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 155:
+#line 715 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_TIFINAGH, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 156:
+#line 716 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_UGARITIC, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 157:
+#line 717 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_VAI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 158:
+#line 718 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_SCRIPT_YI, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 159:
+#line 719 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ currentCls->add(CLASS_UCP_ANY, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 160:
+#line 720 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ throw LocatedParseError("Unknown property"); }}
+	break;
+	case 161:
+#line 582 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ currentCls->add(CLASS_UCP_C, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 162:
+#line 586 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ currentCls->add(CLASS_UCP_CO, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 163:
+#line 588 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ currentCls->add(CLASS_UCP_L, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 164:
+#line 595 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ currentCls->add(CLASS_UCP_M, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 165:
+#line 597 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ currentCls->add(CLASS_UCP_ME, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 166:
+#line 599 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ currentCls->add(CLASS_UCP_N, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 167:
+#line 603 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ currentCls->add(CLASS_UCP_P, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 168:
+#line 611 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ currentCls->add(CLASS_UCP_S, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 169:
+#line 616 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ currentCls->add(CLASS_UCP_Z, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 170:
+#line 655 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ currentCls->add(CLASS_SCRIPT_HAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 171:
+#line 720 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ throw LocatedParseError("Unknown property"); }}
+	break;
+	case 172:
+#line 582 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{ currentCls->add(CLASS_UCP_C, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 173:
+#line 586 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{ currentCls->add(CLASS_UCP_CO, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 174:
+#line 588 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{ currentCls->add(CLASS_UCP_L, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 175:
+#line 595 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{ currentCls->add(CLASS_UCP_M, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 176:
+#line 597 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{ currentCls->add(CLASS_UCP_ME, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 177:
+#line 599 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{ currentCls->add(CLASS_UCP_N, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 178:
+#line 603 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{ currentCls->add(CLASS_UCP_P, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 179:
+#line 611 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{ currentCls->add(CLASS_UCP_S, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 180:
+#line 655 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{ currentCls->add(CLASS_SCRIPT_HAN, negated); {cs = stack[--top]; goto _again;} }}
+	break;
+	case 181:
+#line 720 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{ throw LocatedParseError("Unknown property"); }}
+	break;
+	case 182:
+#line 735 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ 
+            currentCls->add(CLASS_UCP_C, negated); 
+            if (!inCharClass) {
+                currentCls->finalize();
+                currentSeq->addComponent(move(currentCls));
+            }
+            {cs = stack[--top]; goto _again;} 
+        }}
+	break;
+	case 183:
+#line 743 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ 
+            currentCls->add(CLASS_UCP_L, negated); 
+            if (!inCharClass) {
+                currentCls->finalize();
+                currentSeq->addComponent(move(currentCls));
+            }
+            {cs = stack[--top]; goto _again;} 
+        }}
+	break;
+	case 184:
+#line 751 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ 
+            currentCls->add(CLASS_UCP_M, negated); 
+            if (!inCharClass) {
+                currentCls->finalize();
+                currentSeq->addComponent(move(currentCls));
+            }
+            {cs = stack[--top]; goto _again;} 
+        }}
+	break;
+	case 185:
+#line 759 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+            currentCls->add(CLASS_UCP_N, negated); 
+            if (!inCharClass) {
+                currentCls->finalize();
+                currentSeq->addComponent(move(currentCls));
+            }
+            {cs = stack[--top]; goto _again;}
+        }}
+	break;
+	case 186:
+#line 767 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ 
+            currentCls->add(CLASS_UCP_P, negated); 
+            if (!inCharClass) {
+                currentCls->finalize();
+                currentSeq->addComponent(move(currentCls));
+            }
+            {cs = stack[--top]; goto _again;} 
+        }}
+	break;
+	case 187:
+#line 775 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ 
+            currentCls->add(CLASS_UCP_S, negated); 
+            if (!inCharClass) {
+                currentCls->finalize();
+                currentSeq->addComponent(move(currentCls));
+            }
+            {cs = stack[--top]; goto _again;} 
+        }}
+	break;
+	case 188:
+#line 783 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ 
+            currentCls->add(CLASS_UCP_Z, negated); 
+            if (!inCharClass) {
+                currentCls->finalize();
+                currentSeq->addComponent(move(currentCls));
+            }
+            {cs = stack[--top]; goto _again;} 
+        }}
+	break;
+	case 189:
+#line 792 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ throw LocatedParseError("Unknown property"); }}
+	break;
+	case 190:
+#line 798 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  throw LocatedParseError("Unsupported POSIX collating "
+                                          "element");
+              }}
+	break;
+	case 191:
+#line 805 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_ALNUM, false);
+              }}
+	break;
+	case 192:
+#line 808 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_ALNUM, true);
+              }}
+	break;
+	case 193:
+#line 811 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_ALPHA, false);
+              }}
+	break;
+	case 194:
+#line 814 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_ALPHA, true);
+              }}
+	break;
+	case 195:
+#line 817 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_ASCII, false);
+              }}
+	break;
+	case 196:
+#line 820 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_ASCII, true);
+              }}
+	break;
+	case 197:
+#line 823 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_BLANK, false);
+              }}
+	break;
+	case 198:
+#line 826 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_BLANK, true);
+              }}
+	break;
+	case 199:
+#line 829 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_CNTRL, false);
+              }}
+	break;
+	case 200:
+#line 832 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_CNTRL, true);
+              }}
+	break;
+	case 201:
+#line 835 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_DIGIT, false);
+              }}
+	break;
+	case 202:
+#line 838 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_DIGIT, true);
+              }}
+	break;
+	case 203:
+#line 841 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_GRAPH, false);
+              }}
+	break;
+	case 204:
+#line 844 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_GRAPH, true);
+              }}
+	break;
+	case 205:
+#line 847 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_LOWER, false);
+              }}
+	break;
+	case 206:
+#line 850 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_LOWER, true);
+              }}
+	break;
+	case 207:
+#line 853 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_PRINT, false);
+              }}
+	break;
+	case 208:
+#line 856 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_PRINT, true);
+              }}
+	break;
+	case 209:
+#line 859 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_PUNCT, false);
+              }}
+	break;
+	case 210:
+#line 862 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_PUNCT, true);
+              }}
+	break;
+	case 211:
+#line 866 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_SPACE, false);
+              }}
+	break;
+	case 212:
+#line 869 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_SPACE, true);
+              }}
+	break;
+	case 213:
+#line 872 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_UPPER, false);
+              }}
+	break;
+	case 214:
+#line 875 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_UPPER, true);
+              }}
+	break;
+	case 215:
+#line 878 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_WORD, false);
+              }}
+	break;
+	case 216:
+#line 881 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_WORD, true);
+              }}
+	break;
+	case 217:
+#line 884 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_XDIGIT, false);
+              }}
+	break;
+	case 218:
+#line 887 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_XDIGIT, true);
+              }}
+	break;
+	case 219:
+#line 892 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  throw LocatedParseError("Invalid POSIX named class");
+              }}
+	break;
+	case 220:
+#line 895 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  {
+        DEBUG_PRINTF("stack %zu top %d\n", stack.size(), top);
+        if ((int)stack.size() == top) {
+            stack.resize(2 * (top + 1));
+        }
+    {stack[top++] = cs; cs = 834; goto _again;}}
+              }}
+	break;
+	case 221:
+#line 898 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ /*noop*/}}
+	break;
+	case 222:
+#line 900 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add('\x08');
+              }}
+	break;
+	case 223:
+#line 904 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add('\x09');
+              }}
+	break;
+	case 224:
+#line 908 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add('\x0a');
+              }}
+	break;
+	case 225:
+#line 912 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add('\x0d');
+              }}
+	break;
+	case 226:
+#line 916 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add('\x0c');
+              }}
+	break;
+	case 227:
+#line 920 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add('\x07');
+              }}
+	break;
+	case 228:
+#line 924 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add('\x1b');
+              }}
+	break;
+	case 229:
+#line 928 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_HORZ, false);
+              }}
+	break;
+	case 230:
+#line 932 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_HORZ, true);
+              }}
+	break;
+	case 231:
+#line 936 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_VERT, false);
+              }}
+	break;
+	case 232:
+#line 940 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_VERT, true);
+              }}
+	break;
+	case 233:
+#line 944 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  negated = false;
+                  p--;
+                  {
+        DEBUG_PRINTF("stack %zu top %d\n", stack.size(), top);
+        if ((int)stack.size() == top) {
+            stack.resize(2 * (top + 1));
+        }
+    {stack[top++] = cs; cs = 560; goto _again;}}
+              }}
+	break;
+	case 234:
+#line 950 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  negated = false;
+                  p--;
+                  {
+        DEBUG_PRINTF("stack %zu top %d\n", stack.size(), top);
+        if ((int)stack.size() == top) {
+            stack.resize(2 * (top + 1));
+        }
+    {stack[top++] = cs; cs = 812; goto _again;}}
+              }}
+	break;
+	case 235:
+#line 956 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  negated = true;
+                  p--;
+                  {
+        DEBUG_PRINTF("stack %zu top %d\n", stack.size(), top);
+        if ((int)stack.size() == top) {
+            stack.resize(2 * (top + 1));
+        }
+    {stack[top++] = cs; cs = 560; goto _again;}}
+              }}
+	break;
+	case 236:
+#line 962 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  negated = true;
+                  p--;
+                  {
+        DEBUG_PRINTF("stack %zu top %d\n", stack.size(), top);
+        if ((int)stack.size() == top) {
+            stack.resize(2 * (top + 1));
+        }
+    {stack[top++] = cs; cs = 812; goto _again;}}
+              }}
+	break;
+	case 237:
+#line 972 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(octAccumulator);
+              }}
+	break;
+	case 238:
+#line 975 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(octAccumulator);
+              }}
+	break;
+	case 239:
+#line 979 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  string oct((const char *)ts + 3, te - ts - 4);
+                  long int val = strtol(oct.c_str(), nullptr, 8);
+                  if ((!mode.utf8 && val > 255) || val > MAX_UNICODE) {
+                      throw LocatedParseError("Value in \\o{...} sequence is too large");
+                  }
+                  currentCls->add((unichar)val);
+              }}
+	break;
+	case 240:
+#line 994 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(accumulator);
+              }}
+	break;
+	case 241:
+#line 998 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  // whatever we found here
+                  currentCls->add(*(ts + 1));
+
+              }}
+	break;
+	case 242:
+#line 1004 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  string hex((const char *)ts + 3, te - ts - 4);
+                  long int val = strtol(hex.c_str(), nullptr, 16);
+                  if (val > MAX_UNICODE) {
+                      throw LocatedParseError("Value in \\x{...} sequence is too large");
+                  }
+                  currentCls->add((unichar)val);
+              }}
+	break;
+	case 243:
+#line 1017 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  if (te - ts < 3) {
+                      assert(te - ts == 2);
+                      throw LocatedParseError(SLASH_C_ERROR);
+                  } else {
+                      assert(te - ts == 3);
+                      currentCls->add(decodeCtrl(ts[2]));
+                  }
+              }}
+	break;
+	case 244:
+#line 1027 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_WORD, false);
+              }}
+	break;
+	case 245:
+#line 1031 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_WORD, true);
+              }}
+	break;
+	case 246:
+#line 1035 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_SPACE, false);
+              }}
+	break;
+	case 247:
+#line 1039 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_SPACE, true);
+              }}
+	break;
+	case 248:
+#line 1043 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_DIGIT, false);
+              }}
+	break;
+	case 249:
+#line 1047 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(CLASS_DIGIT, true);
+              }}
+	break;
+	case 250:
+#line 1050 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->addDash();
+              }}
+	break;
+	case 251:
+#line 277 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        ostringstream str;
+        str << "'\\" << (char)*(ts + 1) << "' at index "
+            << ts - ptr << " not supported in a character class.";
+        throw ParseError(str.str());
+    }}
+	break;
+	case 252:
+#line 277 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        ostringstream str;
+        str << "'\\" << (char)*(ts + 1) << "' at index "
+            << ts - ptr << " not supported in a character class.";
+        throw ParseError(str.str());
+    }}
+	break;
+	case 253:
+#line 277 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        ostringstream str;
+        str << "'\\" << (char)*(ts + 1) << "' at index "
+            << ts - ptr << " not supported in a character class.";
+        throw ParseError(str.str());
+    }}
+	break;
+	case 254:
+#line 1067 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  // add the literal char
+                  currentCls->add(*(ts + 1));
+              }}
+	break;
+	case 255:
+#line 1073 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  assert(mode.utf8);
+                  currentCls->add(readUtf8CodePoint2c(ts));
+              }}
+	break;
+	case 256:
+#line 1078 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  assert(mode.utf8);
+                  currentCls->add(readUtf8CodePoint3c(ts));
+              }}
+	break;
+	case 257:
+#line 1083 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  assert(mode.utf8);
+                  currentCls->add(readUtf8CodePoint4c(ts));
+              }}
+	break;
+	case 258:
+#line 1088 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  assert(mode.utf8);
+                  throwInvalidUtf8();
+              }}
+	break;
+	case 259:
+#line 1094 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(*ts);
+              }}
+	break;
+	case 260:
+#line 1098 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->finalize();
+                  currentSeq->addComponent(move(currentCls));
+                  inCharClass = false;
+                  {cs = 741; goto _again;}
+              }}
+	break;
+	case 261:
+#line 968 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ throw LocatedParseError("Malformed property"); }}
+	break;
+	case 262:
+#line 969 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ throw LocatedParseError("Malformed property"); }}
+	break;
+	case 263:
+#line 972 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  currentCls->add(octAccumulator);
+              }}
+	break;
+	case 264:
+#line 975 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  currentCls->add(octAccumulator);
+              }}
+	break;
+	case 265:
+#line 989 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  throw LocatedParseError("Value in \\o{...} sequence is non-octal or missing braces");
+              }}
+	break;
+	case 266:
+#line 994 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  currentCls->add(accumulator);
+              }}
+	break;
+	case 267:
+#line 1013 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  throw LocatedParseError("Value in \\x{...} sequence is non-hex or missing }");
+              }}
+	break;
+	case 268:
+#line 1017 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  if (te - ts < 3) {
+                      assert(te - ts == 2);
+                      throw LocatedParseError(SLASH_C_ERROR);
+                  } else {
+                      assert(te - ts == 3);
+                      currentCls->add(decodeCtrl(ts[2]));
+                  }
+              }}
+	break;
+	case 269:
+#line 1088 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  assert(mode.utf8);
+                  throwInvalidUtf8();
+              }}
+	break;
+	case 270:
+#line 1094 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  currentCls->add(*ts);
+              }}
+	break;
+	case 271:
+#line 989 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+                  throw LocatedParseError("Value in \\o{...} sequence is non-octal or missing braces");
+              }}
+	break;
+	case 272:
+#line 1013 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+                  throw LocatedParseError("Value in \\x{...} sequence is non-hex or missing }");
+              }}
+	break;
+	case 273:
+#line 1088 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+                  assert(mode.utf8);
+                  throwInvalidUtf8();
+              }}
+	break;
+	case 274:
+#line 1094 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+                  currentCls->add(*ts);
+              }}
+	break;
+	case 275:
+#line 1112 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+            if (currentCls->isNegated()) {
+                // Already seen a caret; the second one is not a meta-character.
+                inCharClassEarly = false;
+                p--; {cs = 813; goto _again;}
+            } else {
+                currentCls->negate();
+                // Note: we cannot switch off inCharClassEarly here, as /[^]]/
+                // needs to use the right square bracket path below.
+            }
+        }}
+	break;
+	case 276:
+#line 1125 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+            currentCls->add(']');
+            inCharClassEarly = false;
+        }}
+	break;
+	case 277:
+#line 1130 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ {
+        DEBUG_PRINTF("stack %zu top %d\n", stack.size(), top);
+        if ((int)stack.size() == top) {
+            stack.resize(2 * (top + 1));
+        }
+    {stack[top++] = cs; cs = 834; goto _again;}} }}
+	break;
+	case 278:
+#line 1131 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ /*noop*/}}
+	break;
+	case 279:
+#line 1134 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+            inCharClassEarly = false;
+            p--;
+            {cs = 813; goto _again;}
+        }}
+	break;
+	case 280:
+#line 1134 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+            inCharClassEarly = false;
+            p--;
+            {cs = 813; goto _again;}
+        }}
+	break;
+	case 281:
+#line 1146 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  {cs = 741; goto _again;}
+              }}
+	break;
+	case 282:
+#line 1150 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  addLiteral(currentSeq, *ts, mode);
+              }}
+	break;
+	case 283:
+#line 1150 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  addLiteral(currentSeq, *ts, mode);
+              }}
+	break;
+	case 284:
+#line 1160 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  {cs = stack[--top]; goto _again;}
+              }}
+	break;
+	case 285:
+#line 1164 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentCls->add(*ts);
+                  inCharClassEarly = false;
+              }}
+	break;
+	case 286:
+#line 1164 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  currentCls->add(*ts);
+                  inCharClassEarly = false;
+              }}
+	break;
+	case 287:
+#line 1176 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ inComment = false; {cs = 741; goto _again;} }}
+	break;
+	case 288:
+#line 1180 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;}
+	break;
+	case 289:
+#line 1188 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ inComment = false; {cs = 741; goto _again;} }}
+	break;
+	case 290:
+#line 1192 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;}
+	break;
+	case 291:
+#line 1425 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{act = 279;}
+	break;
+	case 292:
+#line 1442 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{act = 281;}
+	break;
+	case 293:
+#line 1661 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{act = 321;}
+	break;
+	case 294:
+#line 363 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        if (sequences.empty()) {
+            throw LocatedParseError("Unmatched parentheses");
+        }
+        currentSeq->finalize();
+        POP_SEQUENCE;
+    }}
+	break;
+	case 295:
+#line 1207 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentSeq->addAlternation();
+              }}
+	break;
+	case 296:
+#line 1212 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  throw LocatedParseError("POSIX named classes are only "
+                                          "supported inside a class");
+              }}
+	break;
+	case 297:
+#line 1219 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  throw LocatedParseError("Unsupported POSIX collating "
+                                          "element");
+              }}
+	break;
+	case 298:
+#line 1226 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  {cs = 832; goto _again;}
+              }}
+	break;
+	case 299:
+#line 1229 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  throw LocatedParseError("Unmatched \\E");
+              }}
+	break;
+	case 300:
+#line 1233 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentSeq->addComponent(generateComponent(CLASS_ANY, false, mode));
+              }}
+	break;
+	case 301:
+#line 1237 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  if (mode.utf8) {
+                      throw LocatedParseError("\\C is unsupported in UTF8");
+                  }
+                  currentSeq->addComponent(ue2::make_unique<ComponentByte>());
+              }}
+	break;
+	case 302:
+#line 1251 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  if (!currentSeq->addRepeat(0, ComponentRepeat::NoLimit,
+                                        ComponentRepeat::REPEAT_NONGREEDY)) {
+                      throwInvalidRepeat();
+                  }
+              }}
+	break;
+	case 303:
+#line 1258 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  if (!currentSeq->addRepeat(0, ComponentRepeat::NoLimit,
+                                        ComponentRepeat::REPEAT_POSSESSIVE)) {
+                      throwInvalidRepeat();
+                  }
+              }}
+	break;
+	case 304:
+#line 1272 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  if (!currentSeq->addRepeat(1, ComponentRepeat::NoLimit,
+                                        ComponentRepeat::REPEAT_NONGREEDY)) {
+                      throwInvalidRepeat();
+                  }
+              }}
+	break;
+	case 305:
+#line 1279 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  if (!currentSeq->addRepeat(1, ComponentRepeat::NoLimit,
+                                        ComponentRepeat::REPEAT_POSSESSIVE)) {
+                      throwInvalidRepeat();
+                  }
+              }}
+	break;
+	case 306:
+#line 1293 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  if (!currentSeq->addRepeat(
+                           0, 1, ComponentRepeat::REPEAT_NONGREEDY)) {
+                      throwInvalidRepeat();
+                  }
+              }}
+	break;
+	case 307:
+#line 1300 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  if (!currentSeq->addRepeat(
+                           0, 1, ComponentRepeat::REPEAT_POSSESSIVE)) {
+                      throwInvalidRepeat();
+                  }
+              }}
+	break;
+	case 308:
+#line 1317 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  if (repeatN > repeatM || repeatM == 0) {
+                      throwInvalidRepeat();
+                  } else if (!currentSeq->addRepeat(
+                                  repeatN, repeatM,
+                                  ComponentRepeat::REPEAT_NONGREEDY)) {
+                      throwInvalidRepeat();
+                  }
+              }}
+	break;
+	case 309:
+#line 1327 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  if (repeatN > repeatM || repeatM == 0) {
+                      throwInvalidRepeat();
+                  } else if (!currentSeq->addRepeat(
+                                  repeatN, repeatM,
+                                  ComponentRepeat::REPEAT_POSSESSIVE)) {
+                      throwInvalidRepeat();
+                  }
+              }}
+	break;
+	case 310:
+#line 323 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        inComment = true;
+        {cs = 837; goto _again;}
+    }}
+	break;
+	case 311:
+#line 1344 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ p--; {
+        DEBUG_PRINTF("stack %zu top %d\n", stack.size(), top);
+        if ((int)stack.size() == top) {
+            stack.resize(2 * (top + 1));
+        }
+    {stack[top++] = cs; cs = 782; goto _again;}} }}
+	break;
+	case 312:
+#line 1348 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ assert(0); {p++; goto _out; } }}
+	break;
+	case 313:
+#line 1355 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto bound = mode.multiline ? ComponentBoundary::BEGIN_LINE
+                                              : ComponentBoundary::BEGIN_STRING;
+                  currentSeq->addComponent(ue2::make_unique<ComponentBoundary>(bound));
+              }}
+	break;
+	case 314:
+#line 1362 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto bound = mode.multiline ? ComponentBoundary::END_LINE
+                                              : ComponentBoundary::END_STRING_OPTIONAL_LF;
+                  currentSeq->addComponent(ue2::make_unique<ComponentBoundary>(bound));
+              }}
+	break;
+	case 315:
+#line 1368 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto bound = ComponentBoundary::BEGIN_STRING;
+                  currentSeq->addComponent(ue2::make_unique<ComponentBoundary>(bound));
+              }}
+	break;
+	case 316:
+#line 1373 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto bound = ComponentBoundary::END_STRING_OPTIONAL_LF;
+                  currentSeq->addComponent(ue2::make_unique<ComponentBoundary>(bound));
+              }}
+	break;
+	case 317:
+#line 1378 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto bound = ComponentBoundary::END_STRING;
+                  currentSeq->addComponent(ue2::make_unique<ComponentBoundary>(bound));
+              }}
+	break;
+	case 318:
+#line 1383 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentSeq->addComponent(
+                      ue2::make_unique<ComponentWordBoundary>(ts - ptr, false, mode));
+              }}
+	break;
+	case 319:
+#line 1388 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentSeq->addComponent(
+                      ue2::make_unique<ComponentWordBoundary>(ts - ptr, true, mode));
+              }}
+	break;
+	case 320:
+#line 1398 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  addLiteral(currentSeq, '\x09', mode);
+              }}
+	break;
+	case 321:
+#line 1402 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  addLiteral(currentSeq, '\x0a', mode);
+              }}
+	break;
+	case 322:
+#line 1406 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  addLiteral(currentSeq, '\x0d', mode);
+              }}
+	break;
+	case 323:
+#line 1410 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  addLiteral(currentSeq, '\x0c', mode);
+              }}
+	break;
+	case 324:
+#line 1414 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  addLiteral(currentSeq, '\x07', mode);
+              }}
+	break;
+	case 325:
+#line 1418 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  addLiteral(currentSeq, '\x1b', mode);
+              }}
+	break;
+	case 326:
+#line 1422 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  addLiteral(currentSeq, octAccumulator, mode);
+              }}
+	break;
+	case 327:
+#line 480 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        if (accumulator == 0) {
+            throw LocatedParseError("Numbered reference cannot be zero");
+        }
+        currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(accumulator));
+    }}
+	break;
+	case 328:
+#line 487 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        // Accumulator is a negative offset.
+        if (accumulator == 0) {
+            throw LocatedParseError("Numbered reference cannot be zero");
+        }
+        if (accumulator >= groupIndex) {
+            throw LocatedParseError("Invalid reference");
+        }
+        unsigned idx = groupIndex - accumulator;
+        currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(idx));
+    }}
+	break;
+	case 329:
+#line 480 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        if (accumulator == 0) {
+            throw LocatedParseError("Numbered reference cannot be zero");
+        }
+        currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(accumulator));
+    }}
+	break;
+	case 330:
+#line 487 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        // Accumulator is a negative offset.
+        if (accumulator == 0) {
+            throw LocatedParseError("Numbered reference cannot be zero");
+        }
+        if (accumulator >= groupIndex) {
+            throw LocatedParseError("Invalid reference");
+        }
+        unsigned idx = groupIndex - accumulator;
+        currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(idx));
+    }}
+	break;
+	case 331:
+#line 499 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(label));
+    }}
+	break;
+	case 332:
+#line 499 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(label));
+    }}
+	break;
+	case 333:
+#line 499 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(label));
+    }}
+	break;
+	case 334:
+#line 499 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(label));
+    }}
+	break;
+	case 335:
+#line 499 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(label));
+    }}
+	break;
+	case 336:
+#line 1483 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  ostringstream str;
+                  str << "Onigiruma subroutine call at index " << ts - ptr <<
+                         " not supported.";
+                  throw ParseError(str.str());
+              }}
+	break;
+	case 337:
+#line 1494 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  string oct((const char *)ts + 3, te - ts - 4);
+                  long int val = strtol(oct.c_str(), nullptr, 8);
+                  if ((!mode.utf8 && val > 255) || val > MAX_UNICODE) {
+                      throw LocatedParseError("Value in \\o{...} sequence is too large");
+                  }
+                  addEscapedOctal(currentSeq, (unichar)val, mode);
+              }}
+	break;
+	case 338:
+#line 1507 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  addEscapedHex(currentSeq, accumulator, mode);
+              }}
+	break;
+	case 339:
+#line 1511 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  string hex((const char *)ts + 3, te - ts - 4);
+                  long int val = strtol(hex.c_str(), nullptr, 16);
+                  if (val > MAX_UNICODE) {
+                      throw LocatedParseError("Value in \\x{...} sequence is too large");
+                  }
+                  addEscapedHex(currentSeq, (unichar)val, mode);
+              }}
+	break;
+	case 340:
+#line 1524 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  if (te - ts < 3) {
+                      assert(te - ts == 2);
+                      throw LocatedParseError(SLASH_C_ERROR);
+                  } else {
+                      assert(te - ts == 3);
+                      addLiteral(currentSeq, decodeCtrl(ts[2]), mode);
+                  }
+              }}
+	break;
+	case 341:
+#line 1534 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  ostringstream str;
+                  str << "'\\" << (char)*(ts + 1) << "' at index "
+                      << ts - ptr << " not supported.";
+                  throw ParseError(str.str());
+              }}
+	break;
+	case 342:
+#line 1542 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto cc = generateComponent(CLASS_WORD, false, mode);
+                  currentSeq->addComponent(move(cc));
+              }}
+	break;
+	case 343:
+#line 1547 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto cc = generateComponent(CLASS_WORD, true, mode);
+                  currentSeq->addComponent(move(cc));
+              }}
+	break;
+	case 344:
+#line 1552 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto cc = generateComponent(CLASS_SPACE, false, mode);
+                  currentSeq->addComponent(move(cc));
+              }}
+	break;
+	case 345:
+#line 1557 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto cc = generateComponent(CLASS_SPACE, true, mode);
+                  currentSeq->addComponent(move(cc));
+              }}
+	break;
+	case 346:
+#line 1562 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto cc = generateComponent(CLASS_DIGIT, false, mode);
+                  currentSeq->addComponent(move(cc));
+              }}
+	break;
+	case 347:
+#line 1567 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto cc = generateComponent(CLASS_DIGIT, true, mode);
+                  currentSeq->addComponent(move(cc));
+              }}
+	break;
+	case 348:
+#line 1572 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto cc = generateComponent(CLASS_HORZ, false, mode);
+                  currentSeq->addComponent(move(cc));
+              }}
+	break;
+	case 349:
+#line 1577 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto cc = generateComponent(CLASS_HORZ, true, mode);
+                  currentSeq->addComponent(move(cc));
+              }}
+	break;
+	case 350:
+#line 1582 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto cc = generateComponent(CLASS_VERT, false, mode);
+                  currentSeq->addComponent(move(cc));
+              }}
+	break;
+	case 351:
+#line 1587 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto cc = generateComponent(CLASS_VERT, true, mode);
+                  currentSeq->addComponent(move(cc));
+              }}
+	break;
+	case 352:
+#line 1592 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  assert(!currentCls && !inCharClass);
+                  currentCls = getComponentClass(mode);
+                  negated = false;
+                  p--;
+                  {
+        DEBUG_PRINTF("stack %zu top %d\n", stack.size(), top);
+        if ((int)stack.size() == top) {
+            stack.resize(2 * (top + 1));
+        }
+    {stack[top++] = cs; cs = 560; goto _again;}}
+              }}
+	break;
+	case 353:
+#line 1600 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  assert(!currentCls && !inCharClass);
+                  currentCls = getComponentClass(mode);
+                  negated = false;
+                  p--;
+                  {
+        DEBUG_PRINTF("stack %zu top %d\n", stack.size(), top);
+        if ((int)stack.size() == top) {
+            stack.resize(2 * (top + 1));
+        }
+    {stack[top++] = cs; cs = 812; goto _again;}}
+              }}
+	break;
+	case 354:
+#line 1608 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  assert(!currentCls && !inCharClass);
+                  currentCls = getComponentClass(mode);
+                  negated = true;
+                  p--;
+                  {
+        DEBUG_PRINTF("stack %zu top %d\n", stack.size(), top);
+        if ((int)stack.size() == top) {
+            stack.resize(2 * (top + 1));
+        }
+    {stack[top++] = cs; cs = 560; goto _again;}}
+              }}
+	break;
+	case 355:
+#line 1616 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  assert(!currentCls && !inCharClass);
+                  currentCls = getComponentClass(mode);
+                  negated = true;
+                  p--;
+                  {
+        DEBUG_PRINTF("stack %zu top %d\n", stack.size(), top);
+        if ((int)stack.size() == top) {
+            stack.resize(2 * (top + 1));
+        }
+    {stack[top++] = cs; cs = 812; goto _again;}}
+              }}
+	break;
+	case 356:
+#line 1628 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  ostringstream str;
+                  str << "\\R at index " << ts - ptr << " not supported.";
+                  throw ParseError(str.str());
+              }}
+	break;
+	case 357:
+#line 1635 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  ostringstream str;
+                  str << "\\K at index " << ts - ptr << " not supported.";
+                  throw ParseError(str.str());
+              }}
+	break;
+	case 358:
+#line 1650 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  ostringstream str;
+                  str << "\\G at index " << ts - ptr << " not supported.";
+                  throw ParseError(str.str());
+              }}
+	break;
+	case 359:
+#line 1656 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  currentSeq->addComponent(ue2::make_unique<ComponentEUS>(ts - ptr, mode));
+              }}
+	break;
+	case 360:
+#line 1661 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  addLiteral(currentSeq, *(ts + 1), mode);
+              }}
+	break;
+	case 361:
+#line 317 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{ 
+        inComment = true;
+        {cs = 836; goto _again;}
+    }}
+	break;
+	case 362:
+#line 434 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        mode = newMode;
+        currentSeq->addComponent(ue2::make_unique<ComponentEmpty>());
+    }}
+	break;
+	case 363:
+#line 356 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        PUSH_SEQUENCE;
+        mode = newMode;
+        currentSeq =
+            enterSequence(currentSeq, ue2::make_unique<ComponentSequence>());
+    }}
+	break;
+	case 364:
+#line 370 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        PUSH_SEQUENCE;
+        currentSeq = enterSequence(currentSeq,
+            ue2::make_unique<ComponentAssertion>(ComponentAssertion::LOOKAHEAD,
+                                                 ComponentAssertion::POS));
+    }}
+	break;
+	case 365:
+#line 376 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        PUSH_SEQUENCE;
+        currentSeq = enterSequence(currentSeq,
+            ue2::make_unique<ComponentAssertion>(ComponentAssertion::LOOKAHEAD,
+                                                 ComponentAssertion::NEG));
+    }}
+	break;
+	case 366:
+#line 382 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        PUSH_SEQUENCE;
+        currentSeq = enterSequence(currentSeq,
+            ue2::make_unique<ComponentAssertion>(ComponentAssertion::LOOKBEHIND,
+                                                 ComponentAssertion::POS));
+    }}
+	break;
+	case 367:
+#line 388 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        PUSH_SEQUENCE;
+        currentSeq = enterSequence(currentSeq,
+            ue2::make_unique<ComponentAssertion>(ComponentAssertion::LOOKBEHIND,
+                                                 ComponentAssertion::NEG));
+    }}
+	break;
+	case 368:
+#line 394 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        throw LocatedParseError("Embedded code is not supported");
+    }}
+	break;
+	case 369:
+#line 394 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        throw LocatedParseError("Embedded code is not supported");
+    }}
+	break;
+	case 370:
+#line 417 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        PUSH_SEQUENCE;
+        currentSeq = enterSequence(currentSeq,
+                                   ue2::make_unique<ComponentAtomicGroup>());
+    }}
+	break;
+	case 371:
+#line 337 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        assert(!label.empty()); // should be guaranteed by machine
+        char c = *label.begin();
+        if (c >= '0' && c <= '9') {
+            throw LocatedParseError("Group name cannot begin with a digit");
+        }
+        if (!groupNames.insert(label).second) {
+            throw LocatedParseError("Two named subpatterns use the name '" + label + "'");
+        }
+        PUSH_SEQUENCE;
+        auto seq = ue2::make_unique<ComponentSequence>();
+        seq->setCaptureIndex(groupIndex++);
+        seq->setCaptureName(label);
+        currentSeq = enterSequence(currentSeq, move(seq));
+    }}
+	break;
+	case 372:
+#line 400 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        throw LocatedParseError("Subpattern reference unsupported");
+    }}
+	break;
+	case 373:
+#line 400 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        throw LocatedParseError("Subpattern reference unsupported");
+    }}
+	break;
+	case 374:
+#line 1707 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto a = ue2::make_unique<ComponentAssertion>(
+                        ComponentAssertion::LOOKAHEAD, ComponentAssertion::POS);
+                  ComponentAssertion *a_seq = a.get();
+                  PUSH_SEQUENCE;
+                  currentSeq = enterSequence(currentSeq,
+                        ue2::make_unique<ComponentCondReference>(move(a)));
+                  PUSH_SEQUENCE;
+                  currentSeq = a_seq;
+              }}
+	break;
+	case 375:
+#line 1718 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto a = ue2::make_unique<ComponentAssertion>(
+                        ComponentAssertion::LOOKAHEAD, ComponentAssertion::NEG);
+                  ComponentAssertion *a_seq = a.get();
+                  PUSH_SEQUENCE;
+                  currentSeq = enterSequence(currentSeq,
+                        ue2::make_unique<ComponentCondReference>(move(a)));
+                  PUSH_SEQUENCE;
+                  currentSeq = a_seq;
+              }}
+	break;
+	case 376:
+#line 1729 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto a = ue2::make_unique<ComponentAssertion>(
+                      ComponentAssertion::LOOKBEHIND, ComponentAssertion::POS);
+                  ComponentAssertion *a_seq = a.get();
+                  PUSH_SEQUENCE;
+                  currentSeq = enterSequence(currentSeq,
+                        ue2::make_unique<ComponentCondReference>(move(a)));
+                  PUSH_SEQUENCE;
+                  currentSeq = a_seq;
+              }}
+	break;
+	case 377:
+#line 1740 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  auto a = ue2::make_unique<ComponentAssertion>(
+                      ComponentAssertion::LOOKBEHIND, ComponentAssertion::NEG);
+                  ComponentAssertion *a_seq = a.get();
+                  PUSH_SEQUENCE;
+                  currentSeq = enterSequence(currentSeq,
+                        ue2::make_unique<ComponentCondReference>(move(a)));
+                  PUSH_SEQUENCE;
+                  currentSeq = a_seq;
+              }}
+	break;
+	case 378:
+#line 1752 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  throw LocatedParseError("Pattern recursion not supported");
+              }}
+	break;
+	case 379:
+#line 403 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        if (accumulator == 0) {
+            throw LocatedParseError("Numbered reference cannot be zero");
+        }
+        PUSH_SEQUENCE;
+        currentSeq = enterSequence(currentSeq,
+                ue2::make_unique<ComponentCondReference>(accumulator));
+    }}
+	break;
+	case 380:
+#line 411 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+        PUSH_SEQUENCE;
+        assert(!label.empty());
+        currentSeq = enterSequence(currentSeq,
+                ue2::make_unique<ComponentCondReference>(label));
+    }}
+	break;
+	case 381:
+#line 1768 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  ostringstream str;
+                  str << "Callout at index " << ts - ptr << " not supported.";
+                  throw ParseError(str.str());
+              }}
+	break;
+	case 382:
+#line 1776 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  throw LocatedParseError("Unrecognised character after (?");
+              }}
+	break;
+	case 383:
+#line 1781 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  assert(mode.utf8);
+                  /* leverage ComponentClass to generate the vertices */
+                  auto cc = getComponentClass(mode);
+                  cc->add(readUtf8CodePoint2c(ts));
+                  cc->finalize();
+                  currentSeq->addComponent(move(cc));
+              }}
+	break;
+	case 384:
+#line 1790 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  assert(mode.utf8);
+                  /* leverage ComponentClass to generate the vertices */
+                  auto cc = getComponentClass(mode);
+                  cc->add(readUtf8CodePoint3c(ts));
+                  cc->finalize();
+                  currentSeq->addComponent(move(cc));
+              }}
+	break;
+	case 385:
+#line 1799 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  assert(mode.utf8);
+                  /* leverage ComponentClass to generate the vertices */
+                  auto cc = getComponentClass(mode);
+                  cc->add(readUtf8CodePoint4c(ts));
+                  cc->finalize();
+                  currentSeq->addComponent(move(cc));
+              }}
+	break;
+	case 386:
+#line 1808 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  assert(mode.utf8);
+                  throwInvalidUtf8();
+              }}
+	break;
+	case 387:
+#line 1817 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  if (mode.ignore_space == false) {
+                      addLiteral(currentSeq, *ts, mode);
+                  }
+              }}
+	break;
+	case 388:
+#line 1822 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p+1;{
+                  addLiteral(currentSeq, *ts, mode);
+              }}
+	break;
+	case 389:
+#line 329 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+        PUSH_SEQUENCE;
+        auto seq = ue2::make_unique<ComponentSequence>();
+        seq->setCaptureIndex(groupIndex++);
+        currentSeq = enterSequence(currentSeq, move(seq));
+    }}
+	break;
+	case 390:
+#line 422 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+        assert(!currentCls);
+        assert(!inCharClass); // not reentrant
+        currentCls = getComponentClass(mode);
+        inCharClass = true;
+        inCharClassEarly = true;
+        currentClsBegin = ts;
+        {cs = 830; goto _again;}
+    }}
+	break;
+	case 391:
+#line 1244 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  if (!currentSeq->addRepeat(0, ComponentRepeat::NoLimit,
+                                             ComponentRepeat::REPEAT_GREEDY)) {
+                      throwInvalidRepeat();
+                  }
+              }}
+	break;
+	case 392:
+#line 1265 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  if (!currentSeq->addRepeat(1, ComponentRepeat::NoLimit,
+                                             ComponentRepeat::REPEAT_GREEDY)) {
+                      throwInvalidRepeat();
+                  }
+              }}
+	break;
+	case 393:
+#line 1286 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  if (!currentSeq->addRepeat(
+                           0, 1, ComponentRepeat::REPEAT_GREEDY)) {
+                      throwInvalidRepeat();
+                  }
+              }}
+	break;
+	case 394:
+#line 1307 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  if (repeatN > repeatM || repeatM == 0) {
+                      throwInvalidRepeat();
+                  } else if (!currentSeq->addRepeat(
+                                  repeatN, repeatM,
+                                  ComponentRepeat::REPEAT_GREEDY)) {
+                      throwInvalidRepeat();
+                  }
+              }}
+	break;
+	case 395:
+#line 1422 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  addLiteral(currentSeq, octAccumulator, mode);
+              }}
+	break;
+	case 396:
+#line 1425 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  // If there are enough capturing sub expressions, this may be
+                  // a back reference
+                  accumulator = parseAsDecimal(octAccumulator);
+                  if (accumulator < groupIndex) {
+                      currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(accumulator));
+                  } else {
+                      addEscapedOctal(currentSeq, octAccumulator, mode);
+                  }
+              }}
+	break;
+	case 397:
+#line 480 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+        if (accumulator == 0) {
+            throw LocatedParseError("Numbered reference cannot be zero");
+        }
+        currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(accumulator));
+    }}
+	break;
+	case 398:
+#line 480 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+        if (accumulator == 0) {
+            throw LocatedParseError("Numbered reference cannot be zero");
+        }
+        currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(accumulator));
+    }}
+	break;
+	case 399:
+#line 487 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+        // Accumulator is a negative offset.
+        if (accumulator == 0) {
+            throw LocatedParseError("Numbered reference cannot be zero");
+        }
+        if (accumulator >= groupIndex) {
+            throw LocatedParseError("Invalid reference");
+        }
+        unsigned idx = groupIndex - accumulator;
+        currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(idx));
+    }}
+	break;
+	case 400:
+#line 1491 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  throw LocatedParseError("Invalid reference after \\g");
+              }}
+	break;
+	case 401:
+#line 1503 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  throw LocatedParseError("Value in \\o{...} sequence is non-octal or missing braces");
+              }}
+	break;
+	case 402:
+#line 1507 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  addEscapedHex(currentSeq, accumulator, mode);
+              }}
+	break;
+	case 403:
+#line 1520 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  throw LocatedParseError("Value in \\x{...} sequence is non-hex or missing }");
+              }}
+	break;
+	case 404:
+#line 1524 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  if (te - ts < 3) {
+                      assert(te - ts == 2);
+                      throw LocatedParseError(SLASH_C_ERROR);
+                  } else {
+                      assert(te - ts == 3);
+                      addLiteral(currentSeq, decodeCtrl(ts[2]), mode);
+                  }
+              }}
+	break;
+	case 405:
+#line 1624 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ throw LocatedParseError("Malformed property"); }}
+	break;
+	case 406:
+#line 1625 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{ throw LocatedParseError("Malformed property"); }}
+	break;
+	case 407:
+#line 1643 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  ostringstream str;
+                  str << "\\k at index " << ts - ptr << " not supported.";
+                  throw ParseError(str.str());
+              }}
+	break;
+	case 408:
+#line 1666 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  assert(ts + 1 == pe);
+                  ostringstream str;
+                  str << "Unescaped \\ at end of input, index " << ts - ptr << ".";
+                  throw ParseError(str.str());
+              }}
+	break;
+	case 409:
+#line 397 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+        throw LocatedParseError("Conditional subpattern unsupported");
+    }}
+	break;
+	case 410:
+#line 1776 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  throw LocatedParseError("Unrecognised character after (?");
+              }}
+	break;
+	case 411:
+#line 1808 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  assert(mode.utf8);
+                  throwInvalidUtf8();
+              }}
+	break;
+	case 412:
+#line 1822 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{te = p;p--;{
+                  addLiteral(currentSeq, *ts, mode);
+              }}
+	break;
+	case 413:
+#line 329 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+        PUSH_SEQUENCE;
+        auto seq = ue2::make_unique<ComponentSequence>();
+        seq->setCaptureIndex(groupIndex++);
+        currentSeq = enterSequence(currentSeq, move(seq));
+    }}
+	break;
+	case 414:
+#line 422 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+        assert(!currentCls);
+        assert(!inCharClass); // not reentrant
+        currentCls = getComponentClass(mode);
+        inCharClass = true;
+        inCharClassEarly = true;
+        currentClsBegin = ts;
+        {cs = 830; goto _again;}
+    }}
+	break;
+	case 415:
+#line 1491 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+                  throw LocatedParseError("Invalid reference after \\g");
+              }}
+	break;
+	case 416:
+#line 1503 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+                  throw LocatedParseError("Value in \\o{...} sequence is non-octal or missing braces");
+              }}
+	break;
+	case 417:
+#line 1520 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+                  throw LocatedParseError("Value in \\x{...} sequence is non-hex or missing }");
+              }}
+	break;
+	case 418:
+#line 1643 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+                  ostringstream str;
+                  str << "\\k at index " << ts - ptr << " not supported.";
+                  throw ParseError(str.str());
+              }}
+	break;
+	case 419:
+#line 397 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+        throw LocatedParseError("Conditional subpattern unsupported");
+    }}
+	break;
+	case 420:
+#line 1776 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+                  throw LocatedParseError("Unrecognised character after (?");
+              }}
+	break;
+	case 421:
+#line 1808 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+                  assert(mode.utf8);
+                  throwInvalidUtf8();
+              }}
+	break;
+	case 422:
+#line 1822 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{{p = ((te))-1;}{
+                  addLiteral(currentSeq, *ts, mode);
+              }}
+	break;
+	case 423:
+#line 1 "NONE"
+	{	switch( act ) {
+	case 279:
+	{{p = ((te))-1;}
+                  // If there are enough capturing sub expressions, this may be
+                  // a back reference
+                  accumulator = parseAsDecimal(octAccumulator);
+                  if (accumulator < groupIndex) {
+                      currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(accumulator));
+                  } else {
+                      addEscapedOctal(currentSeq, octAccumulator, mode);
+                  }
+              }
+	break;
+	case 281:
+	{{p = ((te))-1;}
+                  // if there are enough left parens to this point, back ref
+                  if (accumulator < groupIndex) {
+                      currentSeq->addComponent(ue2::make_unique<ComponentBackReference>(accumulator));
+                  } else {
+                      // Otherwise, we interpret the first three digits as an
+                      // octal escape, and the remaining characters stand for
+                      // themselves as literals.
+                      const u8 *p = ts;
+                      unsigned int accum = 0;
+                      unsigned int oct_digits = 0;
+                      assert(*p == '\\'); // token starts at backslash
+                      for (++p; p < te && oct_digits < 3; ++oct_digits, ++p) {
+                          u8 digit = *p - '0';
+                          if (digit < 8) {
+                              accum = digit + accum * 8;
+                          } else {
+                              break;
+                          }
+                      }
+
+                      if (oct_digits > 0) {
+                          addEscapedOctal(currentSeq, accum, mode);
+                      }
+
+                      // And then the rest of the digits, if any, are literal.
+                      for (; p < te; ++p) {
+                          addLiteral(currentSeq, *p, mode);
+                      }
+                  }
+              }
+	break;
+	case 321:
+	{{p = ((te))-1;}
+                  addLiteral(currentSeq, *(ts + 1), mode);
+              }
+	break;
+	}
+	}
+	break;
+#line 5339 "hyperscan-build/src/parser/Parser.cpp"
+		}
+	}
+
+_again:
+	_acts = _regex_actions + _regex_to_state_actions[cs];
+	_nacts = (unsigned int) *_acts++;
+	while ( _nacts-- > 0 ) {
+		switch ( *_acts++ ) {
+	case 23:
+#line 1 "NONE"
+	{ts = 0;}
+	break;
+#line 5352 "hyperscan-build/src/parser/Parser.cpp"
+		}
+	}
+
+	if ( cs == 0 )
+		goto _out;
+	if ( ++p != pe )
+		goto _resume;
+	_test_eof: {}
+	if ( p == eof )
+	{
+	if ( _regex_eof_trans[cs] > 0 ) {
+		_trans = _regex_eof_trans[cs] - 1;
+		goto _eof_trans;
+	}
+	const short *__acts = _regex_actions + _regex_eof_actions[cs];
+	unsigned int __nacts = (unsigned int) *__acts++;
+	while ( __nacts-- > 0 ) {
+		switch ( *__acts++ ) {
+	case 22:
+#line 732 "hyperscan-4.1.0/src/parser/Parser.rl"
+	{ throw LocatedParseError("Malformed property"); }
+	break;
+#line 5375 "hyperscan-build/src/parser/Parser.cpp"
+		}
+	}
+	}
+
+	_out: {}
+	}
+
+#line 1904 "hyperscan-4.1.0/src/parser/Parser.rl"
+
+        if (p != pe && *p != '\0') {
+            // didn't make it to the end of our input, but we didn't throw a ParseError?
+            assert(0);
+            ostringstream str;
+            str << "Parse error at index " << (p - ptr) << ".";
+            throw ParseError(str.str());
+        }
+
+        if (currentCls) {
+            assert(inCharClass);
+            assert(currentClsBegin);
+            ostringstream oss;
+            oss << "Unterminated character class starting at index "
+                << currentClsBegin - ptr << ".";
+            throw ParseError(oss.str());
+        }
+
+        if (inComment) {
+            throw ParseError("Unterminated comment.");
+        }
+
+        if (!sequences.empty()) {
+            ostringstream str;
+            str << "Missing close parenthesis for group started at index "
+                << sequences.back().seqOffset << ".";
+            throw ParseError(str.str());
+        }
+
+        // Unlikely, but possible
+        if (groupIndex > 65535) {
+            throw ParseError("The maximum number of capturing subexpressions is 65535.");
+        }
+
+        // Finalize the top-level sequence, which will take care of any
+        // top-level alternation.
+        currentSeq->finalize();
+        assert(currentSeq == rootSeq.get());
+
+        // Ensure that all references are valid.
+        checkReferences(*rootSeq, groupIndex, groupNames);
+
+        return move(rootSeq);
+    } catch (LocatedParseError &error) {
+        if (ts >= ptr && ts <= pe) {
+            error.locate(ts - ptr);
+        } else {
+            error.locate(0);
+        }
+        throw;
+    }
+}
+
+} // namespace ue2
diff --git a/util/CMakeLists.txt b/util/CMakeLists.txt
index 1111111..2222222 100644
--- a/util/CMakeLists.txt
+++ b/util/CMakeLists.txt
@@ -4,12 +4,10 @@ set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${EXTRA_CXX_FLAGS}")
 include_directories(${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR})
 
 set_source_files_properties(
-    ${CMAKE_BINARY_DIR}/tools/ExpressionParser.cpp
+    ${CMAKE_SOURCE_DIR}/tools/ExpressionParser.cpp
     PROPERTIES
     COMPILE_FLAGS "${RAGEL_C_FLAGS}")
 
-ragelmaker(ExpressionParser.rl)
-
 set(expressionutil_SRCS
     expressions.cpp
     expressions.h
@@ -17,7 +15,6 @@ set(expressionutil_SRCS
     ExpressionParser.cpp
     )
 add_library(expressionutil ${expressionutil_SRCS})
-add_dependencies(expressionutil ragel_ExpressionParser)
 
 SET(corpusomatic_SRCS
     ng_corpus_editor.h
diff --git a/util/ExpressionParser.cpp b/util/ExpressionParser.cpp
new file mode 100644
index 1111111..2222222
--- /dev/null
+++ b/util/ExpressionParser.cpp
@@ -0,0 +1,383 @@
+
+#line 1 "hyperscan-4.1.0/util/ExpressionParser.rl"
+/*
+ * Copyright (c) 2015, Intel Corporation
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *  * Neither the name of Intel Corporation nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+
+#include "ExpressionParser.h"
+
+#include <cassert>
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+#include <string>
+
+#include "ue2common.h"
+#include "hs_compile.h"
+
+
+using std::string;
+
+namespace { // anon
+
+enum ParamKey {
+    PARAM_NONE,
+    PARAM_MIN_OFFSET,
+    PARAM_MAX_OFFSET,
+    PARAM_MIN_LENGTH
+};
+
+
+#line 58 "hyperscan-build/util//ExpressionParser.cpp"
+static const char _ExpressionParser_actions[] = {
+	0, 1, 0, 1, 1, 1, 2, 1, 
+	3, 1, 4, 1, 5, 1, 7, 1, 
+	8, 2, 6, 0
+};
+
+static const char _ExpressionParser_key_offsets[] = {
+	0, 0, 2, 4, 6, 7, 8, 9, 
+	10, 11, 12, 13, 14, 15, 17, 22, 
+	25, 26, 27, 29, 30, 31, 32, 33, 
+	34, 35, 36, 37, 38, 39, 50
+};
+
+static const char _ExpressionParser_trans_keys[] = {
+	32, 109, 32, 109, 97, 105, 120, 95, 
+	111, 102, 102, 115, 101, 116, 61, 48, 
+	57, 32, 44, 125, 48, 57, 32, 44, 
+	125, 110, 95, 108, 111, 101, 110, 103, 
+	116, 104, 102, 102, 115, 101, 116, 56, 
+	72, 76, 105, 109, 115, 123, 79, 80, 
+	86, 87, 0
+};
+
+static const char _ExpressionParser_single_lengths[] = {
+	0, 2, 2, 2, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 0, 3, 3, 
+	1, 1, 2, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 7, 0
+};
+
+static const char _ExpressionParser_range_lengths[] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 1, 1, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 2, 0
+};
+
+static const char _ExpressionParser_index_offsets[] = {
+	0, 0, 3, 6, 9, 11, 13, 15, 
+	17, 19, 21, 23, 25, 27, 29, 34, 
+	38, 40, 42, 45, 47, 49, 51, 53, 
+	55, 57, 59, 61, 63, 65, 75
+};
+
+static const char _ExpressionParser_indicies[] = {
+	1, 2, 0, 3, 4, 0, 5, 6, 
+	0, 7, 0, 8, 0, 9, 0, 10, 
+	0, 11, 0, 12, 0, 13, 0, 14, 
+	0, 15, 0, 16, 0, 17, 18, 20, 
+	19, 0, 17, 18, 20, 0, 21, 0, 
+	22, 0, 23, 24, 0, 25, 0, 26, 
+	0, 27, 0, 28, 0, 29, 0, 30, 
+	0, 31, 0, 32, 0, 33, 0, 34, 
+	0, 35, 35, 35, 35, 35, 35, 36, 
+	35, 35, 0, 0, 0
+};
+
+static const char _ExpressionParser_trans_targs[] = {
+	0, 2, 3, 2, 3, 4, 16, 5, 
+	6, 7, 8, 9, 10, 11, 12, 13, 
+	14, 15, 1, 14, 30, 17, 18, 19, 
+	24, 20, 21, 22, 23, 12, 25, 26, 
+	27, 28, 12, 29, 1
+};
+
+static const char _ExpressionParser_trans_actions[] = {
+	15, 13, 13, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 9, 0, 
+	17, 0, 5, 1, 5, 0, 0, 0, 
+	0, 0, 0, 0, 0, 11, 0, 0, 
+	0, 0, 7, 3, 0
+};
+
+static const char _ExpressionParser_eof_actions[] = {
+	0, 15, 15, 15, 15, 15, 15, 15, 
+	15, 15, 15, 15, 15, 15, 15, 15, 
+	15, 15, 15, 15, 15, 15, 15, 15, 
+	15, 15, 15, 15, 15, 0, 0
+};
+
+static const int ExpressionParser_start = 29;
+static const int ExpressionParser_first_final = 29;
+static const int ExpressionParser_error = 0;
+
+static const int ExpressionParser_en_main = 29;
+
+
+#line 103 "hyperscan-4.1.0/util/ExpressionParser.rl"
+
+
+} // namespace
+
+static
+void initExt(hs_expr_ext *ext) {
+    memset(ext, 0, sizeof(*ext));
+    ext->max_offset = MAX_OFFSET;
+}
+
+bool readExpression(const std::string &input, std::string &expr,
+                    unsigned int *flags, hs_expr_ext *ext,
+                    bool *must_be_ordered) {
+    assert(flags);
+    assert(ext);
+
+    // Init flags and ext params.
+    *flags = 0;
+    initExt(ext);
+    if (must_be_ordered) {
+        *must_be_ordered = false;
+    }
+
+    // Extract expr, which is easier to do in straight C++ than with Ragel.
+    if (input.empty() || input[0] != '/') {
+        return false;
+    }
+    size_t end = input.find_last_of('/');
+    if (end == string::npos || end == 0) {
+        return false;
+    }
+    expr = input.substr(1, end - 1);
+
+    // Use a Ragel scanner to handle flags and params.
+    const char *p = input.c_str() + end + 1;
+    const char *pe = input.c_str() + input.size();
+    UNUSED const char *eof = pe;
+    UNUSED const char *ts = p, *te = p;
+    int cs;
+    UNUSED int act;
+
+    assert(p);
+    assert(pe);
+
+    // For storing integers as they're scanned.
+    u64a num = 0;
+    enum ParamKey key = PARAM_NONE;
+
+    
+#line 196 "hyperscan-build/util//ExpressionParser.cpp"
+	{
+	cs = ExpressionParser_start;
+	}
+
+#line 201 "hyperscan-build/util//ExpressionParser.cpp"
+	{
+	int _klen;
+	unsigned int _trans;
+	const char *_acts;
+	unsigned int _nacts;
+	const char *_keys;
+
+	if ( p == pe )
+		goto _test_eof;
+	if ( cs == 0 )
+		goto _out;
+_resume:
+	_keys = _ExpressionParser_trans_keys + _ExpressionParser_key_offsets[cs];
+	_trans = _ExpressionParser_index_offsets[cs];
+
+	_klen = _ExpressionParser_single_lengths[cs];
+	if ( _klen > 0 ) {
+		const char *_lower = _keys;
+		const char *_mid;
+		const char *_upper = _keys + _klen - 1;
+		while (1) {
+			if ( _upper < _lower )
+				break;
+
+			_mid = _lower + ((_upper-_lower) >> 1);
+			if ( (*p) < *_mid )
+				_upper = _mid - 1;
+			else if ( (*p) > *_mid )
+				_lower = _mid + 1;
+			else {
+				_trans += (unsigned int)(_mid - _keys);
+				goto _match;
+			}
+		}
+		_keys += _klen;
+		_trans += _klen;
+	}
+
+	_klen = _ExpressionParser_range_lengths[cs];
+	if ( _klen > 0 ) {
+		const char *_lower = _keys;
+		const char *_mid;
+		const char *_upper = _keys + (_klen<<1) - 2;
+		while (1) {
+			if ( _upper < _lower )
+				break;
+
+			_mid = _lower + (((_upper-_lower) >> 1) & ~1);
+			if ( (*p) < _mid[0] )
+				_upper = _mid - 2;
+			else if ( (*p) > _mid[1] )
+				_lower = _mid + 2;
+			else {
+				_trans += (unsigned int)((_mid - _keys)>>1);
+				goto _match;
+			}
+		}
+		_trans += _klen;
+	}
+
+_match:
+	_trans = _ExpressionParser_indicies[_trans];
+	cs = _ExpressionParser_trans_targs[_trans];
+
+	if ( _ExpressionParser_trans_actions[_trans] == 0 )
+		goto _again;
+
+	_acts = _ExpressionParser_actions + _ExpressionParser_trans_actions[_trans];
+	_nacts = (unsigned int) *_acts++;
+	while ( _nacts-- > 0 )
+	{
+		switch ( *_acts++ )
+		{
+	case 0:
+#line 57 "hyperscan-4.1.0/util/ExpressionParser.rl"
+	{
+        num = (num * 10) + ((*p) - '0');
+    }
+	break;
+	case 1:
+#line 61 "hyperscan-4.1.0/util/ExpressionParser.rl"
+	{
+        switch ((*p)) {
+            case 'i': *flags |= HS_FLAG_CASELESS; break;
+            case 's': *flags |= HS_FLAG_DOTALL; break;
+            case 'm': *flags |= HS_FLAG_MULTILINE; break;
+            case 'H': *flags |= HS_FLAG_SINGLEMATCH; break;
+            case 'O':
+                if (must_be_ordered) {
+                    *must_be_ordered = true;
+                }
+                break;
+            case 'V': *flags |= HS_FLAG_ALLOWEMPTY; break;
+            case 'W': *flags |= HS_FLAG_UCP; break;
+            case '8': *flags |= HS_FLAG_UTF8; break;
+            case 'P': *flags |= HS_FLAG_PREFILTER; break;
+            case 'L': *flags |= HS_FLAG_SOM_LEFTMOST; break;
+            default: {p++; goto _out; }
+        }
+    }
+	break;
+	case 2:
+#line 81 "hyperscan-4.1.0/util/ExpressionParser.rl"
+	{
+        switch (key) {
+            case PARAM_MIN_OFFSET:
+                ext->flags |= HS_EXT_FLAG_MIN_OFFSET;
+                ext->min_offset = num;
+                break;
+            case PARAM_MAX_OFFSET:
+                ext->flags |= HS_EXT_FLAG_MAX_OFFSET;
+                ext->max_offset = num;
+                break;
+            case PARAM_MIN_LENGTH:
+                ext->flags |= HS_EXT_FLAG_MIN_LENGTH;
+                ext->min_length = num;
+                break;
+            case PARAM_NONE:
+            default:
+                // No key specified, syntax invalid.
+                return false;
+        }
+    }
+	break;
+	case 3:
+#line 153 "hyperscan-4.1.0/util/ExpressionParser.rl"
+	{ key = PARAM_MIN_OFFSET; }
+	break;
+	case 4:
+#line 154 "hyperscan-4.1.0/util/ExpressionParser.rl"
+	{ key = PARAM_MAX_OFFSET; }
+	break;
+	case 5:
+#line 155 "hyperscan-4.1.0/util/ExpressionParser.rl"
+	{ key = PARAM_MIN_LENGTH; }
+	break;
+	case 6:
+#line 157 "hyperscan-4.1.0/util/ExpressionParser.rl"
+	{num = 0;}
+	break;
+	case 7:
+#line 158 "hyperscan-4.1.0/util/ExpressionParser.rl"
+	{ key = PARAM_NONE; }
+	break;
+	case 8:
+#line 163 "hyperscan-4.1.0/util/ExpressionParser.rl"
+	{ return false; }
+	break;
+#line 350 "hyperscan-build/util//ExpressionParser.cpp"
+		}
+	}
+
+_again:
+	if ( cs == 0 )
+		goto _out;
+	if ( ++p != pe )
+		goto _resume;
+	_test_eof: {}
+	if ( p == eof )
+	{
+	const char *__acts = _ExpressionParser_actions + _ExpressionParser_eof_actions[cs];
+	unsigned int __nacts = (unsigned int) *__acts++;
+	while ( __nacts-- > 0 ) {
+		switch ( *__acts++ ) {
+	case 8:
+#line 163 "hyperscan-4.1.0/util/ExpressionParser.rl"
+	{ return false; }
+	break;
+#line 370 "hyperscan-build/util//ExpressionParser.cpp"
+		}
+	}
+	}
+
+	_out: {}
+	}
+
+#line 168 "hyperscan-4.1.0/util/ExpressionParser.rl"
+
+
+    DEBUG_PRINTF("expr='%s', flags=%u\n", expr.c_str(), *flags);
+
+    return (cs != ExpressionParser_error) && (p == pe);
+}

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Boris Nagaev <bnagaev@gmail.com>
Date: Wed, 18 May 2016 01:10:30 +0200
Subject: [PATCH] add Libs.private to fix linking errors

See https://github.com/01org/hyperscan/issues/18

diff --git a/libhs.pc.in b/libhs.pc.in
index 1111111..2222222 100644
--- a/libhs.pc.in
+++ b/libhs.pc.in
@@ -7,4 +7,5 @@ Name: libhs
 Description: Intel(R) Hyperscan Library
 Version: @HS_VERSION@
 Libs: -L${libdir} -lhs
+Libs.private: -lstdc++ -lm
 Cflags: -I${includedir}/hs

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Boris Nagaev <bnagaev@gmail.com>
Date: Wed, 18 May 2016 01:12:02 +0200
Subject: [PATCH] fix linking against gtest in shared mode

See https://github.com/01org/hyperscan/issues/19

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1111111..2222222 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -214,7 +214,7 @@ CHECK_FUNCTION_EXISTS(_aligned_malloc HAVE__ALIGNED_MALLOC)
 CHECK_C_COMPILER_FLAG(-fvisibility=hidden HAS_C_HIDDEN)
 CHECK_CXX_COMPILER_FLAG(-fvisibility=hidden HAS_CXX_HIDDEN)
 
-if (RELEASE_BUILD)
+if (RELEASE_BUILD AND NOT BUILD_STATIC_AND_SHARED AND NOT BUILD_SHARED_LIBS)
     if (HAS_C_HIDDEN)
         set(EXTRA_C_FLAGS "${EXTRA_C_FLAGS} -fvisibility=hidden")
     endif()

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Boris Nagaev <bnagaev@gmail.com>
Date: Wed, 18 May 2016 01:25:59 +0200
Subject: [PATCH] update preprocessor conditions

Add macro NATIVE_WIN32 = Windows && !MinGW.
Replace _WIN32 with NATIVE_WIN32 where it failed.

diff --git a/cmake/config.h.in b/cmake/config.h.in
index 1111111..2222222 100644
--- a/cmake/config.h.in
+++ b/cmake/config.h.in
@@ -99,3 +99,4 @@
 /* define if this is a release build. */
 #cmakedefine RELEASE_BUILD
 
+#define NATIVE_WIN32 ((defined(_WIN32) || defined(_WIN64)) && !defined(__MINGW__) && !defined(__MINGW32__))
diff --git a/src/database.c b/src/database.c
index 1111111..2222222 100644
--- a/src/database.c
+++ b/src/database.c
@@ -385,7 +385,7 @@ hs_database_t *dbCreate(const char *in_bytecode, size_t len, u64a platform) {
     return db;
 }
 
-#if defined(_WIN32)
+#if NATIVE_WIN32
 #define SNPRINTF_COMPAT _snprintf
 #else
 #define SNPRINTF_COMPAT snprintf
diff --git a/src/nfa/nfa_internal.h b/src/nfa/nfa_internal.h
index 1111111..2222222 100644
--- a/src/nfa/nfa_internal.h
+++ b/src/nfa/nfa_internal.h
@@ -240,7 +240,7 @@ int isMultiTopType(u8 t) {
 
 /** Macros used in place of unimplemented NFA API functions for a given
  * engine. */
-#if !defined(_WIN32)
+#if !NATIVE_WIN32
 
 /* Use for functions that return an integer. */
 #define NFA_API_NO_IMPL(...)                                                   \
diff --git a/src/rose/rose_internal.h b/src/rose/rose_internal.h
index 1111111..2222222 100644
--- a/src/rose/rose_internal.h
+++ b/src/rose/rose_internal.h
@@ -637,7 +637,7 @@ struct lit_benefits {
     } expected;
 };
 
-#if defined(_WIN32)
+#if NATIVE_WIN32
 #pragma pack(push, 1)
 #endif
 // Rose runtime state
@@ -645,7 +645,7 @@ struct RoseRuntimeState {
     u8 stored_depth; /* depth at stream boundary */
     u8 flags; /* high bit true if delay rebuild needed */
     u8 broken; /* user has requested that we stop matching */
-#if defined(_WIN32)
+#if NATIVE_WIN32
 };
 #pragma pack(pop)
 #else
diff --git a/src/ue2common.h b/src/ue2common.h
index 1111111..2222222 100644
--- a/src/ue2common.h
+++ b/src/ue2common.h
@@ -46,7 +46,7 @@
 #include <stdint.h>
 
 /* ick */
-#if defined(_WIN32)
+#if NATIVE_WIN32
 #define ALIGN_ATTR(x) __declspec(align(x))
 #else
 #define ALIGN_ATTR(x) __attribute__((aligned((x))))
@@ -75,7 +75,7 @@ typedef u32 ReportID;
 
 /* Shorthand for attribute to mark a function as part of our public API.
  * Functions without this attribute will be hidden. */
-#if !defined(_WIN32)
+#if !NATIVE_WIN32
 #define HS_PUBLIC_API     __attribute__((visibility("default")))
 #else
 // TODO: dllexport defines for windows
@@ -89,14 +89,14 @@ typedef u32 ReportID;
 #define ARRAY_LENGTH(a) (sizeof(a)/sizeof((a)[0]))
 
 /** \brief Shorthand for the attribute to shut gcc about unused parameters */
-#if !defined(_WIN32)
+#if !NATIVE_WIN32
 #define UNUSED __attribute__ ((unused))
 #else
 #define UNUSED
 #endif
 
 /* really_inline forces inlining always */
-#if !defined(_WIN32)
+#if !NATIVE_WIN32
 #if defined(HS_OPTIMIZE)
 #define really_inline inline __attribute__ ((always_inline, unused))
 #else
@@ -126,7 +126,7 @@ typedef u32 ReportID;
 
 
 // We use C99-style "restrict".
-#ifdef _WIN32
+#if NATIVE_WIN32
 #ifdef __cplusplus
 #define restrict
 #else
@@ -182,7 +182,7 @@ typedef u32 ReportID;
 #define LIMIT_TO_AT_MOST(a, b) (*(a) = MIN(*(a),(b)))
 #define ENSURE_AT_LEAST(a, b) (*(a) = MAX(*(a),(b)))
 
-#ifndef _WIN32
+#if !NATIVE_WIN32
 #ifndef likely
   #define likely(x)     __builtin_expect(!!(x), 1)
 #endif
diff --git a/src/util/alloc.cpp b/src/util/alloc.cpp
index 1111111..2222222 100644
--- a/src/util/alloc.cpp
+++ b/src/util/alloc.cpp
@@ -61,7 +61,7 @@ namespace ue2 {
 
 void *aligned_malloc_internal(size_t size, size_t align) {
     void *mem;
-#if !defined(_WIN32)
+#if !NATIVE_WIN32
     int rv = posix_memalign(&mem, align, size);
     if (rv != 0) {
         DEBUG_PRINTF("posix_memalign returned %d when asked for %zu bytes\n",
@@ -85,7 +85,7 @@ void aligned_free_internal(void *ptr) {
         return;
     }
 
-#if defined(_WIN32)
+#if NATIVE_WIN32
     _aligned_free(ptr);
 #else
     free(ptr);
diff --git a/src/util/bitutils.h b/src/util/bitutils.h
index 1111111..2222222 100644
--- a/src/util/bitutils.h
+++ b/src/util/bitutils.h
@@ -63,7 +63,7 @@
 #endif
 
 // MSVC has a different form of inline asm
-#ifdef _WIN32
+#if NATIVE_WIN32
 #define NO_ASM
 #endif
 
@@ -74,7 +74,7 @@
 static really_inline
 u32 clz32(u32 x) {
     assert(x); // behaviour not defined for x == 0
-#if defined(_WIN32)
+#if NATIVE_WIN32
     unsigned long r;
     _BitScanReverse(&r, x);
     return 31 - r;
@@ -86,7 +86,7 @@ u32 clz32(u32 x) {
 static really_inline
 u32 clz64(u64a x) {
     assert(x); // behaviour not defined for x == 0
-#if defined(_WIN32)
+#if NATIVE_WIN32
     unsigned long r;
     _BitScanReverse64(&r, x);
     return 63 - r;
@@ -99,7 +99,7 @@ u32 clz64(u64a x) {
 static really_inline
 u32 ctz32(u32 x) {
     assert(x); // behaviour not defined for x == 0
-#if defined(_WIN32)
+#if NATIVE_WIN32
     unsigned long r;
     _BitScanForward(&r, x);
     return r;
@@ -111,7 +111,7 @@ u32 ctz32(u32 x) {
 static really_inline
 u32 ctz64(u64a x) {
     assert(x); // behaviour not defined for x == 0
-#if defined(_WIN32)
+#if NATIVE_WIN32
     unsigned long r;
     _BitScanForward64(&r, x);
     return r;
diff --git a/src/util/cpuid_flags.c b/src/util/cpuid_flags.c
index 1111111..2222222 100644
--- a/src/util/cpuid_flags.c
+++ b/src/util/cpuid_flags.c
@@ -31,7 +31,7 @@
 #include "hs_compile.h" // for HS_MODE_ flags
 #include "hs_internal.h"
 
-#ifndef _WIN32
+#if !NATIVE_WIN32
 #include <cpuid.h>
 #endif
 
@@ -54,7 +54,7 @@
 static __inline
 void cpuid(unsigned int op, unsigned int leaf, unsigned int *eax,
            unsigned int *ebx, unsigned int *ecx, unsigned int *edx) {
-#ifndef _WIN32
+#if !NATIVE_WIN32
     __cpuid_count(op, leaf, *eax, *ebx, *ecx, *edx);
 #else
     unsigned int a[4];
diff --git a/src/util/popcount.h b/src/util/popcount.h
index 1111111..2222222 100644
--- a/src/util/popcount.h
+++ b/src/util/popcount.h
@@ -40,7 +40,7 @@
 #define HAVE_POPCOUNT_INSTR
 #endif
 
-#if defined(_WIN32) && defined(__AVX__) // TODO: fix win preproc
+#if NATIVE_WIN32 && defined(__AVX__) // TODO: fix win preproc
 #define HAVE_POPCOUNT_INSTR
 #define __builtin_popcount __popcnt
 #define __builtin_popcountll __popcnt64
diff --git a/src/util/shuffle.h b/src/util/shuffle.h
index 1111111..2222222 100644
--- a/src/util/shuffle.h
+++ b/src/util/shuffle.h
@@ -42,7 +42,7 @@
 #include "simd_utils.h"
 #include "ue2common.h"
 
-#if defined(__BMI2__) || (defined(_WIN32) && defined(__AVX2__))
+#if defined(__BMI2__) || (NATIVE_WIN32 && defined(__AVX2__))
 #define HAVE_PEXT
 #endif
 
diff --git a/src/util/simd_utils.h b/src/util/simd_utils.h
index 1111111..2222222 100644
--- a/src/util/simd_utils.h
+++ b/src/util/simd_utils.h
@@ -84,7 +84,7 @@
 #  endif
 #endif
 
-#ifdef _WIN32
+#if NATIVE_WIN32
 #define NO_ASM
 #endif
 
diff --git a/src/util/simd_utils_ssse3.h b/src/util/simd_utils_ssse3.h
index 1111111..2222222 100644
--- a/src/util/simd_utils_ssse3.h
+++ b/src/util/simd_utils_ssse3.h
@@ -33,7 +33,7 @@
 #ifndef SIMD_UTILS_SSSE3_H_E27DF795C9AA02
 #define SIMD_UTILS_SSSE3_H_E27DF795C9AA02
 
-#if !defined(_WIN32) && !defined(__SSSE3__)
+#if !NATIVE_WIN32 && !defined(__SSSE3__)
 #error SSSE3 instructions must be enabled
 #endif
 
diff --git a/src/util/unaligned.h b/src/util/unaligned.h
index 1111111..2222222 100644
--- a/src/util/unaligned.h
+++ b/src/util/unaligned.h
@@ -35,7 +35,7 @@
 
 #include "ue2common.h"
 
-#if !defined(_WIN32)
+#if !NATIVE_WIN32
 #define PACKED__MAY_ALIAS __attribute__((packed, may_alias))
 #else
 #define PACKED__MAY_ALIAS
@@ -89,7 +89,7 @@ void unaligned_store_u64a(void *ptr, u64a val) {
     struct unaligned *uptr = (struct unaligned *)ptr;
     uptr->u = val;
 }
-#if defined(_WIN32)
+#if NATIVE_WIN32
 #pragma pack(pop)
 #endif // win32
 
diff --git a/unit/hyperscan/test_util.h b/unit/hyperscan/test_util.h
index 1111111..2222222 100644
--- a/unit/hyperscan/test_util.h
+++ b/unit/hyperscan/test_util.h
@@ -35,7 +35,7 @@
 #include "hs.h"
 
 #ifndef UNUSED
-#if defined(_WIN32) || defined(_WIN64)
+#if NATIVE_WIN32
 #define UNUSED
 #else
 #define UNUSED __attribute__ ((unused))
diff --git a/util/expressions.cpp b/util/expressions.cpp
index 1111111..2222222 100644
--- a/util/expressions.cpp
+++ b/util/expressions.cpp
@@ -37,7 +37,7 @@
 #include <boost/algorithm/string/trim.hpp>
 #include <sys/types.h>
 #include <sys/stat.h>
-#if !defined(_WIN32)
+#if !NATIVE_WIN32
 #include <dirent.h>
 #include <unistd.h>
 #else
@@ -96,7 +96,7 @@ void processLine(string &line, unsigned lineNum,
     }
 }
 
-#if defined(_WIN32)
+#if NATIVE_WIN32
 #define stat _stat
 #define S_ISDIR(st_m) (_S_IFDIR & (st_m))
 #define S_ISREG(st_m) (_S_IFREG & (st_m))
@@ -141,7 +141,7 @@ bool isIgnorable(const std::string &f) {
     return false;
 }
 
-#ifndef _WIN32
+#if !NATIVE_WIN32
 void loadExpressions(const string &inPath, ExpressionMap &exprMap) {
     // Is our input path a file or a directory?
     struct stat st;

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Boris Nagaev <bnagaev@gmail.com>
Date: Wed, 18 May 2016 07:38:29 +0200
Subject: [PATCH] cmake: replace WIN32 with WIN32 AND NOT MINGW


diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1111111..2222222 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -101,7 +101,7 @@ option(BUILD_SHARED_LIBS "Build shared libs instead of static" OFF)
 option(BUILD_STATIC_AND_SHARED "Build shared libs as well as static" OFF)
 
 if (BUILD_STATIC_AND_SHARED OR BUILD_SHARED_LIBS)
-    if (WIN32)
+    if (WIN32 AND NOT MINGW)
         message(FATAL_ERROR "Windows DLLs currently not supported")
     else()
         message(STATUS "Building shared libraries")
@@ -227,7 +227,7 @@ endif()
 CHECK_C_SOURCE_COMPILES("void *aa_test(void *x) { return __builtin_assume_aligned(x, 16);}\nint main(void) { return 0; }" HAVE_CC_BUILTIN_ASSUME_ALIGNED)
 CHECK_CXX_SOURCE_COMPILES("void *aa_test(void *x) { return __builtin_assume_aligned(x, 16);}\nint main(void) { return 0; }" HAVE_CXX_BUILTIN_ASSUME_ALIGNED)
 
-if (NOT WIN32)
+if (MINGW OR NOT WIN32)
 set(C_FLAGS_TO_CHECK
 # Variable length arrays are way bad, most especially at run time
 "-Wvla"
@@ -314,7 +314,7 @@ if(CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
     set(FREEBSD true)
 endif(CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
 
-if(NOT WIN32)
+if(MINGW OR NOT WIN32)
 if(CMAKE_C_COMPILER_ID MATCHES "Intel")
     SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -diag-error 10006 -diag-disable 177 -diag-disable 2304 -diag-disable 2305 -diag-disable 2338 -diag-disable 1418 -diag-disable=remark")
 endif()
@@ -351,7 +351,7 @@ add_subdirectory(src/fdr)
 
 include_directories(${PROJECT_BINARY_DIR}/src/fdr)
 
-if(NOT WIN32)
+if(MINGW OR NOT WIN32)
 set(RAGEL_C_FLAGS "-Wno-unused")
 endif()
 
@@ -944,6 +944,6 @@ if (BUILD_STATIC_AND_SHARED OR BUILD_SHARED_LIBS)
 install(TARGETS hs_shared DESTINATION lib)
 endif()
 
-if(NOT WIN32)
+if(MINGW OR NOT WIN32)
     add_subdirectory(examples)
 endif()

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Boris Nagaev <bnagaev@gmail.com>
Date: Wed, 18 May 2016 07:55:44 +0200
Subject: [PATCH] add compile flag "-posix" to fix printf %llu

See https://lists.nongnu.org/archive/html/mingw-cross-env-list/2013-04/msg00024.html
The similar problem occurred in examples/simplegrep.c

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1111111..2222222 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -200,6 +200,11 @@ else()
 
 endif()
 
+if (MINGW)
+    set(EXTRA_C_FLAGS "${EXTRA_C_FLAGS} -posix")
+    set(EXTRA_CXX_FLAGS "${EXTRA_CXX_FLAGS} -posix")
+endif()
+
 CHECK_INCLUDE_FILES(unistd.h HAVE_UNISTD_H)
 CHECK_INCLUDE_FILES(intrin.h HAVE_C_INTRIN_H)
 CHECK_INCLUDE_FILE_CXX(intrin.h HAVE_CXX_INTRIN_H)
diff --git a/libhs.pc.in b/libhs.pc.in
index 1111111..2222222 100644
--- a/libhs.pc.in
+++ b/libhs.pc.in
@@ -8,4 +8,4 @@ Description: Intel(R) Hyperscan Library
 Version: @HS_VERSION@
 Libs: -L${libdir} -lhs
 Libs.private: -lstdc++ -lm
-Cflags: -I${includedir}/hs
+Cflags: -I${includedir}/hs -posix

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Boris Nagaev <bnagaev@gmail.com>
Date: Wed, 18 May 2016 07:57:11 +0200
Subject: [PATCH] fix linking errors in shared mode

libcorpusomatic depends on libhs (for example, it uses symbol
ue2::ReportManager::getReport). DLL fails to be linked if
sime symbols are not resolved.

diff --git a/util/CMakeLists.txt b/util/CMakeLists.txt
index 1111111..2222222 100644
--- a/util/CMakeLists.txt
+++ b/util/CMakeLists.txt
@@ -26,5 +26,5 @@ SET(corpusomatic_SRCS
     ng_find_matches.h
     ng_find_matches.cpp
 )
-add_library(corpusomatic ${corpusomatic_SRCS})
+add_library(corpusomatic STATIC ${corpusomatic_SRCS})
 

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Boris Nagaev <bnagaev@gmail.com>
Date: Wed, 18 May 2016 07:59:57 +0200
Subject: [PATCH] install .dll to bin/, not to lib/


diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1111111..2222222 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -926,7 +926,10 @@ if (BUILD_STATIC_AND_SHARED OR BUILD_SHARED_LIBS)
         OUTPUT_NAME hs_runtime
         MACOSX_RPATH ON
         LINKER_LANGUAGE C)
-    install(TARGETS hs_runtime_shared DESTINATION lib)
+    install(TARGETS hs_runtime_shared
+        RUNTIME DESTINATION bin
+        ARCHIVE DESTINATION lib
+        LIBRARY DESTINATION lib)
 endif()
 
 # we want the static lib for testing
@@ -946,7 +949,10 @@ if (BUILD_STATIC_AND_SHARED OR BUILD_SHARED_LIBS)
         VERSION ${LIB_VERSION}
         SOVERSION ${LIB_SOVERSION}
         MACOSX_RPATH ON)
-install(TARGETS hs_shared DESTINATION lib)
+install(TARGETS hs_shared
+    RUNTIME DESTINATION bin
+    ARCHIVE DESTINATION lib
+    LIBRARY DESTINATION lib)
 endif()
 
 if(MINGW OR NOT WIN32)
