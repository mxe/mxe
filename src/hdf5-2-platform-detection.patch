This file is part of MXE. See LICENSE.md for licensing information.

Contains ad hoc patches for cross building.

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: brodieG <brodieG@users.noreply.github.com>
Date: Thu, 28 Jul 2022 01:08:00 +0000
Subject: [PATCH 1/1] Octave fixes


diff --git a/bin/make_lib_settings b/bin/make_lib_settings
new file mode 100644
index 0000000..7a66580
--- /dev/null
+++ b/bin/make_lib_settings
@@ -0,0 +1,45 @@
+#!/usr/bin/perl -w
+require 5.003;
+
+print "/* Generated automatically by H5make_libsettings -- do not edit */
+
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the files COPYING and Copyright.html.  COPYING can be found at the root   *
+ * of the source code distribution tree; Copyright.html can be found at the  *
+ * root level of an installed copy of the electronic HDF5 document set and   *
+ * is linked from the top-level documents page.  It can also be found at     *
+ * http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          *
+ * access to either file, you may request a copy from help\@hdfgroup.org.     *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ * Created:		Dec 26, 2012
+ *			
+ *
+ * Purpose:		This machine-generated source code contains
+ *			information about the library build configuration
+ *
+ * Modifications:
+ *
+ *	DO NOT MAKE MODIFICATIONS TO THIS FILE!
+ *	It was generated by code in `H5make_libsettings.c'.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+char H5libhdf5_settings[]=
+";
+
+while (<>) {
+  chop;
+  print "\t\"$_\\n\"\n";
+}
+
+print ";\n"
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 1111111..2222222 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -1087,6 +1087,7 @@ else ()
   endif ()
 endif ()
 
+if (NOT EXISTS "${HDF5_GENERATED_SOURCE_DIR}/H5lib_settings.c")
 add_executable (H5make_libsettings ${HDF5_SRC_DIR}/H5make_libsettings.c)
 target_include_directories (H5make_libsettings PRIVATE "${HDF5_SRC_DIR};${HDF5_BINARY_DIR};$<$<BOOL:${HDF5_ENABLE_PARALLEL}>:${MPI_C_INCLUDE_DIRS}>")
 target_compile_definitions(H5make_libsettings PUBLIC ${HDF_EXTRA_C_FLAGS} ${HDF_EXTRA_FLAGS})
@@ -1097,28 +1098,49 @@ target_link_libraries (H5make_libsettings
 )
 
 add_custom_command (
-    OUTPUT ${HDF5_BINARY_DIR}/H5lib_settings.c
-           ${HDF5_BINARY_DIR}/gen_SRCS.stamp2
+    OUTPUT ${HDF5_GENERATED_SOURCE_DIR}/H5lib_settings.c
+           ${HDF5_GENERATED_SOURCE_DIR}/gen_SRCS.stamp2
     COMMAND ${CMAKE_CROSSCOMPILING_EMULATOR} $<TARGET_FILE:H5make_libsettings>
-    ARGS ${HDF5_BINARY_DIR}/H5lib_settings.c
+    ARGS ${HDF5_GENERATED_SOURCE_DIR}/H5lib_settings.c
     COMMAND    ${CMAKE_COMMAND}
     ARGS       -E touch ${HDF5_GENERATED_SOURCE_DIR}/gen_SRCS.stamp2
     DEPENDS H5make_libsettings
-    WORKING_DIRECTORY ${HDF5_BINARY_DIR}
+    WORKING_DIRECTORY ${HDF5_GENERATED_SOURCE_DIR}
 )
-set_source_files_properties (${HDF5_BINARY_DIR}/H5lib_settings.c PROPERTIES GENERATED TRUE)
+set_source_files_properties (${HDF5_GENERATED_SOURCE_DIR}/H5lib_settings.c PROPERTIES GENERATED TRUE)
 if (BUILD_SHARED_LIBS)
   add_custom_command (
-      OUTPUT ${HDF5_BINARY_DIR}/shared/H5lib_settings.c
-             ${HDF5_BINARY_DIR}/shared/shared_gen_SRCS.stamp2
+      OUTPUT ${HDF5_GENERATED_SOURCE_DIR}/shared/H5lib_settings.c
+             ${HDF5_GENERATED_SOURCE_DIR}/shared/shared_gen_SRCS.stamp2
       COMMAND    ${CMAKE_COMMAND}
-      ARGS       -E copy_if_different "${HDF5_BINARY_DIR}/H5lib_settings.c" "${HDF5_BINARY_DIR}/shared/H5lib_settings.c"
+      ARGS       -E copy_if_different "${HDF5_GENERATED_SOURCE_DIR}/H5lib_settings.c" "${HDF5_GENERATED_SOURCE_DIR}/shared/H5lib_settings.c"
       COMMAND    ${CMAKE_COMMAND}
       ARGS       -E touch ${HDF5_GENERATED_SOURCE_DIR}/shared/shared_gen_SRCS.stamp2
-      DEPENDS    ${HDF5_BINARY_DIR}/H5lib_settings.c
-      WORKING_DIRECTORY ${HDF5_BINARY_DIR}
+      DEPENDS    ${HDF5_GENERATED_SOURCE_DIR}/H5lib_settings.c
+      WORKING_DIRECTORY ${HDF5_GENERATED_SOURCE_DIR}
+  )
+  set_source_files_properties (${HDF5_GENERATED_SOURCE_DIR}/shared/H5lib_settings.c PROPERTIES GENERATED TRUE)
+endif ()
+else ()
+  add_custom_command (
+      OUTPUT ${HDF5_GENERATED_SOURCE_DIR}/gen_SRCS.stamp2
+      COMMAND    ${CMAKE_COMMAND}
+      ARGS       -E touch ${HDF5_GENERATED_SOURCE_DIR}/gen_SRCS.stamp2
+      DEPENDS    ${HDF5_GENERATED_SOURCE_DIR}/H5lib_settings.c
+      WORKING_DIRECTORY ${HDF5_GENERATED_SOURCE_DIR}
   )
-  set_source_files_properties (${HDF5_BINARY_DIR}/shared/H5lib_settings.c PROPERTIES GENERATED TRUE)
+  if (BUILD_SHARED_LIBS)
+    add_custom_command (
+        OUTPUT     ${HDF5_GENERATED_SOURCE_DIR}/shared/shared_gen_SRCS.stamp2
+        COMMAND    ${CMAKE_COMMAND}
+        ARGS       -E copy_if_different "${HDF5_GENERATED_SOURCE_DIR}/H5lib_settings.c" "${HDF5_GENERATED_SOURCE_DIR}/shared/H5lib_settings.c"
+        COMMAND    ${CMAKE_COMMAND}
+        ARGS       -E touch ${HDF5_GENERATED_SOURCE_DIR}/shared/shared_gen_SRCS.stamp2
+        DEPENDS    ${HDF5_GENERATED_SOURCE_DIR}/H5lib_settings.c
+        WORKING_DIRECTORY ${HDF5_GENERATED_SOURCE_DIR}
+    )
+    set_source_files_properties (${HDF5_GENERATED_SOURCE_DIR}/shared/H5lib_settings.c PROPERTIES GENERATED TRUE)
+  endif ()
 endif ()
 
 ## all_packages="AC,B,B2,D,F,FA,FL,FS,HL,I,O,S,ST,T,Z"
@@ -1129,7 +1151,7 @@ option (HDF5_ENABLE_DEBUG_APIS "Turn on extra debug output in all packages" OFF)
 # Add H5Tinit source to build - generated by H5detect/CMake at configure time
 #-----------------------------------------------------------------------------
 if (NOT ONLY_SHARED_LIBS)
-  set (gen_SRCS ${HDF5_GENERATED_SOURCE_DIR}/H5Tinit.c ${HDF5_BINARY_DIR}/H5lib_settings.c)
+  set (gen_SRCS ${HDF5_GENERATED_SOURCE_DIR}/H5Tinit.c ${HDF5_GENERATED_SOURCE_DIR}/H5lib_settings.c)
   add_custom_target (gen_${HDF5_LIB_TARGET} ALL DEPENDS ${HDF5_GENERATED_SOURCE_DIR}/gen_SRCS.stamp1 ${HDF5_GENERATED_SOURCE_DIR}/gen_SRCS.stamp2)
 
   add_library (${HDF5_LIB_TARGET} STATIC ${common_SRCS} ${gen_SRCS} ${H5_PUBLIC_HEADERS} ${H5_PRIVATE_HEADERS} ${H5_GENERATED_HEADERS})
@@ -1164,7 +1186,7 @@ if (NOT ONLY_SHARED_LIBS)
 endif ()
 
 if (BUILD_SHARED_LIBS)
-  set (shared_gen_SRCS ${HDF5_GENERATED_SOURCE_DIR}/shared/H5Tinit.c ${HDF5_BINARY_DIR}/shared/H5lib_settings.c)
+  set (shared_gen_SRCS ${HDF5_GENERATED_SOURCE_DIR}/shared/H5Tinit.c ${HDF5_GENERATED_SOURCE_DIR}/shared/H5lib_settings.c)
   add_custom_target (gen_${HDF5_LIBSH_TARGET} ALL DEPENDS ${HDF5_GENERATED_SOURCE_DIR}/shared/shared_gen_SRCS.stamp1 ${HDF5_GENERATED_SOURCE_DIR}/shared/shared_gen_SRCS.stamp2)
 
   add_library (${HDF5_LIBSH_TARGET} SHARED ${common_SRCS} ${shared_gen_SRCS} ${H5_PUBLIC_HEADERS} ${H5_PRIVATE_HEADERS} ${H5_GENERATED_HEADERS})
diff --git a/src/H5Tinit.c.mingw32 b/src/H5Tinit.c.mingw32
new file mode 100644
index 0000000..c271029
--- /dev/null
+++ b/src/H5Tinit.c.mingw32
@@ -0,0 +1,977 @@
+/* Generated automatically by H5detect -- do not edit */
+
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Created:		May 26, 2020
+ *			
+ *
+ * Purpose:		This machine-generated source code contains
+ *			information about the various integer and
+ *			floating point numeric formats found on this
+ *			architecture.  The parameters below should be
+ *			checked carefully and errors reported to the
+ *			HDF5 maintainer.
+ *			
+ *			Each of the numeric formats listed below are
+ *			printed from most significant bit to least
+ *			significant bit even though the actual bytes
+ *			might be stored in a different order in
+ *			memory.     The integers above each binary byte
+ *			indicate the relative order of the bytes in
+ *			memory; little-endian machines have
+ *			decreasing numbers while big-endian machines
+ *			have increasing numbers.
+ *			
+ *			The fields of the numbers are printed as
+ *			letters with `S' for the mantissa sign bit,
+ *			`M' for the mantissa magnitude, and `E' for
+ *			the exponent.  The exponent has an associated
+ *			bias which can be subtracted to find the
+ *			true exponent.    The radix point is assumed
+ *			to be before the first `M' bit.     Any bit
+ *			of a floating-point value not falling into one
+ *			of these categories is printed as a question
+ *			mark.  Bits of integer types are printed as
+ *			`I' for 2's complement and `U' for magnitude.
+ *			
+ *			If the most significant bit of the normalized
+ *			mantissa (always a `1' except for `0.0') is
+ *			not stored then an `implicit=yes' appears
+ *			under the field description.  In this case,
+ *			the radix point is still assumed to be
+ *			before the first `M' but after the implicit
+ *			bit.
+ *
+ * Modifications:
+ *
+ *	DO NOT MAKE MODIFICATIONS TO THIS FILE!
+ *	It was generated by code in `H5detect.c'.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/****************/
+/* Module Setup */
+/****************/
+
+#include "H5Tmodule.h"          /* This source code file is part of the H5T module */
+
+
+/***********/
+/* Headers */
+/***********/
+#include "H5private.h"        /* Generic Functions            */
+#include "H5Eprivate.h"        /* Error handling              */
+#include "H5FLprivate.h"    /* Free Lists                */
+#include "H5Iprivate.h"        /* IDs                      */
+#include "H5Tpkg.h"        /* Datatypes                 */
+
+
+/****************/
+/* Local Macros */
+/****************/
+
+
+/******************/
+/* Local Typedefs */
+/******************/
+
+
+/********************/
+/* Package Typedefs */
+/********************/
+
+
+/********************/
+/* Local Prototypes */
+/********************/
+
+
+/********************/
+/* Public Variables */
+/********************/
+
+
+/*****************************/
+/* Library Private Variables */
+/*****************************/
+
+
+/*********************/
+/* Package Variables */
+/*********************/
+
+
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+
+
+/*-------------------------------------------------------------------------
+ * Function:    H5T__init_native
+ *
+ * Purpose:    Initialize pre-defined native datatypes from code generated
+ *              during the library configuration by H5detect.
+ *
+ * Return:    Success:    non-negative
+ *        Failure:    negative
+ *
+ * Programmer:    Robb Matzke
+ *              Wednesday, December 16, 1998
+ *
+ *-------------------------------------------------------------------------
+ */
+herr_t
+H5T__init_native(void)
+{
+    H5T_t    *dt = NULL;
+    herr_t    ret_value = SUCCEED;
+
+    FUNC_ENTER_PACKAGE
+
+   /*
+    *    0
+    * IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_SCHAR_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_SCHAR_ALIGN_g = 1;
+    H5T_NATIVE_SCHAR_COMP_ALIGN_g = 1;
+
+   /*
+    *    0
+    * UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UCHAR_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UCHAR_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_SHORT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_SHORT_ALIGN_g = 1;
+    H5T_NATIVE_SHORT_COMP_ALIGN_g = 2;
+
+   /*
+    *    1        0
+    * UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_USHORT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_USHORT_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_ALIGN_g = 1;
+    H5T_NATIVE_INT_COMP_ALIGN_g = 4;
+
+   /*
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_LONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_LONG_ALIGN_g = 1;
+    H5T_NATIVE_LONG_COMP_ALIGN_g = 4;
+
+   /*
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_ULONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_ULONG_ALIGN_g = 1;
+
+   /*
+    *    0
+    * IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_LEAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_LEAST8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_LEAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_LEAST8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_FAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_FAST8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_FAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_FAST8_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT16_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT16_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_LEAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_LEAST16_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_LEAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_LEAST16_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_FAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_FAST16_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_FAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_FAST16_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT32_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT32_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_LEAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_LEAST32_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_LEAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_LEAST32_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_FAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_FAST32_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_FAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_FAST32_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_LEAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_LEAST64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_LEAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_LEAST64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_FAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_FAST64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_FAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_FAST64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_LLONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_LLONG_ALIGN_g = 1;
+    H5T_NATIVE_LLONG_COMP_ALIGN_g = 8;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_ULLONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_ULLONG_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * SEEEEEEE EMMMMMMM MMMMMMMM MMMMMMMM
+    * Implicit bit? yes
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_FLOAT;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.f.sign = 31;
+    dt->shared->u.atomic.u.f.epos = 23;
+    dt->shared->u.atomic.u.f.esize = 8;
+    dt->shared->u.atomic.u.f.ebias = 0x0000007f;
+    dt->shared->u.atomic.u.f.mpos = 0;
+    dt->shared->u.atomic.u.f.msize = 23;
+    dt->shared->u.atomic.u.f.norm = H5T_NORM_IMPLIED;
+    dt->shared->u.atomic.u.f.pad = H5T_PAD_ZERO;
+    if((H5T_NATIVE_FLOAT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_FLOAT_ALIGN_g = 1;
+    H5T_NATIVE_FLOAT_COMP_ALIGN_g = 4;
+
+   /*
+    *    7        6        5        4
+    * SEEEEEEE EEEEMMMM MMMMMMMM MMMMMMMM
+    *    3        2        1        0
+    * MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM
+    * Implicit bit? yes
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_FLOAT;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.f.sign = 63;
+    dt->shared->u.atomic.u.f.epos = 52;
+    dt->shared->u.atomic.u.f.esize = 11;
+    dt->shared->u.atomic.u.f.ebias = 0x000003ff;
+    dt->shared->u.atomic.u.f.mpos = 0;
+    dt->shared->u.atomic.u.f.msize = 52;
+    dt->shared->u.atomic.u.f.norm = H5T_NORM_IMPLIED;
+    dt->shared->u.atomic.u.f.pad = H5T_PAD_ZERO;
+    if((H5T_NATIVE_DOUBLE_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_DOUBLE_ALIGN_g = 1;
+    H5T_NATIVE_DOUBLE_COMP_ALIGN_g = 8;
+
+   /*
+    *   11       10        9        8
+    * ???????? ???????? SEEEEEEE EEEEEEEE
+    *    7        6        5        4
+    * MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM
+    *    3        2        1        0
+    * MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM
+    * Implicit bit? no
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_FLOAT;
+    dt->shared->size = 12;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 80;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.f.sign = 79;
+    dt->shared->u.atomic.u.f.epos = 64;
+    dt->shared->u.atomic.u.f.esize = 15;
+    dt->shared->u.atomic.u.f.ebias = 0x00003fff;
+    dt->shared->u.atomic.u.f.mpos = 0;
+    dt->shared->u.atomic.u.f.msize = 64;
+    dt->shared->u.atomic.u.f.norm = H5T_NORM_NONE;
+    dt->shared->u.atomic.u.f.pad = H5T_PAD_ZERO;
+    if((H5T_NATIVE_LDOUBLE_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_LDOUBLE_ALIGN_g = 1;
+    H5T_NATIVE_LDOUBLE_COMP_ALIGN_g = 4;
+
+    /* Set the native order for this machine */
+    H5T_native_order_g = H5T_ORDER_LE;
+
+    /* Structure alignment for pointers, vlen and reference types */
+    H5T_POINTER_COMP_ALIGN_g = 4;
+    H5T_HVL_COMP_ALIGN_g = 4;
+    H5T_HOBJREF_COMP_ALIGN_g = 8;
+    H5T_HDSETREGREF_COMP_ALIGN_g = 1;
+    H5T_REF_COMP_ALIGN_g = 8;
+
+done:
+    if(ret_value < 0) {
+        if(dt != NULL) {
+            dt->shared = H5FL_FREE(H5T_shared_t, dt->shared);
+            dt = H5FL_FREE(H5T_t, dt);
+        } /* end if */
+    } /* end if */
+
+    FUNC_LEAVE_NOAPI(ret_value);
+} /* end H5T__init_native() */
+
+/****************************************/
+/* ALIGNMENT and signal-handling status */
+/****************************************/
+/* Signal() support: yes */
+/* setjmp() support: no */
+/* longjmp() support: yes */
+/* sigsetjmp() support: no */
+/* siglongjmp() support: no */
+/* sigprocmask() support: no */
+
+/******************************/
+/* signal handlers statistics */
+/******************************/
+/* signal_handlers tested: 15 times */
+/* sigbus_handler called: 5 times */
+/* sigsegv_handler called: 5 times */
+/* sigill_handler called: 5 times */
diff --git a/src/H5Tinit.c.mingw64 b/src/H5Tinit.c.mingw64
new file mode 100644
index 0000000..f9a8fc3
--- /dev/null
+++ b/src/H5Tinit.c.mingw64
@@ -0,0 +1,979 @@
+/* Generated automatically by H5detect -- do not edit */
+
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Created:		May 22, 2020
+ *			
+ *
+ * Purpose:		This machine-generated source code contains
+ *			information about the various integer and
+ *			floating point numeric formats found on this
+ *			architecture.  The parameters below should be
+ *			checked carefully and errors reported to the
+ *			HDF5 maintainer.
+ *			
+ *			Each of the numeric formats listed below are
+ *			printed from most significant bit to least
+ *			significant bit even though the actual bytes
+ *			might be stored in a different order in
+ *			memory.     The integers above each binary byte
+ *			indicate the relative order of the bytes in
+ *			memory; little-endian machines have
+ *			decreasing numbers while big-endian machines
+ *			have increasing numbers.
+ *			
+ *			The fields of the numbers are printed as
+ *			letters with `S' for the mantissa sign bit,
+ *			`M' for the mantissa magnitude, and `E' for
+ *			the exponent.  The exponent has an associated
+ *			bias which can be subtracted to find the
+ *			true exponent.    The radix point is assumed
+ *			to be before the first `M' bit.     Any bit
+ *			of a floating-point value not falling into one
+ *			of these categories is printed as a question
+ *			mark.  Bits of integer types are printed as
+ *			`I' for 2's complement and `U' for magnitude.
+ *			
+ *			If the most significant bit of the normalized
+ *			mantissa (always a `1' except for `0.0') is
+ *			not stored then an `implicit=yes' appears
+ *			under the field description.  In this case,
+ *			the radix point is still assumed to be
+ *			before the first `M' but after the implicit
+ *			bit.
+ *
+ * Modifications:
+ *
+ *	DO NOT MAKE MODIFICATIONS TO THIS FILE!
+ *	It was generated by code in `H5detect.c'.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/****************/
+/* Module Setup */
+/****************/
+
+#include "H5Tmodule.h"          /* This source code file is part of the H5T module */
+
+
+/***********/
+/* Headers */
+/***********/
+#include "H5private.h"        /* Generic Functions            */
+#include "H5Eprivate.h"        /* Error handling              */
+#include "H5FLprivate.h"    /* Free Lists                */
+#include "H5Iprivate.h"        /* IDs                      */
+#include "H5Tpkg.h"        /* Datatypes                 */
+
+
+/****************/
+/* Local Macros */
+/****************/
+
+
+/******************/
+/* Local Typedefs */
+/******************/
+
+
+/********************/
+/* Package Typedefs */
+/********************/
+
+
+/********************/
+/* Local Prototypes */
+/********************/
+
+
+/********************/
+/* Public Variables */
+/********************/
+
+
+/*****************************/
+/* Library Private Variables */
+/*****************************/
+
+
+/*********************/
+/* Package Variables */
+/*********************/
+
+
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+
+
+/*-------------------------------------------------------------------------
+ * Function:    H5T__init_native
+ *
+ * Purpose:    Initialize pre-defined native datatypes from code generated
+ *              during the library configuration by H5detect.
+ *
+ * Return:    Success:    non-negative
+ *        Failure:    negative
+ *
+ * Programmer:    Robb Matzke
+ *              Wednesday, December 16, 1998
+ *
+ *-------------------------------------------------------------------------
+ */
+herr_t
+H5T__init_native(void)
+{
+    H5T_t    *dt = NULL;
+    herr_t    ret_value = SUCCEED;
+
+    FUNC_ENTER_PACKAGE
+
+   /*
+    *    0
+    * IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_SCHAR_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_SCHAR_ALIGN_g = 1;
+    H5T_NATIVE_SCHAR_COMP_ALIGN_g = 1;
+
+   /*
+    *    0
+    * UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UCHAR_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UCHAR_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_SHORT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_SHORT_ALIGN_g = 1;
+    H5T_NATIVE_SHORT_COMP_ALIGN_g = 2;
+
+   /*
+    *    1        0
+    * UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_USHORT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_USHORT_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_ALIGN_g = 1;
+    H5T_NATIVE_INT_COMP_ALIGN_g = 4;
+
+   /*
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_LONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_LONG_ALIGN_g = 1;
+    H5T_NATIVE_LONG_COMP_ALIGN_g = 4;
+
+   /*
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_ULONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_ULONG_ALIGN_g = 1;
+
+   /*
+    *    0
+    * IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_LEAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_LEAST8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_LEAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_LEAST8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_FAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_FAST8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_FAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_FAST8_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT16_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT16_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_LEAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_LEAST16_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_LEAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_LEAST16_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_FAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_FAST16_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_FAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_FAST16_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT32_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT32_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_LEAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_LEAST32_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_LEAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_LEAST32_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_FAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_FAST32_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_FAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_FAST32_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_LEAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_LEAST64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_LEAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_LEAST64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_FAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_FAST64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_FAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_FAST64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_LLONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_LLONG_ALIGN_g = 1;
+    H5T_NATIVE_LLONG_COMP_ALIGN_g = 8;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_ULLONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_ULLONG_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * SEEEEEEE EMMMMMMM MMMMMMMM MMMMMMMM
+    * Implicit bit? yes
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_FLOAT;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.f.sign = 31;
+    dt->shared->u.atomic.u.f.epos = 23;
+    dt->shared->u.atomic.u.f.esize = 8;
+    dt->shared->u.atomic.u.f.ebias = 0x0000007f;
+    dt->shared->u.atomic.u.f.mpos = 0;
+    dt->shared->u.atomic.u.f.msize = 23;
+    dt->shared->u.atomic.u.f.norm = H5T_NORM_IMPLIED;
+    dt->shared->u.atomic.u.f.pad = H5T_PAD_ZERO;
+    if((H5T_NATIVE_FLOAT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_FLOAT_ALIGN_g = 1;
+    H5T_NATIVE_FLOAT_COMP_ALIGN_g = 4;
+
+   /*
+    *    7        6        5        4
+    * SEEEEEEE EEEEMMMM MMMMMMMM MMMMMMMM
+    *    3        2        1        0
+    * MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM
+    * Implicit bit? yes
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_FLOAT;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.f.sign = 63;
+    dt->shared->u.atomic.u.f.epos = 52;
+    dt->shared->u.atomic.u.f.esize = 11;
+    dt->shared->u.atomic.u.f.ebias = 0x000003ff;
+    dt->shared->u.atomic.u.f.mpos = 0;
+    dt->shared->u.atomic.u.f.msize = 52;
+    dt->shared->u.atomic.u.f.norm = H5T_NORM_IMPLIED;
+    dt->shared->u.atomic.u.f.pad = H5T_PAD_ZERO;
+    if((H5T_NATIVE_DOUBLE_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_DOUBLE_ALIGN_g = 1;
+    H5T_NATIVE_DOUBLE_COMP_ALIGN_g = 8;
+
+   /*
+    *   15       14       13       12
+    * ???????? ???????? ???????? ????????
+    *   11       10        9        8
+    * ???????? ???????? SEEEEEEE EEEEEEEE
+    *    7        6        5        4
+    * MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM
+    *    3        2        1        0
+    * MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM
+    * Implicit bit? no
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_FLOAT;
+    dt->shared->size = 16;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 80;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.f.sign = 79;
+    dt->shared->u.atomic.u.f.epos = 64;
+    dt->shared->u.atomic.u.f.esize = 15;
+    dt->shared->u.atomic.u.f.ebias = 0x00003fff;
+    dt->shared->u.atomic.u.f.mpos = 0;
+    dt->shared->u.atomic.u.f.msize = 64;
+    dt->shared->u.atomic.u.f.norm = H5T_NORM_NONE;
+    dt->shared->u.atomic.u.f.pad = H5T_PAD_ZERO;
+    if((H5T_NATIVE_LDOUBLE_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_LDOUBLE_ALIGN_g = 1;
+    H5T_NATIVE_LDOUBLE_COMP_ALIGN_g = 16;
+
+    /* Set the native order for this machine */
+    H5T_native_order_g = H5T_ORDER_LE;
+
+    /* Structure alignment for pointers, vlen and reference types */
+    H5T_POINTER_COMP_ALIGN_g = 8;
+    H5T_HVL_COMP_ALIGN_g = 8;
+    H5T_HOBJREF_COMP_ALIGN_g = 8;
+    H5T_HDSETREGREF_COMP_ALIGN_g = 1;
+    H5T_REF_COMP_ALIGN_g = 8;
+
+done:
+    if(ret_value < 0) {
+        if(dt != NULL) {
+            dt->shared = H5FL_FREE(H5T_shared_t, dt->shared);
+            dt = H5FL_FREE(H5T_t, dt);
+        } /* end if */
+    } /* end if */
+
+    FUNC_LEAVE_NOAPI(ret_value);
+} /* end H5T__init_native() */
+
+/****************************************/
+/* ALIGNMENT and signal-handling status */
+/****************************************/
+/* Signal() support: yes */
+/* setjmp() support: yes */
+/* longjmp() support: yes */
+/* sigsetjmp() support: no */
+/* siglongjmp() support: no */
+/* sigprocmask() support: no */
+
+/******************************/
+/* signal handlers statistics */
+/******************************/
+/* signal_handlers tested: 15 times */
+/* sigbus_handler called: 5 times */
+/* sigsegv_handler called: 5 times */
+/* sigill_handler called: 5 times */
diff --git a/src/H5lib_settings.c.mingw32 b/src/H5lib_settings.c.mingw32
new file mode 100644
index 0000000..ce90d85
--- /dev/null
+++ b/src/H5lib_settings.c.mingw32
@@ -0,0 +1,121 @@
+/* Generated automatically by H5make_libsettings -- do not edit */
+
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Created:		May 26, 2020
+ *			
+ *
+ * Purpose:		This machine-generated source code contains
+ *			information about the library build configuration
+ *
+ * Modifications:
+ *
+ *	DO NOT MAKE MODIFICATIONS TO THIS FILE!
+ *	It was generated by code in `H5make_libsettings.c'.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+char H5libhdf5_settings[]=
+	"        SUMMARY OF THE HDF5 CONFIGURATION\n"
+	"        =================================\n"
+	"\n"
+	"General Information:\n"
+	"-------------------\n"
+	"                   HDF5 Version: 1.12.0\n"
+	"                  Configured on: 2020-05-26\n"
+	"                  Configured by: Unix Makefiles\n"
+	"                    Host system: Linux-5.4.0-31-generic\n"
+	"              Uname information: Windows\n"
+	"                       Byte sex: little-endian\n"
+	"             Installation point: \n"
+	"\n"
+	"Compiling Options:\n"
+	"------------------\n"
+	"                     Build Mode: Release\n"
+	"              Debugging Symbols: OFF\n"
+	"                        Asserts: OFF\n"
+	"                      Profiling: OFF\n"
+	"             Optimization Level: OFF\n"
+	"\n"
+	"Linking Options:\n"
+	"----------------\n"
+	"                      Libraries: \n"
+	"  Statically Linked Executables: OFF\n"
+	"                        LDFLAGS: \n"
+	"                     H5_LDFLAGS: \n"
+	"                     AM_LDFLAGS: \n"
+	"                Extra libraries: m;ws2_32;wsock32\n"
+	"                       Archiver: /home/osboxes/Documents/Repositories/Octave/mxe-octave-w32/usr/bin/i686-w64-mingw32-ar\n"
+	"                         Ranlib: /home/osboxes/Documents/Repositories/Octave/mxe-octave-w32/usr/bin/i686-w64-mingw32-ranlib\n"
+	"\n"
+	"Languages:\n"
+	"----------\n"
+	"                              C: YES\n"
+	"                     C Compiler: /home/osboxes/Documents/Repositories/Octave/mxe-octave-w32/usr/bin/i686-w64-mingw32-gcc 9.3.0\n"
+	"                       CPPFLAGS: \n"
+	"                    H5_CPPFLAGS: \n"
+	"                    AM_CPPFLAGS: \n"
+	"                         CFLAGS:   -std=c99  -fstdarg-opt  -Wall -Wcast-qual -Wconversion -Wextra -Wfloat-equal -Wformat=2 -Winit-self -Winvalid-pch -Wmissing-include-dirs -Wno-c++-compat -Wno-format-nonliteral -Wshadow -Wundef -Wwrite-strings -pedantic -fmessage-length=0\n"
+	"                      H5_CFLAGS: \n"
+	"                      AM_CFLAGS: \n"
+	"               Shared C Library: YES\n"
+	"               Static C Library: NO\n"
+	"\n"
+	"                        Fortran: OFF\n"
+	"               Fortran Compiler: /home/osboxes/Documents/Repositories/Octave/mxe-octave-w32/usr/bin/i686-w64-mingw32-gfortran \n"
+	"                  Fortran Flags: \n"
+	"               H5 Fortran Flags: \n"
+	"               AM Fortran Flags: \n"
+	"         Shared Fortran Library: YES\n"
+	"         Static Fortran Library: NO\n"
+	"\n"
+	"                            C++: OFF\n"
+	"                   C++ Compiler: /home/osboxes/Documents/Repositories/Octave/mxe-octave-w32/usr/bin/i686-w64-mingw32-g++ \n"
+	"                      C++ Flags:  \n"
+	"                   H5 C++ Flags: \n"
+	"                   AM C++ Flags: \n"
+	"             Shared C++ Library: YES\n"
+	"             Static C++ Library: NO\n"
+	"\n"
+	"                            JAVA: OFF\n"
+	"                 JAVA Compiler:  \n"
+	"\n"
+	"Features:\n"
+	"---------\n"
+	"                   Parallel HDF5: OFF\n"
+	"Parallel Filtered Dataset Writes: \n"
+	"              Large Parallel I/O: \n"
+	"              High-level library: ON\n"
+	"                Build HDF5 Tests: OFF\n"
+	"                Build HDF5 Tools: ON\n"
+	"                    Threadsafety: OFF\n"
+	"             Default API mapping: v112\n"
+	"  With deprecated public symbols: ON\n"
+	"          I/O filters (external):  DEFLATE\n"
+	"                             MPE: \n"
+	"                      Direct VFD: \n"
+	"              (Read-Only) S3 VFD: \n"
+	"            (Read-Only) HDFS VFD: \n"
+	"                         dmalloc: \n"
+	"  Packages w/ extra debug output: \n"
+	"                     API Tracing: OFF\n"
+	"            Using memory checker: OFF\n"
+	" Memory allocation sanity checks: OFF\n"
+	"          Function Stack Tracing: OFF\n"
+	"       Strict File Format Checks: OFF\n"
+	"    Optimization Instrumentation: \n"
+;
+
diff --git a/src/H5lib_settings.c.mingw64 b/src/H5lib_settings.c.mingw64
new file mode 100644
index 0000000..41f03c9
--- /dev/null
+++ b/src/H5lib_settings.c.mingw64
@@ -0,0 +1,121 @@
+/* Generated automatically by H5make_libsettings -- do not edit */
+
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Created:		May 22, 2020
+ *			
+ *
+ * Purpose:		This machine-generated source code contains
+ *			information about the library build configuration
+ *
+ * Modifications:
+ *
+ *	DO NOT MAKE MODIFICATIONS TO THIS FILE!
+ *	It was generated by code in `H5make_libsettings.c'.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+char H5libhdf5_settings[]=
+	"        SUMMARY OF THE HDF5 CONFIGURATION\n"
+	"        =================================\n"
+	"\n"
+	"General Information:\n"
+	"-------------------\n"
+	"                   HDF5 Version: 1.12.0\n"
+	"                  Configured on: 2020-05-22\n"
+	"                  Configured by: Unix Makefiles\n"
+	"                    Host system: Linux-5.4.0-31-generic\n"
+	"              Uname information: Windows\n"
+	"                       Byte sex: little-endian\n"
+	"             Installation point: \n"
+	"\n"
+	"Compiling Options:\n"
+	"------------------\n"
+	"                     Build Mode: Release\n"
+	"              Debugging Symbols: OFF\n"
+	"                        Asserts: OFF\n"
+	"                      Profiling: OFF\n"
+	"             Optimization Level: OFF\n"
+	"\n"
+	"Linking Options:\n"
+	"----------------\n"
+	"                      Libraries: \n"
+	"  Statically Linked Executables: OFF\n"
+	"                        LDFLAGS: \n"
+	"                     H5_LDFLAGS: \n"
+	"                     AM_LDFLAGS: \n"
+	"                Extra libraries: m;ws2_32;wsock32\n"
+	"                       Archiver: /home/osboxes/Documents/Repositories/Octave/mxe-octave/usr/bin/x86_64-w64-mingw32-ar\n"
+	"                         Ranlib: /home/osboxes/Documents/Repositories/Octave/mxe-octave/usr/bin/x86_64-w64-mingw32-ranlib\n"
+	"\n"
+	"Languages:\n"
+	"----------\n"
+	"                              C: YES\n"
+	"                     C Compiler: /home/osboxes/Documents/Repositories/Octave/mxe-octave/usr/bin/x86_64-w64-mingw32-gcc 9.3.0\n"
+	"                       CPPFLAGS: \n"
+	"                    H5_CPPFLAGS: \n"
+	"                    AM_CPPFLAGS: \n"
+	"                         CFLAGS:   -std=c99  -fstdarg-opt  -Wall -Wcast-qual -Wconversion -Wextra -Wfloat-equal -Wformat=2 -Winit-self -Winvalid-pch -Wmissing-include-dirs -Wno-c++-compat -Wno-format-nonliteral -Wshadow -Wundef -Wwrite-strings -pedantic -fmessage-length=0\n"
+	"                      H5_CFLAGS: \n"
+	"                      AM_CFLAGS: \n"
+	"               Shared C Library: YES\n"
+	"               Static C Library: NO\n"
+	"\n"
+	"                        Fortran: OFF\n"
+	"               Fortran Compiler: /home/osboxes/Documents/Repositories/Octave/mxe-octave/usr/bin/x86_64-w64-mingw32-gfortran \n"
+	"                  Fortran Flags: \n"
+	"               H5 Fortran Flags: \n"
+	"               AM Fortran Flags: \n"
+	"         Shared Fortran Library: YES\n"
+	"         Static Fortran Library: NO\n"
+	"\n"
+	"                            C++: OFF\n"
+	"                   C++ Compiler: /home/osboxes/Documents/Repositories/Octave/mxe-octave/usr/bin/x86_64-w64-mingw32-g++ \n"
+	"                      C++ Flags:  \n"
+	"                   H5 C++ Flags: \n"
+	"                   AM C++ Flags: \n"
+	"             Shared C++ Library: YES\n"
+	"             Static C++ Library: NO\n"
+	"\n"
+	"                            JAVA: OFF\n"
+	"                 JAVA Compiler:  \n"
+	"\n"
+	"Features:\n"
+	"---------\n"
+	"                   Parallel HDF5: OFF\n"
+	"Parallel Filtered Dataset Writes: \n"
+	"              Large Parallel I/O: \n"
+	"              High-level library: ON\n"
+	"                Build HDF5 Tests: OFF\n"
+	"                Build HDF5 Tools: ON\n"
+	"                    Threadsafety: OFF\n"
+	"             Default API mapping: v112\n"
+	"  With deprecated public symbols: ON\n"
+	"          I/O filters (external):  DEFLATE\n"
+	"                             MPE: \n"
+	"                      Direct VFD: \n"
+	"              (Read-Only) S3 VFD: \n"
+	"            (Read-Only) HDFS VFD: \n"
+	"                         dmalloc: \n"
+	"  Packages w/ extra debug output: \n"
+	"                     API Tracing: OFF\n"
+	"            Using memory checker: OFF\n"
+	" Memory allocation sanity checks: OFF\n"
+	"          Function Stack Tracing: OFF\n"
+	"       Strict File Format Checks: OFF\n"
+	"    Optimization Instrumentation: \n"
+;
+
diff --git a/src/H5win32defs.h b/src/H5win32defs.h
index 1111111..2222222 100644
--- a/src/H5win32defs.h
+++ b/src/H5win32defs.h
@@ -42,7 +42,7 @@ typedef __int64             h5_stat_size_t;
 #define HDisatty(F)         _isatty(F)
 
 /* The isnan function needs underscore in VS2012 and earlier */
-#if (_MSC_VER <= 1700)
+#if defined(_MSC_VER) && (_MSC_VER <= 1700)
   #define HDisnan(X)      _isnan(X)
 #endif /* MSC_VER < 1700 */
 
