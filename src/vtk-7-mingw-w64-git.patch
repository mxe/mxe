This file is part of MXE.
See index.html for further information.

This patch has been taken from the git url below:

From: David Partyka <david.partyka@kitware.com>
Date: Wed, 21 Sep 2011 13:19:30 +0000 (-0400)
Subject: Merge branch '11742_mingw64_compile_fixes' into release
X-Git-Tag: v5.10.0-rc1~108^2~1
X-Git-Url: http://vtk.org/gitweb?p=VTK.git;a=commitdiff_plain;h=be64234e8399145f1e2c099500779a9bcff75702;hp=7b4ad680f6b2b4b4211baf47de6588308db7e14f

Merge branch '11742_mingw64_compile_fixes' into release
---

diff --git a/Common/vtkWin32Header.h b/Common/vtkWin32Header.h
index 81b094a..a3edb90 100644
--- a/Common/vtkWin32Header.h
+++ b/Common/vtkWin32Header.h
@@ -102,9 +102,15 @@ Do_not_include_vtkWin32Header_directly__vtkSystemIncludes_includes_it;
 #  define vtkGetWindowLong GetWindowLong
 #  define vtkSetWindowLong SetWindowLong
 #  define vtkLONG LONG
+#  ifdef _WIN64
+#    define vtkGWL_WNDPROC GWLP_WNDPROC
+#    define vtkGWL_HINSTANCE GWLP_HINSTANCE
+#    define vtkGWL_USERDATA GWLP_USERDATA
+#  else
 #  define vtkGWL_WNDPROC GWL_WNDPROC
 #  define vtkGWL_HINSTANCE GWL_HINSTANCE
 #  define vtkGWL_USERDATA GWL_USERDATA
+#  endif
 #endif //
 
 #endif
diff --git a/Hybrid/vtkVideoSource.cxx b/Hybrid/vtkVideoSource.cxx
index 1fcdbe1..c40b845 100644
--- a/Hybrid/vtkVideoSource.cxx
+++ b/Hybrid/vtkVideoSource.cxx
@@ -32,9 +32,9 @@
 
 //---------------------------------------------------------------
 // Important FrameBufferMutex rules:
-// 
+//
 // The frame grabs are generally done asynchronously, and it is necessary
-// to ensure that when the frame buffer is valid when it is being written 
+// to ensure that when the frame buffer is valid when it is being written
 // to or read from
 //
 // The following information can only be changed within a mutex lock,
@@ -59,8 +59,8 @@
 //
 // AdvanceFrameBuffer()
 //
-// Any methods which might be called asynchronously must lock the 
-// mutex before reading the above information, and you must be very 
+// Any methods which might be called asynchronously must lock the
+// mutex before reading the above information, and you must be very
 // careful when accessing any information except for the above.
 // These methods include the following:
 //
@@ -74,13 +74,13 @@ vtkStandardNewMacro(vtkVideoSource);
 #if ( _MSC_VER >= 1300 ) // Visual studio .NET
 #pragma warning ( disable : 4311 )
 #pragma warning ( disable : 4312 )
-#endif 
+#endif
 
 //----------------------------------------------------------------------------
 vtkVideoSource::vtkVideoSource()
 {
   int i;
-  
+
   this->Initialized = 0;
 
   this->AutoAdvance = 1;
@@ -93,7 +93,7 @@ vtkVideoSource::vtkVideoSource()
     {
     this->FrameBufferExtent[i] = 0;
     }
-  
+
   this->Playing = 0;
   this->Recording = 0;
 
@@ -151,8 +151,8 @@ vtkVideoSource::vtkVideoSource()
 
 //----------------------------------------------------------------------------
 vtkVideoSource::~vtkVideoSource()
-{ 
-  // we certainly don't want to access a virtual 
+{
+  // we certainly don't want to access a virtual
   // function after the subclass has destructed!!
   this->vtkVideoSource::ReleaseSystemResources();
 
@@ -165,10 +165,10 @@ vtkVideoSource::~vtkVideoSource()
 void vtkVideoSource::PrintSelf(ostream& os, vtkIndent indent)
 {
   int idx;
-  
+
   this->Superclass::PrintSelf(os,indent);
-  
-  os << indent << "FrameSize: (" << this->FrameSize[0] << ", " 
+
+  os << indent << "FrameSize: (" << this->FrameSize[0] << ", "
      << this->FrameSize[1] << ", " << this->FrameSize[2] << ")\n";
 
   os << indent << "ClipRegion: (" << this->ClipRegion[0];
@@ -177,14 +177,14 @@ void vtkVideoSource::PrintSelf(ostream& os, vtkIndent indent)
     os << ", " << this->ClipRegion[idx];
     }
   os << ")\n";
-  
+
   os << indent << "DataSpacing: (" << this->DataSpacing[0];
   for (idx = 1; idx < 3; ++idx)
     {
     os << ", " << this->DataSpacing[idx];
     }
   os << ")\n";
-  
+
   os << indent << "DataOrigin: (" << this->DataOrigin[0];
   for (idx = 1; idx < 3; ++idx)
     {
@@ -205,7 +205,7 @@ void vtkVideoSource::PrintSelf(ostream& os, vtkIndent indent)
     os << ", " << this->OutputWholeExtent[idx];
     }
   os << ")\n";
-  
+
   os << indent << "FrameRate: " << this->FrameRate << "\n";
 
   os << indent << "FrameCount: " << this->FrameCount << "\n";
@@ -232,7 +232,7 @@ void vtkVideoSource::PrintSelf(ostream& os, vtkIndent indent)
 
 //----------------------------------------------------------------------------
 // Update the FrameBuffers according to any changes in the FrameBuffer*
-// information. 
+// information.
 // This function should always be called from within a FrameBufferMutex lock
 // and should never be called asynchronously.
 // It sets up the FrameBufferExtent
@@ -246,10 +246,10 @@ void vtkVideoSource::UpdateFrameBuffer()
   for (i = 0; i < 3; i++)
     {
     oldExt = this->FrameBufferExtent[2*i+1] - this->FrameBufferExtent[2*i] + 1;
-    this->FrameBufferExtent[2*i] = ((this->ClipRegion[2*i] > 0) 
-                             ? this->ClipRegion[2*i] : 0);  
-    this->FrameBufferExtent[2*i+1] = ((this->ClipRegion[2*i+1] < 
-                                       this->FrameSize[i]-1) 
+    this->FrameBufferExtent[2*i] = ((this->ClipRegion[2*i] > 0)
+                             ? this->ClipRegion[2*i] : 0);
+    this->FrameBufferExtent[2*i+1] = ((this->ClipRegion[2*i+1] <
+                                       this->FrameSize[i]-1)
                              ? this->ClipRegion[2*i+1] : this->FrameSize[i]-1);
 
     ext[i] = this->FrameBufferExtent[2*i+1] - this->FrameBufferExtent[2*i] + 1;
@@ -318,20 +318,20 @@ void vtkVideoSource::ReleaseSystemResources()
 //----------------------------------------------------------------------------
 void vtkVideoSource::SetFrameSize(int x, int y, int z)
 {
-  if (x == this->FrameSize[0] && 
-      y == this->FrameSize[1] && 
+  if (x == this->FrameSize[0] &&
+      y == this->FrameSize[1] &&
       z == this->FrameSize[2])
     {
     return;
     }
 
-  if (x < 1 || y < 1 || z < 1) 
+  if (x < 1 || y < 1 || z < 1)
     {
     vtkErrorMacro(<< "SetFrameSize: Illegal frame size");
     return;
     }
 
-  if (this->Initialized) 
+  if (this->Initialized)
     {
     this->FrameBufferMutex->Lock();
     this->FrameSize[0] = x;
@@ -349,7 +349,7 @@ void vtkVideoSource::SetFrameSize(int x, int y, int z)
 
   this->Modified();
 }
-    
+
 //----------------------------------------------------------------------------
 void vtkVideoSource::SetFrameRate(float rate)
 {
@@ -363,7 +363,7 @@ void vtkVideoSource::SetFrameRate(float rate)
 }
 
 //----------------------------------------------------------------------------
-void vtkVideoSource::SetClipRegion(int x0, int x1, int y0, int y1, 
+void vtkVideoSource::SetClipRegion(int x0, int x1, int y0, int y1,
                                    int z0, int z1)
 {
   if (this->ClipRegion[0] != x0 || this->ClipRegion[1] != x1 ||
@@ -371,7 +371,7 @@ void vtkVideoSource::SetClipRegion(int x0, int x1, int y0, int y1,
       this->ClipRegion[4] != z0 || this->ClipRegion[5] != z1)
     {
     this->Modified();
-    if (this->Initialized) 
+    if (this->Initialized)
       { // modify the FrameBufferExtent
       this->FrameBufferMutex->Lock();
       this->ClipRegion[0] = x0; this->ClipRegion[1] = x1;
@@ -422,7 +422,7 @@ void vtkVideoSource::InternalGrab()
                      this->FrameBufferBitsPerPixel + 7)/8;
   bytesPerRow = ((bytesPerRow + this->FrameBufferRowAlignment - 1) /
                  this->FrameBufferRowAlignment)*this->FrameBufferRowAlignment;
-  int totalSize = bytesPerRow * 
+  int totalSize = bytesPerRow *
                    (this->FrameBufferExtent[3]-this->FrameBufferExtent[2]+1) *
                    (this->FrameBufferExtent[5]-this->FrameBufferExtent[4]+1);
 
@@ -432,7 +432,7 @@ void vtkVideoSource::InternalGrab()
   ptr = reinterpret_cast<vtkUnsignedCharArray *>(this->FrameBuffer[index])->GetPointer(0);
 
   // Somebody should check this:
-  lptr = (int *)(((((long)ptr) + 3)/4)*4);
+  lptr = (int *)(((((intptr_t)ptr) + 3)/4)*4);
   i = totalSize/4;
 
   while (--i >= 0)
@@ -482,7 +482,7 @@ static inline void vtkSleep(double duration)
 
 //----------------------------------------------------------------------------
 // Sleep until the specified absolute time has arrived.
-// You must pass a handle to the current thread.  
+// You must pass a handle to the current thread.
 // If '0' is returned, then the thread was aborted before or during the wait.
 static int vtkThreadSleep(vtkMultiThreader::ThreadInfo *data, double time)
 {
@@ -506,7 +506,7 @@ static int vtkThreadSleep(vtkMultiThreader::ThreadInfo *data, double time)
       remaining = 0.1;
       }
 
-    // check to see if we are being told to quit 
+    // check to see if we are being told to quit
     data->ActiveFlagLock->Lock();
     int activeFlag = *(data->ActiveFlag);
     data->ActiveFlagLock->Unlock();
@@ -527,7 +527,7 @@ static int vtkThreadSleep(vtkMultiThreader::ThreadInfo *data, double time)
 static void *vtkVideoSourceRecordThread(vtkMultiThreader::ThreadInfo *data)
 {
   vtkVideoSource *self = (vtkVideoSource *)(data->UserData);
-  
+
   double startTime = vtkTimerLog::GetUniversalTime();
   double rate = self->GetFrameRate();
   int frame = 0;
@@ -544,7 +544,7 @@ static void *vtkVideoSourceRecordThread(vtkMultiThreader::ThreadInfo *data)
 
 //----------------------------------------------------------------------------
 // Set the source to grab frames continuously.
-// You should override this as appropriate for your device.  
+// You should override this as appropriate for your device.
 void vtkVideoSource::Record()
 {
   if (this->Playing)
@@ -559,19 +559,19 @@ void vtkVideoSource::Record()
     this->Recording = 1;
     this->FrameCount = 0;
     this->Modified();
-    this->PlayerThreadId = 
+    this->PlayerThreadId =
       this->PlayerThreader->SpawnThread((vtkThreadFunctionType)\
                                 &vtkVideoSourceRecordThread,this);
     }
 }
-    
+
 //----------------------------------------------------------------------------
 // this function runs in an alternate thread to 'play the tape' at the
 // specified frame rate.
 static void *vtkVideoSourcePlayThread(vtkMultiThreader::ThreadInfo *data)
 {
   vtkVideoSource *self = (vtkVideoSource *)(data->UserData);
- 
+
   double startTime = vtkTimerLog::GetUniversalTime();
   double rate = self->GetFrameRate();
   int frame = 0;
@@ -588,7 +588,7 @@ static void *vtkVideoSourcePlayThread(vtkMultiThreader::ThreadInfo *data)
 
 //----------------------------------------------------------------------------
 // Set the source to play back recorded frames.
-// You should override this as appropriate for your device.  
+// You should override this as appropriate for your device.
 void vtkVideoSource::Play()
 {
   if (this->Recording)
@@ -602,12 +602,12 @@ void vtkVideoSource::Play()
 
     this->Playing = 1;
     this->Modified();
-    this->PlayerThreadId = 
+    this->PlayerThreadId =
       this->PlayerThreader->SpawnThread((vtkThreadFunctionType)\
                                         &vtkVideoSourcePlayThread,this);
     }
 }
-    
+
 //----------------------------------------------------------------------------
 // Stop continuous grabbing or playback.  You will have to override this
 // if your class overrides Play() and Record()
@@ -621,7 +621,7 @@ void vtkVideoSource::Stop()
     this->Recording = 0;
     this->Modified();
     }
-} 
+}
 
 //----------------------------------------------------------------------------
 // Rewind back to the frame with the earliest timestamp.
@@ -665,7 +665,7 @@ void vtkVideoSource::Rewind()
     }
 
   this->FrameBufferMutex->Unlock();
-}  
+}
 
 //----------------------------------------------------------------------------
 // Fast-forward to the frame with the latest timestamp.
@@ -717,12 +717,12 @@ void vtkVideoSource::FastForward()
     }
 
   this->FrameBufferMutex->Unlock();
-}  
+}
 
 //----------------------------------------------------------------------------
 // Rotate the buffers
 void vtkVideoSource::Seek(int n)
-{ 
+{
   this->FrameBufferMutex->Lock();
   this->AdvanceFrameBuffer(n);
   this->FrameIndex = (this->FrameIndex + n) % this->FrameBufferSize;
@@ -731,7 +731,7 @@ void vtkVideoSource::Seek(int n)
     this->FrameIndex += this->FrameBufferSize;
     }
   this->FrameBufferMutex->Unlock();
-  this->Modified(); 
+  this->Modified();
 }
 
 //----------------------------------------------------------------------------
@@ -798,7 +798,7 @@ void vtkVideoSource::SetOutputFormat(int format)
 
 //----------------------------------------------------------------------------
 // set or change the circular buffer size
-// you will have to override this if you want the buffers 
+// you will have to override this if you want the buffers
 // to be device-specific (i.e. something other than vtkDataArray)
 void vtkVideoSource::SetFrameBufferSize(int bufsize)
 {
@@ -830,12 +830,12 @@ void vtkVideoSource::SetFrameBufferSize(int bufsize)
         {
         this->FrameBuffer[i] = vtkUnsignedCharArray::New();
         this->FrameBufferTimeStamps[i] = 0.0;
-        } 
+        }
       this->FrameBufferSize = bufsize;
       this->Modified();
       }
     }
-  else 
+  else
     {
     if (bufsize > 0)
       {
@@ -909,7 +909,7 @@ void vtkVideoSource::SetFrameBufferSize(int bufsize)
 void vtkVideoSource::AdvanceFrameBuffer(int n)
 {
   int i = (this->FrameBufferIndex - n) % this->FrameBufferSize;
-  while (i < 0) 
+  while (i < 0)
     {
     i += this->FrameBufferSize;
     }
@@ -918,7 +918,7 @@ void vtkVideoSource::AdvanceFrameBuffer(int n)
 
 //----------------------------------------------------------------------------
 double vtkVideoSource::GetFrameTimeStamp(int frame)
-{ 
+{
   double timeStamp;
 
   this->FrameBufferMutex->Lock();
@@ -959,7 +959,7 @@ int vtkVideoSource::RequestInformation(
     // if 'flag' is set in output extent, use the FrameBufferExtent instead
     if (extent[2*i+1] < extent[2*i])
       {
-      extent[2*i] = 0; 
+      extent[2*i] = 0;
       extent[2*i+1] = \
         this->FrameBufferExtent[2*i+1] - this->FrameBufferExtent[2*i];
       }
@@ -981,7 +981,7 @@ int vtkVideoSource::RequestInformation(
   extent[5] = extent[4] + (extent[5]-extent[4]+1) * numFrames - 1;
 
   outInfo->Set(vtkStreamingDemandDrivenPipeline::WHOLE_EXTENT(),extent,6);
-    
+
   // set the spacing
   outInfo->Set(vtkDataObject::SPACING(),this->DataSpacing,3);
 
@@ -989,7 +989,7 @@ int vtkVideoSource::RequestInformation(
   outInfo->Set(vtkDataObject::ORIGIN(),this->DataOrigin,3);
 
   // set default data type (8 bit greyscale)
-  vtkDataObject::SetPointDataActiveScalarInfo(outInfo, VTK_UNSIGNED_CHAR, 
+  vtkDataObject::SetPointDataActiveScalarInfo(outInfo, VTK_UNSIGNED_CHAR,
     this->NumberOfScalarComponents);
 
   return 1;
@@ -1000,7 +1000,7 @@ int vtkVideoSource::RequestInformation(
 // unusual pixel packing formats, such as XRGB XBRG BGRX BGR etc.
 // The version below assumes that the packing of the framebuffer is
 // identical to that of the output.
-void vtkVideoSource::UnpackRasterLine(char *outPtr, char *rowPtr, 
+void vtkVideoSource::UnpackRasterLine(char *outPtr, char *rowPtr,
                                       int start, int count)
 {
   char *inPtr = rowPtr + start*this->NumberOfScalarComponents;
@@ -1020,7 +1020,7 @@ void vtkVideoSource::UnpackRasterLine(char *outPtr, char *rowPtr,
 //----------------------------------------------------------------------------
 // The Execute method is fairly complex, so I would not recommend overriding
 // it unless you have to.  Override the UnpackRasterLine() method instead.
-// You should only have to override it if you are using something other 
+// You should only have to override it if you are using something other
 // than 8-bit vtkUnsignedCharArray for the frame buffer.
 int vtkVideoSource::RequestData(
   vtkInformation *vtkNotUsed(request),
@@ -1037,9 +1037,9 @@ int vtkVideoSource::RequestData(
     {
     saveOutputExtent[i] = outputExtent[i];
     }
-  // clip to extent to the Z size of one frame  
-  outputExtent[4] = this->FrameOutputExtent[4]; 
-  outputExtent[5] = this->FrameOutputExtent[5]; 
+  // clip to extent to the Z size of one frame
+  outputExtent[4] = this->FrameOutputExtent[4];
+  outputExtent[5] = this->FrameOutputExtent[5];
 
   int frameExtentX = this->FrameBufferExtent[1]-this->FrameBufferExtent[0]+1;
   int frameExtentY = this->FrameBufferExtent[3]-this->FrameBufferExtent[2]+1;
@@ -1093,8 +1093,8 @@ int vtkVideoSource::RequestData(
     outPadY = 0;
     }
 
-  int outX = frameExtentX - inPadX; 
-  int outY = frameExtentY - inPadY; 
+  int outX = frameExtentX - inPadX;
+  int outY = frameExtentY - inPadY;
   int outZ; // do outZ later
 
   if (outX > extentX - outPadX)
@@ -1117,7 +1117,7 @@ int vtkVideoSource::RequestData(
     }
 
   // ditto for number of scalar components
-  if (data->GetNumberOfScalarComponents() != 
+  if (data->GetNumberOfScalarComponents() !=
       this->LastNumberOfScalarComponents)
     {
     this->LastNumberOfScalarComponents = data->GetNumberOfScalarComponents();
@@ -1132,7 +1132,7 @@ int vtkVideoSource::RequestData(
            (saveOutputExtent[3]-saveOutputExtent[2]+1)*
            (saveOutputExtent[5]-saveOutputExtent[4]+1)*outIncX);
     this->OutputNeedsInitialization = 0;
-    } 
+    }
 
   // we have to modify the outputExtent of the first frame,
   // because it might be complete (it will be restored after
@@ -1143,7 +1143,7 @@ int vtkVideoSource::RequestData(
   this->FrameBufferMutex->Lock();
 
   int index = this->FrameBufferIndex;
-  this->FrameTimeStamp = 
+  this->FrameTimeStamp =
     this->FrameBufferTimeStamps[index % this->FrameBufferSize];
 
   int frame;
@@ -1152,8 +1152,8 @@ int vtkVideoSource::RequestData(
     if (frame == finalFrame)
       {
       outputExtent[5] = finalOutputExtent5;
-      } 
-    
+      }
+
     vtkDataArray *frameBuffer = reinterpret_cast<vtkDataArray *>(this->FrameBuffer[(index + frame) % this->FrameBufferSize]);
 
     char *inPtr = reinterpret_cast<char*>(frameBuffer->GetVoidPointer(0));
@@ -1162,7 +1162,7 @@ int vtkVideoSource::RequestData(
     extentZ = outputExtent[5]-outputExtent[4]+1;
     inPadZ = 0;
     outPadZ = -outputExtent[4];
-    
+
     if (outPadZ < 0)
       {
       inPadZ -= outPadZ;
@@ -1209,7 +1209,7 @@ int vtkVideoSource::RequestData(
         outPtrTmp = outPtr;
         for (j = 0; j < outY; j++)
           {
-          if (outX > 0) 
+          if (outX > 0)
             {
             this->UnpackRasterLine(outPtrTmp,inPtrTmp,inPadX,outX);
             }
diff --git a/Rendering/vtkFreeTypeTools.cxx b/Rendering/vtkFreeTypeTools.cxx
index 7443693..681fae6 100644
--- a/Rendering/vtkFreeTypeTools.cxx
+++ b/Rendering/vtkFreeTypeTools.cxx
@@ -222,7 +222,7 @@ vtkFreeTypeToolsFaceRequester(FTC_FaceID face_id,
   // Map the ID to a text property
   vtkSmartPointer<vtkTextProperty> tprop =
       vtkSmartPointer<vtkTextProperty>::New();
-  self->MapIdToTextProperty(reinterpret_cast<unsigned long>(face_id), tprop);
+  self->MapIdToTextProperty(reinterpret_cast<intptr_t>(face_id), tprop);
 
   // Fonts, organized by [Family][Bold][Italic]
   static EmbeddedFontStruct EmbeddedFonts[3][2][2] =
diff --git a/Rendering/vtkFreeTypeUtilities.cxx b/Rendering/vtkFreeTypeUtilities.cxx
index 629e5da..2d140a8 100644
--- a/Rendering/vtkFreeTypeUtilities.cxx
+++ b/Rendering/vtkFreeTypeUtilities.cxx
@@ -337,7 +337,7 @@ vtkFreeTypeUtilitiesFaceRequester(FTC_FaceID face_id,
   // Map the ID to a text property
 
   vtkTextProperty *tprop = vtkTextProperty::New();
-  self->MapIdToTextProperty(reinterpret_cast<unsigned long>(face_id), tprop);
+  self->MapIdToTextProperty(reinterpret_cast<intptr_t>(face_id), tprop);
 
   // Fonts, organized by [Family][Bold][Italic]
 
diff --git a/Rendering/vtkWin32OpenGLRenderWindow.cxx b/Rendering/vtkWin32OpenGLRenderWindow.cxx
index a4485d2..6b6e6b4 100644
--- a/Rendering/vtkWin32OpenGLRenderWindow.cxx
+++ b/Rendering/vtkWin32OpenGLRenderWindow.cxx
@@ -75,9 +75,9 @@ vtkWin32OpenGLRenderWindow::~vtkWin32OpenGLRenderWindow()
 void vtkWin32OpenGLRenderWindow::Clean()
 {
   GLuint id;
-  
+
   /* finish OpenGL rendering */
-  if (this->ContextId) 
+  if (this->ContextId)
     {
     this->MakeCurrent();
 
@@ -86,7 +86,7 @@ void vtkWin32OpenGLRenderWindow::Clean()
       {
       glDisable((GLenum)cur_light);
       }
-    
+
     /* now delete all textures */
     glDisable(GL_TEXTURE_2D);
     for (int i = 1; i < this->TextureResourceIds->GetNumberOfIds(); i++)
@@ -106,16 +106,16 @@ void vtkWin32OpenGLRenderWindow::Clean()
       }
 
     this->CleanUpRenderers();
-    
+
     // Note: wglMakeCurrent(NULL,NULL) is valid according to the documentation
     // and works with nVidia and ATI but not with Intel. Passing an existing
     // device context works in any case.
     // see VTK Bug 7119.
-    if(wglMakeCurrent(this->DeviceContext,NULL)!=TRUE) 
+    if(wglMakeCurrent(this->DeviceContext,NULL)!=TRUE)
       {
       vtkErrorMacro("wglMakeCurrent failed in Clean(), error: " << GetLastError());
       }
-    if (wglDeleteContext(this->ContextId) != TRUE) 
+    if (wglDeleteContext(this->ContextId) != TRUE)
       {
       vtkErrorMacro("wglDeleteContext failed in Clean(), error: " << GetLastError());
       }
@@ -136,7 +136,7 @@ void vtkWin32OpenGLRenderWindow::CleanUpRenderers()
   // destructor)
   vtkRenderer *ren;
   vtkCollectionSimpleIterator rsit;
-  for (this->Renderers->InitTraversal(rsit); 
+  for (this->Renderers->InitTraversal(rsit);
        (ren = this->Renderers->GetNextRenderer(rsit));)
     {
     ren->SetRenderWindow(NULL);
@@ -144,13 +144,13 @@ void vtkWin32OpenGLRenderWindow::CleanUpRenderers()
     }
 }
 
-LRESULT APIENTRY vtkWin32OpenGLRenderWindow::WndProc(HWND hWnd, UINT message, 
-                                                     WPARAM wParam, 
+LRESULT APIENTRY vtkWin32OpenGLRenderWindow::WndProc(HWND hWnd, UINT message,
+                                                     WPARAM wParam,
                                                      LPARAM lParam)
 {
   LRESULT res;
 
-  vtkWin32OpenGLRenderWindow *me = 
+  vtkWin32OpenGLRenderWindow *me =
     (vtkWin32OpenGLRenderWindow *)vtkGetWindowLong(hWnd,sizeof(vtkLONG));
 
   if (me && me->GetReferenceCount()>0)
@@ -199,7 +199,7 @@ int vtkWin32OpenGLRenderWindow::GetEventPending()
       return 1;
       }
     }
-  
+
   return 0;
 }
 
@@ -216,21 +216,21 @@ void vtkWin32OpenGLRenderWindow::MakeCurrent()
                     " than the one doing the picking, this can causes crashes"
                     " and/or bad pick results");
       }
-    else 
+    else
       {
-      if (wglMakeCurrent(this->DeviceContext, this->ContextId) != TRUE) 
+      if (wglMakeCurrent(this->DeviceContext, this->ContextId) != TRUE)
         {
         LPVOID lpMsgBuf;
-        ::FormatMessage( 
-          FORMAT_MESSAGE_ALLOCATE_BUFFER | 
-          FORMAT_MESSAGE_FROM_SYSTEM | 
+        ::FormatMessage(
+          FORMAT_MESSAGE_ALLOCATE_BUFFER |
+          FORMAT_MESSAGE_FROM_SYSTEM |
           FORMAT_MESSAGE_IGNORE_INSERTS,
           NULL,
           GetLastError(),
           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
           (LPTSTR) &lpMsgBuf,
           0,
-          NULL 
+          NULL
           );
         if(lpMsgBuf)
           {
@@ -243,7 +243,7 @@ void vtkWin32OpenGLRenderWindow::MakeCurrent()
           delete [] wmsg;
           delete [] wtemp;
 #else
-          vtkErrorMacro("wglMakeCurrent failed in MakeCurrent(), error: " 
+          vtkErrorMacro("wglMakeCurrent failed in MakeCurrent(), error: "
                         << (LPCTSTR)lpMsgBuf);
 #endif
           ::LocalFree( lpMsgBuf );
@@ -289,13 +289,13 @@ void vtkWin32OpenGLRenderWindow::SetSize(int x, int y)
           }
         }
       }
-    
+
     else if (this->Mapped)
       {
       if (!resizing)
         {
         resizing = 1;
-        
+
         if (this->ParentId)
           {
           SetWindowExtEx(this->DeviceContext,x,y,NULL);
@@ -330,7 +330,7 @@ void vtkWin32OpenGLRenderWindow::SetPosition(int x, int y)
       if (!resizing)
         {
         resizing = 1;
-        
+
         SetWindowPos(this->WindowId,HWND_TOP,x,y,
                      0, 0, SWP_NOSIZE | SWP_NOZORDER);
         resizing = 0;
@@ -426,7 +426,7 @@ const char* vtkWin32OpenGLRenderWindow::ReportCapabilities()
   if (pfd.cColorBits <= 8)
     {
     strm << "class:  PseudoColor" << endl;
-    } 
+    }
   else
     {
     strm << "class:  TrueColor" << endl;
@@ -447,14 +447,14 @@ const char* vtkWin32OpenGLRenderWindow::ReportCapabilities()
   strm << "double buffer:  False" << endl;
   }
   if (pfd.dwFlags & PFD_STEREO) {
-  strm << "stereo:  True" << endl;  
+  strm << "stereo:  True" << endl;
   } else {
   strm << "stereo:  False" << endl;
   }
   if (pfd.dwFlags & PFD_GENERIC_FORMAT) {
-  strm << "hardware acceleration:  False" << endl; 
+  strm << "hardware acceleration:  False" << endl;
   } else {
-  strm << "hardware acceleration:  True" << endl; 
+  strm << "hardware acceleration:  True" << endl;
   }
   strm << "rgba:  redSize=" << static_cast<int>(pfd.cRedBits) << " greenSize=" << static_cast<int>(pfd.cGreenBits) << "blueSize=" << static_cast<int>(pfd.cBlueBits) << "alphaSize=" << static_cast<int>(pfd.cAlphaBits) << endl;
   strm << "aux buffers:  " << static_cast<int>(pfd.cAuxBuffers)<< endl;
@@ -463,17 +463,17 @@ const char* vtkWin32OpenGLRenderWindow::ReportCapabilities()
   strm << "accum:  redSize=" << static_cast<int>(pfd.cAccumRedBits) << " greenSize=" << static_cast<int>(pfd.cAccumGreenBits) << "blueSize=" << static_cast<int>(pfd.cAccumBlueBits) << "alphaSize=" << static_cast<int>(pfd.cAccumAlphaBits) << endl;
 
   delete[] this->Capabilities;
-  
+
   size_t len = strm.str().length() + 1;
   this->Capabilities = new char[len];
   strncpy(this->Capabilities, strm.str().c_str(), len);
-  
+
   return this->Capabilities;
 }
 
- 
-void vtkWin32OpenGLRenderWindow::SetupPixelFormat(HDC hDC, DWORD dwFlags, 
-                                                  int debug, int bpp, 
+
+void vtkWin32OpenGLRenderWindow::SetupPixelFormat(HDC hDC, DWORD dwFlags,
+                                                  int debug, int bpp,
                                                   int zbpp)
 {
   PIXELFORMATDESCRIPTOR pfd = {
@@ -505,12 +505,12 @@ void vtkWin32OpenGLRenderWindow::SetupPixelFormat(HDC hDC, DWORD dwFlags,
     if (!(pfd.dwFlags & PFD_SUPPORT_OPENGL))
       {
 #ifdef UNICODE
-      MessageBox(WindowFromDC(hDC), 
+      MessageBox(WindowFromDC(hDC),
                  L"Invalid pixel format, no OpenGL support",
                  L"Error",
                  MB_ICONERROR | MB_OK);
 #else
-      MessageBox(WindowFromDC(hDC), 
+      MessageBox(WindowFromDC(hDC),
                  "Invalid pixel format, no OpenGL support",
                  "Error",
                  MB_ICONERROR | MB_OK);
@@ -524,11 +524,11 @@ void vtkWin32OpenGLRenderWindow::SetupPixelFormat(HDC hDC, DWORD dwFlags,
         {
         exit(1);
         }
-      }         
+      }
     }
   else
     {
-    // hDC has no current PixelFormat, so 
+    // hDC has no current PixelFormat, so
     pixelFormat = ChoosePixelFormat(hDC, &pfd);
     if (pixelFormat == 0)
       {
@@ -549,8 +549,8 @@ void vtkWin32OpenGLRenderWindow::SetupPixelFormat(HDC hDC, DWORD dwFlags,
         exit(1);
         }
       }
-    DescribePixelFormat(hDC, pixelFormat,sizeof(pfd), &pfd); 
-    if (SetPixelFormat(hDC, pixelFormat, &pfd) != TRUE) 
+    DescribePixelFormat(hDC, pixelFormat,sizeof(pfd), &pfd);
+    if (SetPixelFormat(hDC, pixelFormat, &pfd) != TRUE)
       {
       // int err = GetLastError();
 #ifdef UNICODE
@@ -626,10 +626,10 @@ void vtkWin32OpenGLRenderWindow::SetupPalette(HDC hDC)
 }
 
 
-LRESULT vtkWin32OpenGLRenderWindow::MessageProc(HWND hWnd, UINT message, 
+LRESULT vtkWin32OpenGLRenderWindow::MessageProc(HWND hWnd, UINT message,
                                                 WPARAM wParam, LPARAM lParam)
 {
-  switch (message) 
+  switch (message)
     {
     case WM_CREATE:
     {
@@ -648,18 +648,18 @@ LRESULT vtkWin32OpenGLRenderWindow::MessageProc(HWND hWnd, UINT message,
       return 0;
     case WM_SIZE:
       /* track window size changes */
-      if (this->ContextId) 
+      if (this->ContextId)
         {
         this->SetSize((int) LOWORD(lParam),(int) HIWORD(lParam));
         return 0;
         }
     case WM_PALETTECHANGED:
       /* realize palette if this is *not* the current window */
-      if (this->ContextId && this->Palette && (HWND) wParam != hWnd) 
+      if (this->ContextId && this->Palette && (HWND) wParam != hWnd)
         {
         SelectPalette(this->DeviceContext, this->OldPalette, FALSE);
         UnrealizeObject(this->Palette);
-        this->OldPalette = SelectPalette(this->DeviceContext, 
+        this->OldPalette = SelectPalette(this->DeviceContext,
                                          this->Palette, FALSE);
         RealizePalette(this->DeviceContext);
         this->Render();
@@ -667,11 +667,11 @@ LRESULT vtkWin32OpenGLRenderWindow::MessageProc(HWND hWnd, UINT message,
       break;
     case WM_QUERYNEWPALETTE:
       /* realize palette if this is the current window */
-      if (this->ContextId && this->Palette) 
+      if (this->ContextId && this->Palette)
         {
         SelectPalette(this->DeviceContext, this->OldPalette, FALSE);
         UnrealizeObject(this->Palette);
-        this->OldPalette = SelectPalette(this->DeviceContext, 
+        this->OldPalette = SelectPalette(this->DeviceContext,
                                          this->Palette, FALSE);
         RealizePalette(this->DeviceContext);
         this->Render();
@@ -682,7 +682,7 @@ LRESULT vtkWin32OpenGLRenderWindow::MessageProc(HWND hWnd, UINT message,
     {
     PAINTSTRUCT ps;
     BeginPaint(hWnd, &ps);
-    if (this->ContextId) 
+    if (this->ContextId)
       {
       this->Render();
       }
@@ -730,20 +730,20 @@ void vtkWin32OpenGLRenderWindow::CreateAWindow()
     {
     static int count = 1;
     char *windowName;
-    
+
     if (!this->WindowId)
       {
       WNDCLASS wndClass;
       this->DeviceContext = 0;
-      
-      int len = static_cast<int>(strlen("Visualization Toolkit - Win32OpenGL #")) 
+
+      int len = static_cast<int>(strlen("Visualization Toolkit - Win32OpenGL #"))
         + (int)ceil( (double) log10( (double)(count+1) ) )
-        + 1; 
+        + 1;
       windowName = new char [ len ];
       sprintf(windowName,"Visualization Toolkit - Win32OpenGL #%i",count++);
       this->SetWindowName(windowName);
       delete [] windowName;
-      
+
       // has the class been registered ?
 #ifdef UNICODE
       if (!GetClassInfo(this->ApplicationInstance,L"vtkOpenGL",&wndClass))
@@ -770,7 +770,7 @@ void vtkWin32OpenGLRenderWindow::CreateAWindow()
           wndClass.cbWndExtra = 2 * sizeof(vtkLONG);
           RegisterClass(&wndClass);
           }
-      
+
 #ifdef UNICODE
       wchar_t *wname = new wchar_t [mbstowcs(NULL, this->WindowName, 32000)+1];
       mbstowcs(wname, this->WindowName, 32000);
@@ -779,7 +779,7 @@ void vtkWin32OpenGLRenderWindow::CreateAWindow()
       int y = ((this->Position[1] >= 0) ? this->Position[1] : 5);
       int height = ((this->Size[1] > 0) ? this->Size[1] : 300);
       int width = ((this->Size[0] > 0) ? this->Size[0] : 300);
-      
+
       /* create window */
       if (this->ParentId)
         {
@@ -812,7 +812,7 @@ void vtkWin32OpenGLRenderWindow::CreateAWindow()
         this->WindowId = CreateWindow(
           L"vtkOpenGL", wname, style,
           x,y, width+2*GetSystemMetrics(SM_CXFRAME),
-          height+2*GetSystemMetrics(SM_CYFRAME) 
+          height+2*GetSystemMetrics(SM_CYFRAME)
           +GetSystemMetrics(SM_CYCAPTION),
           NULL, NULL, this->ApplicationInstance, NULL);
 #else
@@ -827,14 +827,14 @@ void vtkWin32OpenGLRenderWindow::CreateAWindow()
 #ifdef UNICODE
       delete [] wname;
 #endif
-      
+
       if (!this->WindowId)
         {
         vtkErrorMacro("Could not create window, error:  " << GetLastError());
         return;
         }
       // extract the create info
-      
+
       /* display window */
       if(!this->OffScreenRendering)
         {
@@ -842,7 +842,7 @@ void vtkWin32OpenGLRenderWindow::CreateAWindow()
         }
       //UpdateWindow(this->WindowId);
       this->OwnWindow = 1;
-      vtkSetWindowLong(this->WindowId,sizeof(vtkLONG),(vtkLONG)this);
+      vtkSetWindowLong(this->WindowId,sizeof(vtkLONG),(intptr_t)this);
       }
     if (!this->DeviceContext)
       {
@@ -862,16 +862,16 @@ void vtkWin32OpenGLRenderWindow::CreateAWindow()
       }
     this->SetupPalette(this->DeviceContext);
     this->ContextId = wglCreateContext(this->DeviceContext);
-    if (this->ContextId == NULL) 
+    if (this->ContextId == NULL)
       {
       vtkErrorMacro("wglCreateContext failed in CreateAWindow(), error: " << GetLastError());
       }
     this->MakeCurrent();
-    
+
     // wipe out any existing display lists
     vtkRenderer* ren;
     vtkCollectionSimpleIterator rsit;
-    for (this->Renderers->InitTraversal(rsit); 
+    for (this->Renderers->InitTraversal(rsit);
          (ren = this->Renderers->GetNextRenderer(rsit));)
       {
       ren->SetRenderWindow(0);
@@ -889,20 +889,20 @@ void vtkWin32OpenGLRenderWindow::CreateAWindow()
 
 // Initialize the window for rendering.
 void vtkWin32OpenGLRenderWindow::WindowInitialize()
-{ 
+{
   // create our own window if not already set
   this->OwnWindow = 0;
   if (!this->MFChandledWindow)
     {
     this->InitializeApplication();
     this->CreateAWindow();
-    }   
-  else 
+    }
+  else
     {
     this->MakeCurrent(); // hsr
     this->OpenGLInit();
     }
-  
+
   // set the DPI
   this->SetDPI(GetDeviceCaps(this->DeviceContext, LOGPIXELSY));
 }
@@ -910,7 +910,7 @@ void vtkWin32OpenGLRenderWindow::WindowInitialize()
 // Initialize the rendering window.
 void vtkWin32OpenGLRenderWindow::Initialize (void)
 {
-  // make sure we havent already been initialized 
+  // make sure we havent already been initialized
   if (!this->OffScreenRendering && !this->ContextId)
     {
     this->WindowInitialize();
@@ -955,7 +955,7 @@ void vtkWin32OpenGLRenderWindow::DestroyWindow()
         ReleaseDC(this->WindowId, this->DeviceContext);
         // can't set WindowId=NULL, needed for DestroyWindow
         this->DeviceContext = NULL;
-        
+
         // clear the extra data before calling destroy
         vtkSetWindowLong(this->WindowId,sizeof(vtkLONG),(vtkLONG)0);
         if(this->OwnWindow)
@@ -971,18 +971,18 @@ void vtkWin32OpenGLRenderWindow::DestroyWindow()
 // Get the current size of the window.
 int *vtkWin32OpenGLRenderWindow::GetSize(void)
 {
-  // if we aren't mapped then just return the ivar 
+  // if we aren't mapped then just return the ivar
   if (this->Mapped)
     {
     RECT rect;
 
-    //  Find the current window size 
+    //  Find the current window size
     if (GetClientRect(this->WindowId, &rect))
-      {    
+      {
       this->Size[0] = rect.right;
       this->Size[1] = rect.bottom;
       }
-    else 
+    else
       {
       this->Size[0] = 0;
       this->Size[1] = 0;
@@ -999,23 +999,23 @@ int *vtkWin32OpenGLRenderWindow::GetScreenSize(void)
   RECT rect;
 
   SystemParametersInfo(SPI_GETWORKAREA, 0, &rect, 0);
-                            
+
   this->Size[0] = rect.right - rect.left;
   this->Size[1] = rect.bottom - rect.top;
-  
+
   return this->Size;
 }
 
 // Get the position in screen coordinates of the window.
 int *vtkWin32OpenGLRenderWindow::GetPosition(void)
 {
-  // if we aren't mapped then just return the ivar 
+  // if we aren't mapped then just return the ivar
   if (!this->Mapped)
     {
     return this->Position;
     }
 
-  //  Find the current window position 
+  //  Find the current window position
   //  x,y,&this->Position[0],&this->Position[1],&child);
 
   return this->Position;
@@ -1025,34 +1025,34 @@ int *vtkWin32OpenGLRenderWindow::GetPosition(void)
 void vtkWin32OpenGLRenderWindow::SetFullScreen(int arg)
 {
   int *temp;
-  
+
   if (this->FullScreen == arg)
     {
     return;
     }
-  
+
   if (!this->Mapped)
     {
     this->PrefFullScreen();
     return;
     }
 
-  // set the mode 
+  // set the mode
   this->FullScreen = arg;
   if (this->FullScreen <= 0)
     {
     this->Position[0] = this->OldScreen[0];
     this->Position[1] = this->OldScreen[1];
-    this->Size[0] = this->OldScreen[2]; 
+    this->Size[0] = this->OldScreen[2];
     this->Size[1] = this->OldScreen[3];
     this->Borders = this->OldScreen[4];
     }
   else
     {
-    // if window already up get its values 
+    // if window already up get its values
     if (this->WindowId)
       {
-      temp = this->GetPosition();      
+      temp = this->GetPosition();
       this->OldScreen[0] = temp[0];
       this->OldScreen[1] = temp[1];
 
@@ -1060,8 +1060,8 @@ void vtkWin32OpenGLRenderWindow::SetFullScreen(int arg)
       this->PrefFullScreen();
       }
     }
-  
-  // remap the window 
+
+  // remap the window
   this->WindowRemap();
 
   this->Modified();
@@ -1092,14 +1092,14 @@ void vtkWin32OpenGLRenderWindow::PrefFullScreen()
 
   size = this->GetScreenSize();
 
-  // use full screen 
+  // use full screen
   this->Position[0] = 0;
   this->Position[1] = 0;
   this->Size[0] = size[0] - 2*GetSystemMetrics(SM_CXFRAME);
-  this->Size[1] = size[1] - 
+  this->Size[1] = size[1] -
     2*GetSystemMetrics(SM_CYFRAME) - GetSystemMetrics(SM_CYCAPTION);
 
-  // don't show borders 
+  // don't show borders
   this->Borders = 0;
 }
 
@@ -1108,8 +1108,8 @@ void vtkWin32OpenGLRenderWindow::WindowRemap()
 {
   // close everything down
   this->Finalize();
-  
-  // set the default windowid 
+
+  // set the default windowid
   this->WindowId = this->NextWindowId;
   this->NextWindowId = 0;
 
@@ -1129,7 +1129,7 @@ void vtkWin32OpenGLRenderWindow::PrintSelf(ostream& os, vtkIndent indent)
 // Get the window id.
 HWND vtkWin32OpenGLRenderWindow::GetWindowId()
 {
-  vtkDebugMacro(<< "Returning WindowId of " << this->WindowId << "\n"); 
+  vtkDebugMacro(<< "Returning WindowId of " << this->WindowId << "\n");
 
   return this->WindowId;
 }
@@ -1138,11 +1138,11 @@ HWND vtkWin32OpenGLRenderWindow::GetWindowId()
 void vtkWin32OpenGLRenderWindow::SetWindowId(HWND arg)
 {
   vtkDebugMacro(<< "Setting WindowId to " << arg << "\n");
-  
+
   if (arg != this->WindowId)
     {
     this->WindowId = arg;
-    if (this->ContextId) 
+    if (this->ContextId)
       {
       wglDeleteContext(this->ContextId);
       }
@@ -1155,24 +1155,24 @@ void vtkWin32OpenGLRenderWindow::SetWindowId(HWND arg)
 void vtkWin32OpenGLRenderWindow::SetWindowInfo(char *info)
 {
   int tmp;
-  
+
   sscanf(info,"%i",&tmp);
 
   this->WindowId = (HWND)tmp;
-  vtkDebugMacro(<< "Setting WindowId to " << this->WindowId << "\n"); 
+  vtkDebugMacro(<< "Setting WindowId to " << this->WindowId << "\n");
 }
 
 void vtkWin32OpenGLRenderWindow::SetNextWindowInfo(char *info)
 {
   int tmp;
-  
+
   sscanf(info,"%i",&tmp);
 
   this->SetNextWindowId((HWND)tmp);
 }
 
 void vtkWin32OpenGLRenderWindow::SetDisplayId(void * arg)
-{ 
+{
   this->DeviceContext = (HDC) arg;
 }
 
@@ -1181,7 +1181,7 @@ void vtkWin32OpenGLRenderWindow::SetContextId(HGLRC arg)
   this->ContextId = arg;
 }
 
-void vtkWin32OpenGLRenderWindow::SetDeviceContext(HDC arg) 
+void vtkWin32OpenGLRenderWindow::SetDeviceContext(HDC arg)
 {
   this->DeviceContext = arg;
   this->MFChandledWindow = TRUE;
@@ -1191,17 +1191,17 @@ void vtkWin32OpenGLRenderWindow::SetDeviceContext(HDC arg)
 void vtkWin32OpenGLRenderWindow::SetParentInfo(char *info)
 {
   int tmp;
-  
+
   sscanf(info,"%i",&tmp);
 
   this->ParentId = (HWND)tmp;
-  vtkDebugMacro(<< "Setting ParentId to " << this->ParentId << "\n"); 
+  vtkDebugMacro(<< "Setting ParentId to " << this->ParentId << "\n");
 }
 
 // Set the window id to a pre-existing window.
 void vtkWin32OpenGLRenderWindow::SetParentId(HWND arg)
 {
-  vtkDebugMacro(<< "Setting ParentId to " << arg << "\n"); 
+  vtkDebugMacro(<< "Setting ParentId to " << arg << "\n");
 
   this->ParentId = arg;
 }
@@ -1209,7 +1209,7 @@ void vtkWin32OpenGLRenderWindow::SetParentId(HWND arg)
 // Set the window id of the new window once a WindowRemap is done.
 void vtkWin32OpenGLRenderWindow::SetNextWindowId(HWND arg)
 {
-  vtkDebugMacro(<< "Setting NextWindowId to " << arg << "\n"); 
+  vtkDebugMacro(<< "Setting NextWindowId to " << arg << "\n");
 
   this->NextWindowId = arg;
 }
@@ -1228,7 +1228,7 @@ void vtkWin32OpenGLRenderWindow::Start(void)
     this->Initialize();
     }
 
-  // set the current window 
+  // set the current window
   this->MakeCurrent();
 }
 
@@ -1296,13 +1296,13 @@ void vtkWin32OpenGLRenderWindow::CreateOffScreenWindow(int width,
     DeleteDC(dc);
     }
   this->CreatingOffScreenWindow = status;
-} 
+}
 
 void vtkWin32OpenGLRenderWindow::CreateOffScreenDC(int xsize, int ysize,
                                                    HDC aHdc)
 {
   int dataWidth = ((xsize*3+3)/4)*4;
-  
+
   this->MemoryDataHeader.bmiHeader.biSize = 40;
   this->MemoryDataHeader.bmiHeader.biWidth = xsize;
   this->MemoryDataHeader.bmiHeader.biHeight = ysize;
@@ -1314,7 +1314,7 @@ void vtkWin32OpenGLRenderWindow::CreateOffScreenDC(int xsize, int ysize,
   this->MemoryDataHeader.bmiHeader.biSizeImage = dataWidth*ysize;
   this->MemoryDataHeader.bmiHeader.biXPelsPerMeter = 10000;
   this->MemoryDataHeader.bmiHeader.biYPelsPerMeter = 10000;
-  
+
   HBITMAP dib = CreateDIBSection(aHdc,
                                  &this->MemoryDataHeader, DIB_RGB_COLORS,
                                  (void **)(&(this->MemoryData)),  NULL, 0);
@@ -1330,13 +1330,13 @@ void vtkWin32OpenGLRenderWindow::CreateOffScreenDC(HBITMAP hbmp, HDC aHdc)
   GetObject(hbmp, sizeof(BITMAP), &bm);
 
   this->MemoryBuffer = hbmp;
-  
+
   // Create a compatible device context
   this->MemoryHdc = (HDC)CreateCompatibleDC(aHdc);
-  
+
   // Put the bitmap into the device context
   SelectObject(this->MemoryHdc, this->MemoryBuffer);
-  
+
   // Renderers will need to redraw anything cached in display lists
   this->CleanUpRenderers();
 
@@ -1344,15 +1344,15 @@ void vtkWin32OpenGLRenderWindow::CreateOffScreenDC(HBITMAP hbmp, HDC aHdc)
   this->Mapped =0;
   this->Size[0] = bm.bmWidth;
   this->Size[1] = bm.bmHeight;
-  
+
   this->DeviceContext = this->MemoryHdc;
   this->DoubleBuffer = 0;
-  this->SetupPixelFormat(this->DeviceContext, 
-                         PFD_SUPPORT_OPENGL | PFD_SUPPORT_GDI | 
+  this->SetupPixelFormat(this->DeviceContext,
+                         PFD_SUPPORT_OPENGL | PFD_SUPPORT_GDI |
                          PFD_DRAW_TO_BITMAP, this->GetDebug(), 24, 32);
   this->SetupPalette(this->DeviceContext);
   this->ContextId = wglCreateContext(this->DeviceContext);
-  if (this->ContextId == NULL) 
+  if (this->ContextId == NULL)
     {
     vtkErrorMacro("wglCreateContext failed in CreateOffScreenDC(), error: " << GetLastError());
     }
@@ -1391,7 +1391,7 @@ void vtkWin32OpenGLRenderWindow::SetupMemoryRendering(HBITMAP hbmp)
   this->ScreenContextId = this->ContextId;
 
   this->CreateOffScreenDC(hbmp, dc);
-  DeleteDC(dc); 
+  DeleteDC(dc);
 }
 
 HDC vtkWin32OpenGLRenderWindow::GetMemoryDC()
@@ -1411,15 +1411,15 @@ void vtkWin32OpenGLRenderWindow::CleanUpOffScreenRendering(void)
       {
       return;
       }
-      
+
     GdiFlush();
-      
+
     // we need to release resources
     this->CleanUpRenderers();
     DeleteDC(this->MemoryHdc);
     this->MemoryHdc = (HDC)0;
     DeleteObject(this->MemoryBuffer);
-    if (wglDeleteContext(this->ContextId) != TRUE) 
+    if (wglDeleteContext(this->ContextId) != TRUE)
       {
       vtkErrorMacro("wglDeleteContext failed in CleanUpOffScreenRendering(), error: " << GetLastError());
       }
@@ -1429,7 +1429,7 @@ void vtkWin32OpenGLRenderWindow::CleanUpOffScreenRendering(void)
 
 void vtkWin32OpenGLRenderWindow::ResumeScreenRendering(void)
 {
-  // release OpenGL graphics resources before switch back to on-screen. 
+  // release OpenGL graphics resources before switch back to on-screen.
   if(this->ContextId!=0)
     {
       this->MakeCurrent();
@@ -1467,10 +1467,10 @@ void vtkWin32OpenGLRenderWindow::ShowCursor()
   this->CursorHidden = 0;
 
   ::ShowCursor(!this->CursorHidden);
-}                                  
+}
 
 //----------------------------------------------------------------------------
-void vtkWin32OpenGLRenderWindow::SetCursorPosition(int x, int y) 
+void vtkWin32OpenGLRenderWindow::SetCursorPosition(int x, int y)
 {
   int *size = this->GetSize();
 
@@ -1517,7 +1517,7 @@ void vtkWin32OpenGLRenderWindow::SetCurrentCursor(int shape)
       cursorName = IDC_SIZEALL;
       break;
     case VTK_CURSOR_HAND:
-#if(WINVER >= 0x0500)      
+#if(WINVER >= 0x0500)
       cursorName = IDC_HAND;
 #else
       cursorName = IDC_ARROW;
@@ -1527,10 +1527,10 @@ void vtkWin32OpenGLRenderWindow::SetCurrentCursor(int shape)
       cursorName = IDC_CROSS;
       break;
     }
-  
+
   if (cursorName)
     {
-    HANDLE cursor = 
+    HANDLE cursor =
       LoadImage(0,cursorName,IMAGE_CURSOR,0,0,LR_SHARED | LR_DEFAULTSIZE);
     SetCursor((HCURSOR)cursor);
     }
diff --git a/Rendering/vtkWin32RenderWindowInteractor.cxx b/Rendering/vtkWin32RenderWindowInteractor.cxx
index a53bbc8..8a3dc63 100644
--- a/Rendering/vtkWin32RenderWindowInteractor.cxx
+++ b/Rendering/vtkWin32RenderWindowInteractor.cxx
@@ -17,10 +17,12 @@
 #include <string.h>
 #include <math.h>
 
-#define _WIN32_WINNT 0x0400  // for trackmouseevent support  requires Win95 with IE 3.0 or greater.
-
 #include "vtkWin32OpenGLRenderWindow.h"
 
+#ifndef _WIN32_WINNT
+#define _WIN32_WINNT 0x0400  // for trackmouseevent support  requires Win95 with IE 3.0 or greater.
+#endif
+
 // Mouse wheel support
 // In an ideal world we would just have to include <zmouse.h>, but it is not
 // always available with all compilers/headers
@@ -31,7 +33,7 @@
 #  define GET_WHEEL_DELTA_WPARAM(wparam) ((short)HIWORD (wparam))
 #endif  //GET_WHEEL_DELTA_WPARAM
 
-// MSVC does the right thing without the forward declaration when it 
+// MSVC does the right thing without the forward declaration when it
 // sees it in the friend decl in vtkWin32RenderWindowInteractor, but
 // GCC needs to see the declaration beforehand. It has to do with the
 // CALLBACK attribute.
@@ -60,42 +62,42 @@ void (*vtkWin32RenderWindowInteractor::ClassExitMethodArgDelete)(void *) = (void
 
 //----------------------------------------------------------------------------
 // Construct object so that light follows camera motion.
-vtkWin32RenderWindowInteractor::vtkWin32RenderWindowInteractor() 
+vtkWin32RenderWindowInteractor::vtkWin32RenderWindowInteractor()
 {
   this->WindowId           = 0;
   this->InstallMessageProc = 1;
   this->MouseInWindow = 0;
   this->StartedMessageLoop = 0;
-  
+
 #ifdef VTK_USE_TDX
   this->Device=vtkTDxWinDevice::New();
 #endif
 }
 
 //----------------------------------------------------------------------------
-vtkWin32RenderWindowInteractor::~vtkWin32RenderWindowInteractor() 
+vtkWin32RenderWindowInteractor::~vtkWin32RenderWindowInteractor()
 {
   vtkWin32OpenGLRenderWindow *tmp;
 
   // we need to release any hold we have on a windows event loop
-  if (this->WindowId && this->Enabled && this->InstallMessageProc) 
+  if (this->WindowId && this->Enabled && this->InstallMessageProc)
     {
     vtkWin32OpenGLRenderWindow *ren;
     ren = static_cast<vtkWin32OpenGLRenderWindow *>(this->RenderWindow);
     tmp = (vtkWin32OpenGLRenderWindow *)(vtkGetWindowLong(this->WindowId,sizeof(vtkLONG)));
     // watch for odd conditions
-    if ((tmp != ren) && (ren != NULL)) 
+    if ((tmp != ren) && (ren != NULL))
       {
       // OK someone else has a hold on our event handler
       // so lets have them handle this stuff
       // well send a USER message to the other
       // event handler so that it can properly
       // call this event handler if required
-      CallWindowProc(this->OldProc,this->WindowId,WM_USER+14,28,(LONG)this->OldProc);
+      CallWindowProc(this->OldProc,this->WindowId,WM_USER+14,28,(intptr_t)this->OldProc);
       }
-    else 
+    else
       {
-      vtkSetWindowLong(this->WindowId,vtkGWL_WNDPROC,(vtkLONG)this->OldProc);
+      vtkSetWindowLong(this->WindowId,vtkGWL_WNDPROC,(intptr_t)this->OldProc);
       }
     this->Enabled = 0;
     }
@@ -105,7 +107,7 @@ vtkWin32RenderWindowInteractor::~vtkWin32RenderWindowInteractor()
 }
 
 //----------------------------------------------------------------------------
-void  vtkWin32RenderWindowInteractor::Start() 
+void  vtkWin32RenderWindowInteractor::Start()
 {
   // Let the compositing handle the event loop if it wants to.
   if (this->HasObserver(vtkCommand::StartEvent) && !this->HandleEventLoop)
@@ -132,18 +134,18 @@ void  vtkWin32RenderWindowInteractor::Start()
 
 //----------------------------------------------------------------------------
 // Begin processing keyboard strokes.
-void vtkWin32RenderWindowInteractor::Initialize() 
+void vtkWin32RenderWindowInteractor::Initialize()
 {
   vtkWin32OpenGLRenderWindow *ren;
   int *size;
 
   // make sure we have a RenderWindow and camera
-  if ( ! this->RenderWindow) 
+  if ( ! this->RenderWindow)
     {
     vtkErrorMacro(<<"No renderer defined!");
     return;
     }
-  if (this->Initialized) 
+  if (this->Initialized)
     {
     return;
     }
@@ -160,35 +162,35 @@ void vtkWin32RenderWindowInteractor::Initialize()
 }
 
 //----------------------------------------------------------------------------
-void vtkWin32RenderWindowInteractor::Enable() 
+void vtkWin32RenderWindowInteractor::Enable()
 {
   vtkWin32OpenGLRenderWindow *ren;
   vtkWin32OpenGLRenderWindow *tmp;
-  if (this->Enabled) 
+  if (this->Enabled)
     {
     return;
     }
-  if (this->InstallMessageProc) 
+  if (this->InstallMessageProc)
     {
     // add our callback
     ren = (vtkWin32OpenGLRenderWindow *)(this->RenderWindow);
     this->OldProc = (WNDPROC)vtkGetWindowLong(this->WindowId,vtkGWL_WNDPROC);
     tmp=(vtkWin32OpenGLRenderWindow *)vtkGetWindowLong(this->WindowId,sizeof(vtkLONG));
     // watch for odd conditions
-    if (tmp != ren) 
+    if (tmp != ren)
       {
       // OK someone else has a hold on our event handler
       // so lets have them handle this stuff
       // well send a USER message to the other
       // event handler so that it can properly
       // call this event handler if required
-      CallWindowProc(this->OldProc,this->WindowId,WM_USER+12,24,(LONG)vtkHandleMessage);
+      CallWindowProc(this->OldProc,this->WindowId,WM_USER+12,24,(intptr_t)vtkHandleMessage);
       }
-    else 
+    else
       {
-      vtkSetWindowLong(this->WindowId,vtkGWL_WNDPROC,(vtkLONG)vtkHandleMessage);
+      vtkSetWindowLong(this->WindowId,vtkGWL_WNDPROC,(intptr_t)vtkHandleMessage);
       }
-    
+
 #ifdef VTK_USE_TDX
     if(this->UseTDx)
       {
@@ -197,7 +199,7 @@ void vtkWin32RenderWindowInteractor::Enable()
       this->Device->StartListening();
       }
 #endif
-    
+
     // in case the size of the window has changed while we were away
     int *size;
     size = ren->GetSize();
@@ -210,33 +212,33 @@ void vtkWin32RenderWindowInteractor::Enable()
 
 
 //----------------------------------------------------------------------------
-void vtkWin32RenderWindowInteractor::Disable() 
+void vtkWin32RenderWindowInteractor::Disable()
 {
   vtkWin32OpenGLRenderWindow *tmp;
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
-  
-  if (this->InstallMessageProc && this->Enabled && this->WindowId) 
+
+  if (this->InstallMessageProc && this->Enabled && this->WindowId)
     {
     // we need to release any hold we have on a windows event loop
     vtkWin32OpenGLRenderWindow *ren;
     ren = (vtkWin32OpenGLRenderWindow *)(this->RenderWindow);
     tmp = (vtkWin32OpenGLRenderWindow *)vtkGetWindowLong(this->WindowId,sizeof(vtkLONG));
     // watch for odd conditions
-    if ((tmp != ren) && (ren != NULL)) 
+    if ((tmp != ren) && (ren != NULL))
       {
       // OK someone else has a hold on our event handler
       // so lets have them handle this stuff
       // well send a USER message to the other
       // event handler so that it can properly
       // call this event handler if required
-      CallWindowProc(this->OldProc,this->WindowId,WM_USER+14,28,(LONG)this->OldProc);
+      CallWindowProc(this->OldProc,this->WindowId,WM_USER+14,28,(intptr_t)this->OldProc);
       }
-    else 
+    else
       {
-      vtkSetWindowLong(this->WindowId,vtkGWL_WNDPROC,(vtkLONG)this->OldProc);
+      vtkSetWindowLong(this->WindowId,vtkGWL_WNDPROC,(intptr_t)this->OldProc);
       }
 #ifdef VTK_USE_TDX
     if(this->Device->GetInitialized())
@@ -270,7 +272,7 @@ int vtkWin32RenderWindowInteractor::InternalCreateTimer(int timerId, int vtkNotU
 }
 
 //----------------------------------------------------------------------------
-int vtkWin32RenderWindowInteractor::InternalDestroyTimer(int platformTimerId) 
+int vtkWin32RenderWindowInteractor::InternalDestroyTimer(int platformTimerId)
 {
   return KillTimer(this->WindowId,platformTimerId);
 }
@@ -282,42 +284,42 @@ int vtkWin32RenderWindowInteractor::InternalDestroyTimer(int platformTimerId)
 // this ascii code to keysym table is meant to mimic Tk
 
 static const char *AsciiToKeySymTable[] = {
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
-  "space", "exclam", "quotedbl", "numbersign", 
-  "dollar", "percent", "ampersand", "quoteright", 
-  "parenleft", "parenright", "asterisk", "plus", 
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  "space", "exclam", "quotedbl", "numbersign",
+  "dollar", "percent", "ampersand", "quoteright",
+  "parenleft", "parenright", "asterisk", "plus",
   "comma", "minus", "period", "slash",
-  "0", "1", "2", "3", "4", "5", "6", "7", 
+  "0", "1", "2", "3", "4", "5", "6", "7",
   "8", "9", "colon", "semicolon", "less", "equal", "greater", "question",
-  "at", "A", "B", "C", "D", "E", "F", "G", 
+  "at", "A", "B", "C", "D", "E", "F", "G",
   "H", "I", "J", "K", "L", "M", "N", "O",
   "P", "Q", "R", "S", "T", "U", "V", "W",
-  "X", "Y", "Z", "bracketleft", 
+  "X", "Y", "Z", "bracketleft",
   "backslash", "bracketright", "asciicircum", "underscore",
   "quoteleft", "a", "b", "c", "d", "e", "f", "g",
   "h", "i", "j", "k", "l", "m", "n", "o",
   "p", "q", "r", "s", "t", "u", "v", "w",
   "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Delete",
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-  
+
 // this virtual key code to keysym table is meant to mimic Tk
 
 static const char *VKeyCodeToKeySymTable[] = {
   0, 0, 0, "Cancel", 0, 0, 0, 0,
   "BackSpace", "Tab", 0, 0, "Clear", "Return", 0, 0,
-  "Shift_L", "Control_L", "Alt_L", "Pause", "Caps_Lock", 0,0,0, 
+  "Shift_L", "Control_L", "Alt_L", "Pause", "Caps_Lock", 0,0,0,
   0, 0, 0, "Escape", 0, 0, 0, 0,
   "space", "Prior", "Next", "End", "Home", "Left", "Up", "Right",
   "Down", "Select", 0, "Execute", "Snapshot", "Insert", "Delete", "Help",
-  "0", "1", "2", "3", "4", "5", "6", "7", 
+  "0", "1", "2", "3", "4", "5", "6", "7",
   "8", "9", 0, 0, 0, 0, 0, 0,
   0, "a", "b", "c", "d", "e", "f", "g",
   "h", "i", "j", "k", "l", "m", "n", "o",
@@ -326,7 +328,7 @@ static const char *VKeyCodeToKeySymTable[] = {
   "KP_0", "KP_1", "KP_2", "KP_3", "KP_4", "KP_5", "KP_6", "KP_7",
   "KP_8", "KP_9", "asterisk", "plus", "bar", "minus", "period", "slash",
   "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8",
-  "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", 
+  "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16",
   "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24",
   0, 0, 0, 0, 0, 0, 0, 0,
   "Num_Lock", "Scroll_Lock", 0, 0, 0, 0, 0, 0,
@@ -341,20 +343,20 @@ static const char *VKeyCodeToKeySymTable[] = {
 //-------------------------------------------------------------
 // Event loop handlers
 //-------------------------------------------------------------
-void vtkWin32RenderWindowInteractor::OnMouseMove(HWND hWnd, UINT nFlags, 
-                                                 int X, int Y) 
+void vtkWin32RenderWindowInteractor::OnMouseMove(HWND hWnd, UINT nFlags,
+                                                 int X, int Y)
 {
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
 
-  this->SetEventInformationFlipY(X, 
-                                 Y, 
-                                 nFlags & MK_CONTROL, 
+  this->SetEventInformationFlipY(X,
+                                 Y,
+                                 nFlags & MK_CONTROL,
                                  nFlags & MK_SHIFT);
   this->SetAltKey(GetKeyState(VK_MENU) & (~1));
-  if (!this->MouseInWindow && 
+  if (!this->MouseInWindow &&
       (X >= 0 && X < this->Size[0] && Y >= 0 && Y < this->Size[1]))
     {
     this->InvokeEvent(vtkCommand::EnterEvent, NULL);
@@ -366,15 +368,15 @@ void vtkWin32RenderWindowInteractor::OnMouseMove(HWND hWnd, UINT nFlags,
     tme.hwndTrack = hWnd;
     TrackMouseEvent(&tme);
     }
- 
+
   this->InvokeEvent(vtkCommand::MouseMoveEvent, NULL);
 }
 
 //----------------------------------------------------------------------------
-void vtkWin32RenderWindowInteractor::OnNCMouseMove(HWND, UINT nFlags, 
-                                                   int X, int Y) 
+void vtkWin32RenderWindowInteractor::OnNCMouseMove(HWND, UINT nFlags,
+                                                   int X, int Y)
 {
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
@@ -382,9 +384,9 @@ void vtkWin32RenderWindowInteractor::OnNCMouseMove(HWND, UINT nFlags,
   int *pos = this->RenderWindow->GetPosition();
   if (this->MouseInWindow)
     {
-    this->SetEventInformationFlipY(X - pos[0], 
+    this->SetEventInformationFlipY(X - pos[0],
                                    Y - pos[1],
-                                   nFlags & MK_CONTROL, 
+                                   nFlags & MK_CONTROL,
                                    nFlags & MK_SHIFT);
     this->SetAltKey(GetKeyState(VK_MENU) & (~1));
     this->InvokeEvent(vtkCommand::LeaveEvent, NULL);
@@ -393,50 +395,50 @@ void vtkWin32RenderWindowInteractor::OnNCMouseMove(HWND, UINT nFlags,
 }
 
 //----------------------------------------------------------------------------
-void vtkWin32RenderWindowInteractor::OnMouseWheelForward(HWND,UINT nFlags, 
-                                                   int X, int Y) 
+void vtkWin32RenderWindowInteractor::OnMouseWheelForward(HWND,UINT nFlags,
+                                                   int X, int Y)
 {
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
-  this->SetEventInformationFlipY(X, 
-                                 Y, 
-                                 nFlags & MK_CONTROL, 
+  this->SetEventInformationFlipY(X,
+                                 Y,
+                                 nFlags & MK_CONTROL,
                                  nFlags & MK_SHIFT);
   this->SetAltKey(GetKeyState(VK_MENU) & (~1));
   this->InvokeEvent(vtkCommand::MouseWheelForwardEvent,NULL);
 }
 
 //----------------------------------------------------------------------------
-void vtkWin32RenderWindowInteractor::OnMouseWheelBackward(HWND,UINT nFlags, 
-                                                   int X, int Y) 
+void vtkWin32RenderWindowInteractor::OnMouseWheelBackward(HWND,UINT nFlags,
+                                                   int X, int Y)
 {
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
-  this->SetEventInformationFlipY(X, 
-                                 Y, 
-                                 nFlags & MK_CONTROL, 
+  this->SetEventInformationFlipY(X,
+                                 Y,
+                                 nFlags & MK_CONTROL,
                                  nFlags & MK_SHIFT);
   this->SetAltKey(GetKeyState(VK_MENU) & (~1));
   this->InvokeEvent(vtkCommand::MouseWheelBackwardEvent,NULL);
 }
 
 //----------------------------------------------------------------------------
-void vtkWin32RenderWindowInteractor::OnLButtonDown(HWND wnd,UINT nFlags, 
-                                                   int X, int Y, int repeat) 
+void vtkWin32RenderWindowInteractor::OnLButtonDown(HWND wnd,UINT nFlags,
+                                                   int X, int Y, int repeat)
 {
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
   SetFocus(wnd);
   SetCapture(wnd);
-  this->SetEventInformationFlipY(X, 
-                                 Y, 
-                                 nFlags & MK_CONTROL, 
+  this->SetEventInformationFlipY(X,
+                                 Y,
+                                 nFlags & MK_CONTROL,
                                  nFlags & MK_SHIFT,
                                  0, repeat);
   this->SetAltKey(GetKeyState(VK_MENU) & (~1));
@@ -444,16 +446,16 @@ void vtkWin32RenderWindowInteractor::OnLButtonDown(HWND wnd,UINT nFlags,
 }
 
 //----------------------------------------------------------------------------
-void vtkWin32RenderWindowInteractor::OnLButtonUp(HWND,UINT nFlags, 
-                                                 int X, int Y) 
+void vtkWin32RenderWindowInteractor::OnLButtonUp(HWND,UINT nFlags,
+                                                 int X, int Y)
 {
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
-  this->SetEventInformationFlipY(X, 
-                                 Y, 
-                                 nFlags & MK_CONTROL, 
+  this->SetEventInformationFlipY(X,
+                                 Y,
+                                 nFlags & MK_CONTROL,
                                  nFlags & MK_SHIFT);
   this->SetAltKey(GetKeyState(VK_MENU) & (~1));
   this->InvokeEvent(vtkCommand::LeftButtonReleaseEvent,NULL);
@@ -461,18 +463,18 @@ void vtkWin32RenderWindowInteractor::OnLButtonUp(HWND,UINT nFlags,
 }
 
 //----------------------------------------------------------------------------
-void vtkWin32RenderWindowInteractor::OnMButtonDown(HWND wnd,UINT nFlags, 
-                                                   int X, int Y, int repeat) 
+void vtkWin32RenderWindowInteractor::OnMButtonDown(HWND wnd,UINT nFlags,
+                                                   int X, int Y, int repeat)
 {
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
   SetFocus(wnd);
   SetCapture(wnd);
-  this->SetEventInformationFlipY(X, 
-                                 Y, 
-                                 nFlags & MK_CONTROL, 
+  this->SetEventInformationFlipY(X,
+                                 Y,
+                                 nFlags & MK_CONTROL,
                                  nFlags & MK_SHIFT,
                                  0, repeat);
   this->SetAltKey(GetKeyState(VK_MENU) & (~1));
@@ -480,16 +482,16 @@ void vtkWin32RenderWindowInteractor::OnMButtonDown(HWND wnd,UINT nFlags,
 }
 
 //----------------------------------------------------------------------------
-void vtkWin32RenderWindowInteractor::OnMButtonUp(HWND,UINT nFlags, 
-                                                 int X, int Y) 
+void vtkWin32RenderWindowInteractor::OnMButtonUp(HWND,UINT nFlags,
+                                                 int X, int Y)
 {
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
-  this->SetEventInformationFlipY(X, 
-                                 Y, 
-                                 nFlags & MK_CONTROL, 
+  this->SetEventInformationFlipY(X,
+                                 Y,
+                                 nFlags & MK_CONTROL,
                                  nFlags & MK_SHIFT);
   this->SetAltKey(GetKeyState(VK_MENU) & (~1));
   this->InvokeEvent(vtkCommand::MiddleButtonReleaseEvent,NULL);
@@ -497,18 +499,18 @@ void vtkWin32RenderWindowInteractor::OnMButtonUp(HWND,UINT nFlags,
 }
 
 //----------------------------------------------------------------------------
-void vtkWin32RenderWindowInteractor::OnRButtonDown(HWND wnd,UINT nFlags, 
-                                                   int X, int Y, int repeat) 
+void vtkWin32RenderWindowInteractor::OnRButtonDown(HWND wnd,UINT nFlags,
+                                                   int X, int Y, int repeat)
 {
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
   SetFocus(wnd);
   SetCapture(wnd);
-  this->SetEventInformationFlipY(X, 
-                                 Y, 
-                                 nFlags & MK_CONTROL, 
+  this->SetEventInformationFlipY(X,
+                                 Y,
+                                 nFlags & MK_CONTROL,
                                  nFlags & MK_SHIFT,
                                  0, repeat);
   this->SetAltKey(GetKeyState(VK_MENU) & (~1));
@@ -516,16 +518,16 @@ void vtkWin32RenderWindowInteractor::OnRButtonDown(HWND wnd,UINT nFlags,
 }
 
 //----------------------------------------------------------------------------
-void vtkWin32RenderWindowInteractor::OnRButtonUp(HWND,UINT nFlags, 
-                                                 int X, int Y) 
+void vtkWin32RenderWindowInteractor::OnRButtonUp(HWND,UINT nFlags,
+                                                 int X, int Y)
 {
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
-  this->SetEventInformationFlipY(X, 
-                                 Y, 
-                                 nFlags & MK_CONTROL, 
+  this->SetEventInformationFlipY(X,
+                                 Y,
+                                 nFlags & MK_CONTROL,
                                  nFlags & MK_SHIFT);
   this->SetAltKey(GetKeyState(VK_MENU) & (~1));
   this->InvokeEvent(vtkCommand::RightButtonReleaseEvent,NULL);
@@ -542,15 +544,15 @@ void vtkWin32RenderWindowInteractor::OnSize(HWND,UINT, int X, int Y) {
 }
 
 //----------------------------------------------------------------------------
-void vtkWin32RenderWindowInteractor::OnTimer(HWND,UINT timerId) 
+void vtkWin32RenderWindowInteractor::OnTimer(HWND,UINT timerId)
 {
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
   int tid = static_cast<int>(timerId);
   this->InvokeEvent(vtkCommand::TimerEvent,(void*)&tid);
-  
+
   // Here we deal with one-shot versus repeating timers
   if ( this->IsOneShotTimer(tid) )
     {
@@ -578,7 +580,7 @@ void vtkWin32RenderWindowInteractor::OnKeyDown(HWND, UINT vCode, UINT nRepCnt, U
       nChar = 0;
       }
 #endif
-  } 
+  }
   const char *keysym = AsciiToKeySymTable[(unsigned char)nChar];
   if (keysym == 0)
     {
@@ -588,10 +590,10 @@ void vtkWin32RenderWindowInteractor::OnKeyDown(HWND, UINT vCode, UINT nRepCnt, U
     {
     keysym = "None";
     }
-  this->SetKeyEventInformation(ctrl, 
-                               shift, 
-                               nChar, 
-                               nRepCnt, 
+  this->SetKeyEventInformation(ctrl,
+                               shift,
+                               nChar,
+                               nRepCnt,
                                keysym);
   this->SetAltKey(alt);
   this->InvokeEvent(vtkCommand::KeyPressEvent, NULL);
@@ -627,10 +629,10 @@ void vtkWin32RenderWindowInteractor::OnKeyUp(HWND, UINT vCode, UINT nRepCnt, UIN
     {
     keysym = "None";
     }
-  this->SetKeyEventInformation(ctrl, 
-                               shift, 
-                               nChar, 
-                               nRepCnt, 
+  this->SetKeyEventInformation(ctrl,
+                               shift,
+                               nChar,
+                               nRepCnt,
                                keysym);
   this->SetAltKey(alt);
   this->InvokeEvent(vtkCommand::KeyReleaseEvent, NULL);
@@ -645,11 +647,11 @@ void vtkWin32RenderWindowInteractor::OnChar(HWND,UINT nChar,
     return;
     }
   int ctrl  = GetKeyState(VK_CONTROL) & (~1);
-  int shift = GetKeyState(VK_SHIFT) & (~1); 
+  int shift = GetKeyState(VK_SHIFT) & (~1);
   int alt = GetKeyState(VK_MENU) & (~1);
-  this->SetKeyEventInformation(ctrl, 
-                               shift, 
-                               nChar, 
+  this->SetKeyEventInformation(ctrl,
+                               shift,
+                               nChar,
                                nRepCnt);
   this->SetAltKey(alt);
   this->InvokeEvent(vtkCommand::CharEvent, NULL);
@@ -658,11 +660,11 @@ void vtkWin32RenderWindowInteractor::OnChar(HWND,UINT nChar,
 //----------------------------------------------------------------------------
 void vtkWin32RenderWindowInteractor::OnFocus(HWND,UINT)
 {
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
-  
+
 #ifdef VTK_USE_TDX
   if(this->Device->GetInitialized() && !this->Device->GetIsListening())
     {
@@ -674,7 +676,7 @@ void vtkWin32RenderWindowInteractor::OnFocus(HWND,UINT)
 //----------------------------------------------------------------------------
 void vtkWin32RenderWindowInteractor::OnKillFocus(HWND,UINT)
 {
-  if (!this->Enabled) 
+  if (!this->Enabled)
     {
     return;
     }
@@ -688,8 +690,8 @@ void vtkWin32RenderWindowInteractor::OnKillFocus(HWND,UINT)
 
 //----------------------------------------------------------------------------
 // This is only called when InstallMessageProc is true
-LRESULT CALLBACK vtkHandleMessage(HWND hWnd,UINT uMsg, WPARAM wParam, 
-                                  LPARAM lParam) 
+LRESULT CALLBACK vtkHandleMessage(HWND hWnd,UINT uMsg, WPARAM wParam,
+                                  LPARAM lParam)
 {
   LRESULT res = 0;
   vtkWin32OpenGLRenderWindow *ren;
@@ -713,33 +715,33 @@ LRESULT CALLBACK vtkHandleMessage(HWND hWnd,UINT uMsg, WPARAM wParam,
 }
 
 #ifndef MAKEPOINTS
-#define MAKEPOINTS(l)   (*((POINTS FAR *) & (l))) 
+#define MAKEPOINTS(l)   (*((POINTS FAR *) & (l)))
 #endif
 
 //----------------------------------------------------------------------------
-LRESULT CALLBACK vtkHandleMessage2(HWND hWnd,UINT uMsg, WPARAM wParam, 
-                                   LPARAM lParam, 
-                                   vtkWin32RenderWindowInteractor *me) 
+LRESULT CALLBACK vtkHandleMessage2(HWND hWnd,UINT uMsg, WPARAM wParam,
+                                   LPARAM lParam,
+                                   vtkWin32RenderWindowInteractor *me)
 {
-  if ((uMsg == WM_USER+13)&&(wParam == 26)) 
+  if ((uMsg == WM_USER+13)&&(wParam == 26))
     {
     // someone is telling us to set our OldProc
     me->OldProc = (WNDPROC)lParam;
     return 1;
     }
-  
-  switch (uMsg) 
+
+  switch (uMsg)
     {
     case WM_PAINT:
       me->Render();
       return CallWindowProc(me->OldProc,hWnd,uMsg,wParam,lParam);
       break;
-      
+
     case WM_SIZE:
       me->OnSize(hWnd,wParam,LOWORD(lParam),HIWORD(lParam));
       return CallWindowProc(me->OldProc,hWnd,uMsg,wParam,lParam);
       break;
-      
+
     case WM_LBUTTONDBLCLK:
       me->OnLButtonDown(hWnd,wParam,MAKEPOINTS(lParam).x,MAKEPOINTS(lParam).y, 1);
       break;
@@ -747,7 +749,7 @@ LRESULT CALLBACK vtkHandleMessage2(HWND hWnd,UINT uMsg, WPARAM wParam,
     case WM_LBUTTONDOWN:
       me->OnLButtonDown(hWnd,wParam,MAKEPOINTS(lParam).x,MAKEPOINTS(lParam).y, 0);
       break;
-      
+
     case WM_LBUTTONUP:
       me->OnLButtonUp(hWnd,wParam,MAKEPOINTS(lParam).x,MAKEPOINTS(lParam).y);
       break;
@@ -759,11 +761,11 @@ LRESULT CALLBACK vtkHandleMessage2(HWND hWnd,UINT uMsg, WPARAM wParam,
     case WM_MBUTTONDOWN:
       me->OnMButtonDown(hWnd,wParam,MAKEPOINTS(lParam).x,MAKEPOINTS(lParam).y, 0);
       break;
-      
+
     case WM_MBUTTONUP:
       me->OnMButtonUp(hWnd,wParam,MAKEPOINTS(lParam).x,MAKEPOINTS(lParam).y);
       break;
-      
+
     case WM_RBUTTONDBLCLK:
       me->OnRButtonDown(hWnd,wParam,MAKEPOINTS(lParam).x,MAKEPOINTS(lParam).y, 1);
       break;
@@ -771,7 +773,7 @@ LRESULT CALLBACK vtkHandleMessage2(HWND hWnd,UINT uMsg, WPARAM wParam,
     case WM_RBUTTONDOWN:
       me->OnRButtonDown(hWnd,wParam,MAKEPOINTS(lParam).x,MAKEPOINTS(lParam).y, 0);
       break;
-      
+
     case WM_RBUTTONUP:
       me->OnRButtonUp(hWnd,wParam,MAKEPOINTS(lParam).x,MAKEPOINTS(lParam).y);
       break;
@@ -811,7 +813,7 @@ LRESULT CALLBACK vtkHandleMessage2(HWND hWnd,UINT uMsg, WPARAM wParam,
     case WM_CHAR:
       me->OnChar(hWnd,wParam,LOWORD(lParam),HIWORD(lParam));
       break;
-      
+
     case WM_KEYDOWN:
     case WM_SYSKEYDOWN:
       me->OnKeyDown(hWnd,wParam,LOWORD(lParam),HIWORD(lParam));
@@ -823,7 +825,7 @@ LRESULT CALLBACK vtkHandleMessage2(HWND hWnd,UINT uMsg, WPARAM wParam,
       break;
 
     case WM_TIMER:
-      me->OnTimer(hWnd,wParam);    
+      me->OnTimer(hWnd,wParam);
       break;
 
     case WM_ACTIVATE:
@@ -836,25 +838,25 @@ LRESULT CALLBACK vtkHandleMessage2(HWND hWnd,UINT uMsg, WPARAM wParam,
         me->OnFocus(hWnd,wParam);
         }
       break;
-      
+
     case WM_SETFOCUS:
       // occurs when SetFocus() is called on the current window
       me->OnFocus(hWnd,wParam);
       break;
-      
+
     case WM_KILLFOCUS:
       // occurs when the focus was on the current window and SetFocus() is
-      // called on another window. 
+      // called on another window.
       me->OnKillFocus(hWnd,wParam);
       break;
-      
+
     default:
-      if (me) 
+      if (me)
         {
         return CallWindowProc(me->OldProc,hWnd,uMsg,wParam,lParam);
         }
     };
-  
+
   return 0;
 }
 
